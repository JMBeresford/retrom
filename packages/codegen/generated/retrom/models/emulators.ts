// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: retrom/models/emulators.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../google/protobuf/timestamp";

export const protobufPackage = "retrom";

export const SaveStrategy = { SINGLE_FILE: 0, FILE_SYSTEM_DIRECTORY: 1, DISK_IMAGE: 2, UNRECOGNIZED: -1 } as const;

export type SaveStrategy = typeof SaveStrategy[keyof typeof SaveStrategy];

export namespace SaveStrategy {
  export type SINGLE_FILE = typeof SaveStrategy.SINGLE_FILE;
  export type FILE_SYSTEM_DIRECTORY = typeof SaveStrategy.FILE_SYSTEM_DIRECTORY;
  export type DISK_IMAGE = typeof SaveStrategy.DISK_IMAGE;
  export type UNRECOGNIZED = typeof SaveStrategy.UNRECOGNIZED;
}

export function saveStrategyFromJSON(object: any): SaveStrategy {
  switch (object) {
    case 0:
    case "SINGLE_FILE":
      return SaveStrategy.SINGLE_FILE;
    case 1:
    case "FILE_SYSTEM_DIRECTORY":
      return SaveStrategy.FILE_SYSTEM_DIRECTORY;
    case 2:
    case "DISK_IMAGE":
      return SaveStrategy.DISK_IMAGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SaveStrategy.UNRECOGNIZED;
  }
}

export function saveStrategyToJSON(object: SaveStrategy): string {
  switch (object) {
    case SaveStrategy.SINGLE_FILE:
      return "SINGLE_FILE";
    case SaveStrategy.FILE_SYSTEM_DIRECTORY:
      return "FILE_SYSTEM_DIRECTORY";
    case SaveStrategy.DISK_IMAGE:
      return "DISK_IMAGE";
    case SaveStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Emulator {
  id: number;
  supportedPlatforms: number[];
  name: string;
  saveStrategy: SaveStrategy;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
}

export interface NewEmulator {
  supportedPlatforms: number[];
  name: string;
  saveStrategy: SaveStrategy;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
}

export interface UpdatedEmulator {
  id: number;
  supportedPlatforms: number[];
  name?: string | undefined;
  saveStrategy?: SaveStrategy | undefined;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
}

export interface EmulatorProfile {
  id: number;
  emulatorId: number;
  name: string;
  supportedExtensions: string[];
  customArgs: string[];
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  builtIn: boolean;
}

export interface NewEmulatorProfile {
  emulatorId: number;
  name: string;
  supportedExtensions: string[];
  customArgs: string[];
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  builtIn?: boolean | undefined;
}

export interface UpdatedEmulatorProfile {
  id: number;
  emulatorId?: number | undefined;
  name?: string | undefined;
  supportedExtensions: string[];
  customArgs: string[];
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  builtIn?: boolean | undefined;
}

export interface DefaultEmulatorProfile {
  platformId: number;
  emulatorProfileId: number;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  clientId: number;
}

export interface NewDefaultEmulatorProfile {
  platformId: number;
  emulatorProfileId: number;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  clientId?: number | undefined;
}

export interface UpdatedDefaultEmulatorProfile {
  platformId: number;
  emulatorProfileId: number;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  clientId?: number | undefined;
}

export interface LocalEmulatorConfig {
  id: number;
  emulatorId: number;
  clientId: number;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  executablePath: string;
  nickname?: string | undefined;
}

export interface NewLocalEmulatorConfig {
  emulatorId: number;
  clientId: number;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  executablePath: string;
  nickname?: string | undefined;
}

export interface UpdatedLocalEmulatorConfig {
  id: number;
  emulatorId?: number | undefined;
  clientId?: number | undefined;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  executablePath?: string | undefined;
  nickname?: string | undefined;
}

function createBaseEmulator(): Emulator {
  return { id: 0, supportedPlatforms: [], name: "", saveStrategy: 0, createdAt: undefined, updatedAt: undefined };
}

export const Emulator: MessageFns<Emulator> = {
  encode(message: Emulator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    writer.uint32(18).fork();
    for (const v of message.supportedPlatforms) {
      writer.int32(v);
    }
    writer.join();
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.saveStrategy !== 0) {
      writer.uint32(32).int32(message.saveStrategy);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(42).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Emulator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmulator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.supportedPlatforms.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedPlatforms.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.saveStrategy = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Emulator {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      supportedPlatforms: globalThis.Array.isArray(object?.supportedPlatforms)
        ? object.supportedPlatforms.map((e: any) => globalThis.Number(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      saveStrategy: isSet(object.saveStrategy) ? saveStrategyFromJSON(object.saveStrategy) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: Emulator): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.supportedPlatforms?.length) {
      obj.supportedPlatforms = message.supportedPlatforms.map((e) => Math.round(e));
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.saveStrategy !== 0) {
      obj.saveStrategy = saveStrategyToJSON(message.saveStrategy);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Emulator>): Emulator {
    return Emulator.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Emulator>): Emulator {
    const message = createBaseEmulator();
    message.id = object.id ?? 0;
    message.supportedPlatforms = object.supportedPlatforms?.map((e) => e) || [];
    message.name = object.name ?? "";
    message.saveStrategy = object.saveStrategy ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    return message;
  },
};

function createBaseNewEmulator(): NewEmulator {
  return { supportedPlatforms: [], name: "", saveStrategy: 0, createdAt: undefined, updatedAt: undefined };
}

export const NewEmulator: MessageFns<NewEmulator> = {
  encode(message: NewEmulator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.supportedPlatforms) {
      writer.int32(v);
    }
    writer.join();
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.saveStrategy !== 0) {
      writer.uint32(24).int32(message.saveStrategy);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(34).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewEmulator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewEmulator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.supportedPlatforms.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedPlatforms.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.saveStrategy = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewEmulator {
    return {
      supportedPlatforms: globalThis.Array.isArray(object?.supportedPlatforms)
        ? object.supportedPlatforms.map((e: any) => globalThis.Number(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      saveStrategy: isSet(object.saveStrategy) ? saveStrategyFromJSON(object.saveStrategy) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: NewEmulator): unknown {
    const obj: any = {};
    if (message.supportedPlatforms?.length) {
      obj.supportedPlatforms = message.supportedPlatforms.map((e) => Math.round(e));
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.saveStrategy !== 0) {
      obj.saveStrategy = saveStrategyToJSON(message.saveStrategy);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<NewEmulator>): NewEmulator {
    return NewEmulator.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NewEmulator>): NewEmulator {
    const message = createBaseNewEmulator();
    message.supportedPlatforms = object.supportedPlatforms?.map((e) => e) || [];
    message.name = object.name ?? "";
    message.saveStrategy = object.saveStrategy ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    return message;
  },
};

function createBaseUpdatedEmulator(): UpdatedEmulator {
  return {
    id: 0,
    supportedPlatforms: [],
    name: undefined,
    saveStrategy: undefined,
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const UpdatedEmulator: MessageFns<UpdatedEmulator> = {
  encode(message: UpdatedEmulator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    writer.uint32(18).fork();
    for (const v of message.supportedPlatforms) {
      writer.int32(v);
    }
    writer.join();
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.saveStrategy !== undefined) {
      writer.uint32(32).int32(message.saveStrategy);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(42).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatedEmulator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatedEmulator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.supportedPlatforms.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedPlatforms.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.saveStrategy = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatedEmulator {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      supportedPlatforms: globalThis.Array.isArray(object?.supportedPlatforms)
        ? object.supportedPlatforms.map((e: any) => globalThis.Number(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      saveStrategy: isSet(object.saveStrategy) ? saveStrategyFromJSON(object.saveStrategy) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: UpdatedEmulator): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.supportedPlatforms?.length) {
      obj.supportedPlatforms = message.supportedPlatforms.map((e) => Math.round(e));
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.saveStrategy !== undefined) {
      obj.saveStrategy = saveStrategyToJSON(message.saveStrategy);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<UpdatedEmulator>): UpdatedEmulator {
    return UpdatedEmulator.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdatedEmulator>): UpdatedEmulator {
    const message = createBaseUpdatedEmulator();
    message.id = object.id ?? 0;
    message.supportedPlatforms = object.supportedPlatforms?.map((e) => e) || [];
    message.name = object.name ?? undefined;
    message.saveStrategy = object.saveStrategy ?? undefined;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    return message;
  },
};

function createBaseEmulatorProfile(): EmulatorProfile {
  return {
    id: 0,
    emulatorId: 0,
    name: "",
    supportedExtensions: [],
    customArgs: [],
    createdAt: undefined,
    updatedAt: undefined,
    builtIn: false,
  };
}

export const EmulatorProfile: MessageFns<EmulatorProfile> = {
  encode(message: EmulatorProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.emulatorId !== 0) {
      writer.uint32(16).int32(message.emulatorId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    for (const v of message.supportedExtensions) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.customArgs) {
      writer.uint32(42).string(v!);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(50).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(58).fork()).join();
    }
    if (message.builtIn !== false) {
      writer.uint32(64).bool(message.builtIn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmulatorProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmulatorProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.emulatorId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.supportedExtensions.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.customArgs.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.builtIn = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmulatorProfile {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      emulatorId: isSet(object.emulatorId) ? globalThis.Number(object.emulatorId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      supportedExtensions: globalThis.Array.isArray(object?.supportedExtensions)
        ? object.supportedExtensions.map((e: any) => globalThis.String(e))
        : [],
      customArgs: globalThis.Array.isArray(object?.customArgs)
        ? object.customArgs.map((e: any) => globalThis.String(e))
        : [],
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      builtIn: isSet(object.builtIn) ? globalThis.Boolean(object.builtIn) : false,
    };
  },

  toJSON(message: EmulatorProfile): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.emulatorId !== 0) {
      obj.emulatorId = Math.round(message.emulatorId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.supportedExtensions?.length) {
      obj.supportedExtensions = message.supportedExtensions;
    }
    if (message.customArgs?.length) {
      obj.customArgs = message.customArgs;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.builtIn !== false) {
      obj.builtIn = message.builtIn;
    }
    return obj;
  },

  create(base?: DeepPartial<EmulatorProfile>): EmulatorProfile {
    return EmulatorProfile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EmulatorProfile>): EmulatorProfile {
    const message = createBaseEmulatorProfile();
    message.id = object.id ?? 0;
    message.emulatorId = object.emulatorId ?? 0;
    message.name = object.name ?? "";
    message.supportedExtensions = object.supportedExtensions?.map((e) => e) || [];
    message.customArgs = object.customArgs?.map((e) => e) || [];
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.builtIn = object.builtIn ?? false;
    return message;
  },
};

function createBaseNewEmulatorProfile(): NewEmulatorProfile {
  return {
    emulatorId: 0,
    name: "",
    supportedExtensions: [],
    customArgs: [],
    createdAt: undefined,
    updatedAt: undefined,
    builtIn: undefined,
  };
}

export const NewEmulatorProfile: MessageFns<NewEmulatorProfile> = {
  encode(message: NewEmulatorProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emulatorId !== 0) {
      writer.uint32(8).int32(message.emulatorId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.supportedExtensions) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.customArgs) {
      writer.uint32(34).string(v!);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(42).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(50).fork()).join();
    }
    if (message.builtIn !== undefined) {
      writer.uint32(56).bool(message.builtIn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewEmulatorProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewEmulatorProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.emulatorId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.supportedExtensions.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.customArgs.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.builtIn = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewEmulatorProfile {
    return {
      emulatorId: isSet(object.emulatorId) ? globalThis.Number(object.emulatorId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      supportedExtensions: globalThis.Array.isArray(object?.supportedExtensions)
        ? object.supportedExtensions.map((e: any) => globalThis.String(e))
        : [],
      customArgs: globalThis.Array.isArray(object?.customArgs)
        ? object.customArgs.map((e: any) => globalThis.String(e))
        : [],
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      builtIn: isSet(object.builtIn) ? globalThis.Boolean(object.builtIn) : undefined,
    };
  },

  toJSON(message: NewEmulatorProfile): unknown {
    const obj: any = {};
    if (message.emulatorId !== 0) {
      obj.emulatorId = Math.round(message.emulatorId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.supportedExtensions?.length) {
      obj.supportedExtensions = message.supportedExtensions;
    }
    if (message.customArgs?.length) {
      obj.customArgs = message.customArgs;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.builtIn !== undefined) {
      obj.builtIn = message.builtIn;
    }
    return obj;
  },

  create(base?: DeepPartial<NewEmulatorProfile>): NewEmulatorProfile {
    return NewEmulatorProfile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NewEmulatorProfile>): NewEmulatorProfile {
    const message = createBaseNewEmulatorProfile();
    message.emulatorId = object.emulatorId ?? 0;
    message.name = object.name ?? "";
    message.supportedExtensions = object.supportedExtensions?.map((e) => e) || [];
    message.customArgs = object.customArgs?.map((e) => e) || [];
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.builtIn = object.builtIn ?? undefined;
    return message;
  },
};

function createBaseUpdatedEmulatorProfile(): UpdatedEmulatorProfile {
  return {
    id: 0,
    emulatorId: undefined,
    name: undefined,
    supportedExtensions: [],
    customArgs: [],
    createdAt: undefined,
    updatedAt: undefined,
    builtIn: undefined,
  };
}

export const UpdatedEmulatorProfile: MessageFns<UpdatedEmulatorProfile> = {
  encode(message: UpdatedEmulatorProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.emulatorId !== undefined) {
      writer.uint32(16).int32(message.emulatorId);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    for (const v of message.supportedExtensions) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.customArgs) {
      writer.uint32(42).string(v!);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(50).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(58).fork()).join();
    }
    if (message.builtIn !== undefined) {
      writer.uint32(64).bool(message.builtIn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatedEmulatorProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatedEmulatorProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.emulatorId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.supportedExtensions.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.customArgs.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.builtIn = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatedEmulatorProfile {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      emulatorId: isSet(object.emulatorId) ? globalThis.Number(object.emulatorId) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      supportedExtensions: globalThis.Array.isArray(object?.supportedExtensions)
        ? object.supportedExtensions.map((e: any) => globalThis.String(e))
        : [],
      customArgs: globalThis.Array.isArray(object?.customArgs)
        ? object.customArgs.map((e: any) => globalThis.String(e))
        : [],
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      builtIn: isSet(object.builtIn) ? globalThis.Boolean(object.builtIn) : undefined,
    };
  },

  toJSON(message: UpdatedEmulatorProfile): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.emulatorId !== undefined) {
      obj.emulatorId = Math.round(message.emulatorId);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.supportedExtensions?.length) {
      obj.supportedExtensions = message.supportedExtensions;
    }
    if (message.customArgs?.length) {
      obj.customArgs = message.customArgs;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.builtIn !== undefined) {
      obj.builtIn = message.builtIn;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdatedEmulatorProfile>): UpdatedEmulatorProfile {
    return UpdatedEmulatorProfile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdatedEmulatorProfile>): UpdatedEmulatorProfile {
    const message = createBaseUpdatedEmulatorProfile();
    message.id = object.id ?? 0;
    message.emulatorId = object.emulatorId ?? undefined;
    message.name = object.name ?? undefined;
    message.supportedExtensions = object.supportedExtensions?.map((e) => e) || [];
    message.customArgs = object.customArgs?.map((e) => e) || [];
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.builtIn = object.builtIn ?? undefined;
    return message;
  },
};

function createBaseDefaultEmulatorProfile(): DefaultEmulatorProfile {
  return { platformId: 0, emulatorProfileId: 0, createdAt: undefined, updatedAt: undefined, clientId: 0 };
}

export const DefaultEmulatorProfile: MessageFns<DefaultEmulatorProfile> = {
  encode(message: DefaultEmulatorProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.platformId !== 0) {
      writer.uint32(8).int32(message.platformId);
    }
    if (message.emulatorProfileId !== 0) {
      writer.uint32(16).int32(message.emulatorProfileId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(34).fork()).join();
    }
    if (message.clientId !== 0) {
      writer.uint32(40).int32(message.clientId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DefaultEmulatorProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultEmulatorProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.platformId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.emulatorProfileId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.clientId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DefaultEmulatorProfile {
    return {
      platformId: isSet(object.platformId) ? globalThis.Number(object.platformId) : 0,
      emulatorProfileId: isSet(object.emulatorProfileId) ? globalThis.Number(object.emulatorProfileId) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      clientId: isSet(object.clientId) ? globalThis.Number(object.clientId) : 0,
    };
  },

  toJSON(message: DefaultEmulatorProfile): unknown {
    const obj: any = {};
    if (message.platformId !== 0) {
      obj.platformId = Math.round(message.platformId);
    }
    if (message.emulatorProfileId !== 0) {
      obj.emulatorProfileId = Math.round(message.emulatorProfileId);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.clientId !== 0) {
      obj.clientId = Math.round(message.clientId);
    }
    return obj;
  },

  create(base?: DeepPartial<DefaultEmulatorProfile>): DefaultEmulatorProfile {
    return DefaultEmulatorProfile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DefaultEmulatorProfile>): DefaultEmulatorProfile {
    const message = createBaseDefaultEmulatorProfile();
    message.platformId = object.platformId ?? 0;
    message.emulatorProfileId = object.emulatorProfileId ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.clientId = object.clientId ?? 0;
    return message;
  },
};

function createBaseNewDefaultEmulatorProfile(): NewDefaultEmulatorProfile {
  return { platformId: 0, emulatorProfileId: 0, createdAt: undefined, updatedAt: undefined, clientId: undefined };
}

export const NewDefaultEmulatorProfile: MessageFns<NewDefaultEmulatorProfile> = {
  encode(message: NewDefaultEmulatorProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.platformId !== 0) {
      writer.uint32(8).int32(message.platformId);
    }
    if (message.emulatorProfileId !== 0) {
      writer.uint32(16).int32(message.emulatorProfileId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(34).fork()).join();
    }
    if (message.clientId !== undefined) {
      writer.uint32(40).int32(message.clientId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewDefaultEmulatorProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewDefaultEmulatorProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.platformId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.emulatorProfileId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.clientId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewDefaultEmulatorProfile {
    return {
      platformId: isSet(object.platformId) ? globalThis.Number(object.platformId) : 0,
      emulatorProfileId: isSet(object.emulatorProfileId) ? globalThis.Number(object.emulatorProfileId) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      clientId: isSet(object.clientId) ? globalThis.Number(object.clientId) : undefined,
    };
  },

  toJSON(message: NewDefaultEmulatorProfile): unknown {
    const obj: any = {};
    if (message.platformId !== 0) {
      obj.platformId = Math.round(message.platformId);
    }
    if (message.emulatorProfileId !== 0) {
      obj.emulatorProfileId = Math.round(message.emulatorProfileId);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.clientId !== undefined) {
      obj.clientId = Math.round(message.clientId);
    }
    return obj;
  },

  create(base?: DeepPartial<NewDefaultEmulatorProfile>): NewDefaultEmulatorProfile {
    return NewDefaultEmulatorProfile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NewDefaultEmulatorProfile>): NewDefaultEmulatorProfile {
    const message = createBaseNewDefaultEmulatorProfile();
    message.platformId = object.platformId ?? 0;
    message.emulatorProfileId = object.emulatorProfileId ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.clientId = object.clientId ?? undefined;
    return message;
  },
};

function createBaseUpdatedDefaultEmulatorProfile(): UpdatedDefaultEmulatorProfile {
  return { platformId: 0, emulatorProfileId: 0, createdAt: undefined, updatedAt: undefined, clientId: undefined };
}

export const UpdatedDefaultEmulatorProfile: MessageFns<UpdatedDefaultEmulatorProfile> = {
  encode(message: UpdatedDefaultEmulatorProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.platformId !== 0) {
      writer.uint32(8).int32(message.platformId);
    }
    if (message.emulatorProfileId !== 0) {
      writer.uint32(16).int32(message.emulatorProfileId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(34).fork()).join();
    }
    if (message.clientId !== undefined) {
      writer.uint32(40).int32(message.clientId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatedDefaultEmulatorProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatedDefaultEmulatorProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.platformId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.emulatorProfileId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.clientId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatedDefaultEmulatorProfile {
    return {
      platformId: isSet(object.platformId) ? globalThis.Number(object.platformId) : 0,
      emulatorProfileId: isSet(object.emulatorProfileId) ? globalThis.Number(object.emulatorProfileId) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      clientId: isSet(object.clientId) ? globalThis.Number(object.clientId) : undefined,
    };
  },

  toJSON(message: UpdatedDefaultEmulatorProfile): unknown {
    const obj: any = {};
    if (message.platformId !== 0) {
      obj.platformId = Math.round(message.platformId);
    }
    if (message.emulatorProfileId !== 0) {
      obj.emulatorProfileId = Math.round(message.emulatorProfileId);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.clientId !== undefined) {
      obj.clientId = Math.round(message.clientId);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdatedDefaultEmulatorProfile>): UpdatedDefaultEmulatorProfile {
    return UpdatedDefaultEmulatorProfile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdatedDefaultEmulatorProfile>): UpdatedDefaultEmulatorProfile {
    const message = createBaseUpdatedDefaultEmulatorProfile();
    message.platformId = object.platformId ?? 0;
    message.emulatorProfileId = object.emulatorProfileId ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.clientId = object.clientId ?? undefined;
    return message;
  },
};

function createBaseLocalEmulatorConfig(): LocalEmulatorConfig {
  return {
    id: 0,
    emulatorId: 0,
    clientId: 0,
    createdAt: undefined,
    updatedAt: undefined,
    executablePath: "",
    nickname: undefined,
  };
}

export const LocalEmulatorConfig: MessageFns<LocalEmulatorConfig> = {
  encode(message: LocalEmulatorConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.emulatorId !== 0) {
      writer.uint32(16).int32(message.emulatorId);
    }
    if (message.clientId !== 0) {
      writer.uint32(24).int32(message.clientId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(34).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(42).fork()).join();
    }
    if (message.executablePath !== "") {
      writer.uint32(50).string(message.executablePath);
    }
    if (message.nickname !== undefined) {
      writer.uint32(58).string(message.nickname);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalEmulatorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalEmulatorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.emulatorId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.clientId = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.executablePath = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalEmulatorConfig {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      emulatorId: isSet(object.emulatorId) ? globalThis.Number(object.emulatorId) : 0,
      clientId: isSet(object.clientId) ? globalThis.Number(object.clientId) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      executablePath: isSet(object.executablePath) ? globalThis.String(object.executablePath) : "",
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : undefined,
    };
  },

  toJSON(message: LocalEmulatorConfig): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.emulatorId !== 0) {
      obj.emulatorId = Math.round(message.emulatorId);
    }
    if (message.clientId !== 0) {
      obj.clientId = Math.round(message.clientId);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.executablePath !== "") {
      obj.executablePath = message.executablePath;
    }
    if (message.nickname !== undefined) {
      obj.nickname = message.nickname;
    }
    return obj;
  },

  create(base?: DeepPartial<LocalEmulatorConfig>): LocalEmulatorConfig {
    return LocalEmulatorConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocalEmulatorConfig>): LocalEmulatorConfig {
    const message = createBaseLocalEmulatorConfig();
    message.id = object.id ?? 0;
    message.emulatorId = object.emulatorId ?? 0;
    message.clientId = object.clientId ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.executablePath = object.executablePath ?? "";
    message.nickname = object.nickname ?? undefined;
    return message;
  },
};

function createBaseNewLocalEmulatorConfig(): NewLocalEmulatorConfig {
  return {
    emulatorId: 0,
    clientId: 0,
    createdAt: undefined,
    updatedAt: undefined,
    executablePath: "",
    nickname: undefined,
  };
}

export const NewLocalEmulatorConfig: MessageFns<NewLocalEmulatorConfig> = {
  encode(message: NewLocalEmulatorConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emulatorId !== 0) {
      writer.uint32(8).int32(message.emulatorId);
    }
    if (message.clientId !== 0) {
      writer.uint32(16).int32(message.clientId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(34).fork()).join();
    }
    if (message.executablePath !== "") {
      writer.uint32(42).string(message.executablePath);
    }
    if (message.nickname !== undefined) {
      writer.uint32(50).string(message.nickname);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewLocalEmulatorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewLocalEmulatorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.emulatorId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.clientId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.executablePath = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewLocalEmulatorConfig {
    return {
      emulatorId: isSet(object.emulatorId) ? globalThis.Number(object.emulatorId) : 0,
      clientId: isSet(object.clientId) ? globalThis.Number(object.clientId) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      executablePath: isSet(object.executablePath) ? globalThis.String(object.executablePath) : "",
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : undefined,
    };
  },

  toJSON(message: NewLocalEmulatorConfig): unknown {
    const obj: any = {};
    if (message.emulatorId !== 0) {
      obj.emulatorId = Math.round(message.emulatorId);
    }
    if (message.clientId !== 0) {
      obj.clientId = Math.round(message.clientId);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.executablePath !== "") {
      obj.executablePath = message.executablePath;
    }
    if (message.nickname !== undefined) {
      obj.nickname = message.nickname;
    }
    return obj;
  },

  create(base?: DeepPartial<NewLocalEmulatorConfig>): NewLocalEmulatorConfig {
    return NewLocalEmulatorConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NewLocalEmulatorConfig>): NewLocalEmulatorConfig {
    const message = createBaseNewLocalEmulatorConfig();
    message.emulatorId = object.emulatorId ?? 0;
    message.clientId = object.clientId ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.executablePath = object.executablePath ?? "";
    message.nickname = object.nickname ?? undefined;
    return message;
  },
};

function createBaseUpdatedLocalEmulatorConfig(): UpdatedLocalEmulatorConfig {
  return {
    id: 0,
    emulatorId: undefined,
    clientId: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    executablePath: undefined,
    nickname: undefined,
  };
}

export const UpdatedLocalEmulatorConfig: MessageFns<UpdatedLocalEmulatorConfig> = {
  encode(message: UpdatedLocalEmulatorConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.emulatorId !== undefined) {
      writer.uint32(16).int32(message.emulatorId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(24).int32(message.clientId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(34).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(42).fork()).join();
    }
    if (message.executablePath !== undefined) {
      writer.uint32(50).string(message.executablePath);
    }
    if (message.nickname !== undefined) {
      writer.uint32(58).string(message.nickname);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatedLocalEmulatorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatedLocalEmulatorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.emulatorId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.clientId = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.executablePath = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatedLocalEmulatorConfig {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      emulatorId: isSet(object.emulatorId) ? globalThis.Number(object.emulatorId) : undefined,
      clientId: isSet(object.clientId) ? globalThis.Number(object.clientId) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      executablePath: isSet(object.executablePath) ? globalThis.String(object.executablePath) : undefined,
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : undefined,
    };
  },

  toJSON(message: UpdatedLocalEmulatorConfig): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.emulatorId !== undefined) {
      obj.emulatorId = Math.round(message.emulatorId);
    }
    if (message.clientId !== undefined) {
      obj.clientId = Math.round(message.clientId);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.executablePath !== undefined) {
      obj.executablePath = message.executablePath;
    }
    if (message.nickname !== undefined) {
      obj.nickname = message.nickname;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdatedLocalEmulatorConfig>): UpdatedLocalEmulatorConfig {
    return UpdatedLocalEmulatorConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdatedLocalEmulatorConfig>): UpdatedLocalEmulatorConfig {
    const message = createBaseUpdatedLocalEmulatorConfig();
    message.id = object.id ?? 0;
    message.emulatorId = object.emulatorId ?? undefined;
    message.clientId = object.clientId ?? undefined;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.executablePath = object.executablePath ?? undefined;
    message.nickname = object.nickname ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Timestamp {
  if (o instanceof globalThis.Date) {
    return toTimestamp(o);
  } else if (typeof o === "string") {
    return toTimestamp(new globalThis.Date(o));
  } else {
    return Timestamp.fromJSON(o);
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
