// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: retrom/server/config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "retrom";

export const StorageType = {
  /**
   * SINGLE_FILE_GAME - Standard library directory with single-file games
   * e.g. /contentDir/platformX/game.rom
   */
  SINGLE_FILE_GAME: 0,
  /**
   * MULTI_FILE_GAME - Standard library directory with multi-file games
   * e.g. /contentDir/platformX/game/game.rom
   */
  MULTI_FILE_GAME: 1,
  /**
   * CUSTOM - Custom, user-defined structure composed of named macros
   * used for non-standard library directories and/or automatic
   * tagging of scanned entries
   *
   * example user definition: "/some/path/{platform}/{game}/{region}/{file}"
   */
  CUSTOM: 2,
  UNRECOGNIZED: -1,
} as const;

export type StorageType = typeof StorageType[keyof typeof StorageType];

export namespace StorageType {
  export type SINGLE_FILE_GAME = typeof StorageType.SINGLE_FILE_GAME;
  export type MULTI_FILE_GAME = typeof StorageType.MULTI_FILE_GAME;
  export type CUSTOM = typeof StorageType.CUSTOM;
  export type UNRECOGNIZED = typeof StorageType.UNRECOGNIZED;
}

export function storageTypeFromJSON(object: any): StorageType {
  switch (object) {
    case 0:
    case "SINGLE_FILE_GAME":
      return StorageType.SINGLE_FILE_GAME;
    case 1:
    case "MULTI_FILE_GAME":
      return StorageType.MULTI_FILE_GAME;
    case 2:
    case "CUSTOM":
      return StorageType.CUSTOM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StorageType.UNRECOGNIZED;
  }
}

export function storageTypeToJSON(object: StorageType): string {
  switch (object) {
    case StorageType.SINGLE_FILE_GAME:
      return "SINGLE_FILE_GAME";
    case StorageType.MULTI_FILE_GAME:
      return "MULTI_FILE_GAME";
    case StorageType.CUSTOM:
      return "CUSTOM";
    case StorageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ConnectionConfig {
  port?: number | undefined;
  dbUrl?: string | undefined;
}

export interface IgnorePatterns {
  patterns: string[];
}

export interface CustomLibraryDefinition {
  definition: string;
}

export interface ContentDirectory {
  path: string;
  storageType?: StorageType | undefined;
  ignorePatterns?: IgnorePatterns | undefined;
  customLibraryDefinition?: CustomLibraryDefinition | undefined;
}

export interface IGDBConfig {
  clientId: string;
  clientSecret: string;
}

export interface SteamConfig {
  apiKey: string;
  userId: string;
}

export interface ServerConfig {
  connection?: ConnectionConfig | undefined;
  contentDirectories: ContentDirectory[];
  igdb?: IGDBConfig | undefined;
  steam?: SteamConfig | undefined;
}

function createBaseConnectionConfig(): ConnectionConfig {
  return { port: undefined, dbUrl: undefined };
}

export const ConnectionConfig: MessageFns<ConnectionConfig> = {
  encode(message: ConnectionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.port !== undefined) {
      writer.uint32(8).int32(message.port);
    }
    if (message.dbUrl !== undefined) {
      writer.uint32(18).string(message.dbUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dbUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionConfig {
    return {
      port: isSet(object.port) ? globalThis.Number(object.port) : undefined,
      dbUrl: isSet(object.dbUrl) ? globalThis.String(object.dbUrl) : undefined,
    };
  },

  toJSON(message: ConnectionConfig): unknown {
    const obj: any = {};
    if (message.port !== undefined) {
      obj.port = Math.round(message.port);
    }
    if (message.dbUrl !== undefined) {
      obj.dbUrl = message.dbUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectionConfig>): ConnectionConfig {
    return ConnectionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectionConfig>): ConnectionConfig {
    const message = createBaseConnectionConfig();
    message.port = object.port ?? undefined;
    message.dbUrl = object.dbUrl ?? undefined;
    return message;
  },
};

function createBaseIgnorePatterns(): IgnorePatterns {
  return { patterns: [] };
}

export const IgnorePatterns: MessageFns<IgnorePatterns> = {
  encode(message: IgnorePatterns, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.patterns) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IgnorePatterns {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIgnorePatterns();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.patterns.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IgnorePatterns {
    return {
      patterns: globalThis.Array.isArray(object?.patterns) ? object.patterns.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: IgnorePatterns): unknown {
    const obj: any = {};
    if (message.patterns?.length) {
      obj.patterns = message.patterns;
    }
    return obj;
  },

  create(base?: DeepPartial<IgnorePatterns>): IgnorePatterns {
    return IgnorePatterns.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IgnorePatterns>): IgnorePatterns {
    const message = createBaseIgnorePatterns();
    message.patterns = object.patterns?.map((e) => e) || [];
    return message;
  },
};

function createBaseCustomLibraryDefinition(): CustomLibraryDefinition {
  return { definition: "" };
}

export const CustomLibraryDefinition: MessageFns<CustomLibraryDefinition> = {
  encode(message: CustomLibraryDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.definition !== "") {
      writer.uint32(10).string(message.definition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomLibraryDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomLibraryDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.definition = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomLibraryDefinition {
    return { definition: isSet(object.definition) ? globalThis.String(object.definition) : "" };
  },

  toJSON(message: CustomLibraryDefinition): unknown {
    const obj: any = {};
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomLibraryDefinition>): CustomLibraryDefinition {
    return CustomLibraryDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomLibraryDefinition>): CustomLibraryDefinition {
    const message = createBaseCustomLibraryDefinition();
    message.definition = object.definition ?? "";
    return message;
  },
};

function createBaseContentDirectory(): ContentDirectory {
  return { path: "", storageType: undefined, ignorePatterns: undefined, customLibraryDefinition: undefined };
}

export const ContentDirectory: MessageFns<ContentDirectory> = {
  encode(message: ContentDirectory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.storageType !== undefined) {
      writer.uint32(16).int32(message.storageType);
    }
    if (message.ignorePatterns !== undefined) {
      IgnorePatterns.encode(message.ignorePatterns, writer.uint32(26).fork()).join();
    }
    if (message.customLibraryDefinition !== undefined) {
      CustomLibraryDefinition.encode(message.customLibraryDefinition, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContentDirectory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentDirectory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.storageType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ignorePatterns = IgnorePatterns.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.customLibraryDefinition = CustomLibraryDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContentDirectory {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      storageType: isSet(object.storageType) ? storageTypeFromJSON(object.storageType) : undefined,
      ignorePatterns: isSet(object.ignorePatterns) ? IgnorePatterns.fromJSON(object.ignorePatterns) : undefined,
      customLibraryDefinition: isSet(object.customLibraryDefinition)
        ? CustomLibraryDefinition.fromJSON(object.customLibraryDefinition)
        : undefined,
    };
  },

  toJSON(message: ContentDirectory): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.storageType !== undefined) {
      obj.storageType = storageTypeToJSON(message.storageType);
    }
    if (message.ignorePatterns !== undefined) {
      obj.ignorePatterns = IgnorePatterns.toJSON(message.ignorePatterns);
    }
    if (message.customLibraryDefinition !== undefined) {
      obj.customLibraryDefinition = CustomLibraryDefinition.toJSON(message.customLibraryDefinition);
    }
    return obj;
  },

  create(base?: DeepPartial<ContentDirectory>): ContentDirectory {
    return ContentDirectory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContentDirectory>): ContentDirectory {
    const message = createBaseContentDirectory();
    message.path = object.path ?? "";
    message.storageType = object.storageType ?? undefined;
    message.ignorePatterns = (object.ignorePatterns !== undefined && object.ignorePatterns !== null)
      ? IgnorePatterns.fromPartial(object.ignorePatterns)
      : undefined;
    message.customLibraryDefinition =
      (object.customLibraryDefinition !== undefined && object.customLibraryDefinition !== null)
        ? CustomLibraryDefinition.fromPartial(object.customLibraryDefinition)
        : undefined;
    return message;
  },
};

function createBaseIGDBConfig(): IGDBConfig {
  return { clientId: "", clientSecret: "" };
}

export const IGDBConfig: MessageFns<IGDBConfig> = {
  encode(message: IGDBConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.clientSecret !== "") {
      writer.uint32(18).string(message.clientSecret);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IGDBConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIGDBConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IGDBConfig {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      clientSecret: isSet(object.clientSecret) ? globalThis.String(object.clientSecret) : "",
    };
  },

  toJSON(message: IGDBConfig): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.clientSecret !== "") {
      obj.clientSecret = message.clientSecret;
    }
    return obj;
  },

  create(base?: DeepPartial<IGDBConfig>): IGDBConfig {
    return IGDBConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IGDBConfig>): IGDBConfig {
    const message = createBaseIGDBConfig();
    message.clientId = object.clientId ?? "";
    message.clientSecret = object.clientSecret ?? "";
    return message;
  },
};

function createBaseSteamConfig(): SteamConfig {
  return { apiKey: "", userId: "" };
}

export const SteamConfig: MessageFns<SteamConfig> = {
  encode(message: SteamConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiKey !== "") {
      writer.uint32(10).string(message.apiKey);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SteamConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSteamConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SteamConfig {
    return {
      apiKey: isSet(object.apiKey) ? globalThis.String(object.apiKey) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: SteamConfig): unknown {
    const obj: any = {};
    if (message.apiKey !== "") {
      obj.apiKey = message.apiKey;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create(base?: DeepPartial<SteamConfig>): SteamConfig {
    return SteamConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SteamConfig>): SteamConfig {
    const message = createBaseSteamConfig();
    message.apiKey = object.apiKey ?? "";
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseServerConfig(): ServerConfig {
  return { connection: undefined, contentDirectories: [], igdb: undefined, steam: undefined };
}

export const ServerConfig: MessageFns<ServerConfig> = {
  encode(message: ServerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connection !== undefined) {
      ConnectionConfig.encode(message.connection, writer.uint32(10).fork()).join();
    }
    for (const v of message.contentDirectories) {
      ContentDirectory.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.igdb !== undefined) {
      IGDBConfig.encode(message.igdb, writer.uint32(26).fork()).join();
    }
    if (message.steam !== undefined) {
      SteamConfig.encode(message.steam, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connection = ConnectionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contentDirectories.push(ContentDirectory.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.igdb = IGDBConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.steam = SteamConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerConfig {
    return {
      connection: isSet(object.connection) ? ConnectionConfig.fromJSON(object.connection) : undefined,
      contentDirectories: globalThis.Array.isArray(object?.contentDirectories)
        ? object.contentDirectories.map((e: any) => ContentDirectory.fromJSON(e))
        : [],
      igdb: isSet(object.igdb) ? IGDBConfig.fromJSON(object.igdb) : undefined,
      steam: isSet(object.steam) ? SteamConfig.fromJSON(object.steam) : undefined,
    };
  },

  toJSON(message: ServerConfig): unknown {
    const obj: any = {};
    if (message.connection !== undefined) {
      obj.connection = ConnectionConfig.toJSON(message.connection);
    }
    if (message.contentDirectories?.length) {
      obj.contentDirectories = message.contentDirectories.map((e) => ContentDirectory.toJSON(e));
    }
    if (message.igdb !== undefined) {
      obj.igdb = IGDBConfig.toJSON(message.igdb);
    }
    if (message.steam !== undefined) {
      obj.steam = SteamConfig.toJSON(message.steam);
    }
    return obj;
  },

  create(base?: DeepPartial<ServerConfig>): ServerConfig {
    return ServerConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServerConfig>): ServerConfig {
    const message = createBaseServerConfig();
    message.connection = (object.connection !== undefined && object.connection !== null)
      ? ConnectionConfig.fromPartial(object.connection)
      : undefined;
    message.contentDirectories = object.contentDirectories?.map((e) => ContentDirectory.fromPartial(e)) || [];
    message.igdb = (object.igdb !== undefined && object.igdb !== null)
      ? IGDBConfig.fromPartial(object.igdb)
      : undefined;
    message.steam = (object.steam !== undefined && object.steam !== null)
      ? SteamConfig.fromPartial(object.steam)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
