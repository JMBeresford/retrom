// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: igdbapi.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "igdb";

export const AgeRatingCategoryEnum = {
  /** @deprecated */
  AGERATING_CATEGORY_NULL: 0,
  /** @deprecated */
  ESRB: 1,
  /** @deprecated */
  PEGI: 2,
  /** @deprecated */
  CERO: 3,
  /** @deprecated */
  USK: 4,
  /** @deprecated */
  GRAC: 5,
  /** @deprecated */
  CLASS_IND: 6,
  /** @deprecated */
  ACB: 7,
  UNRECOGNIZED: -1,
} as const;

export type AgeRatingCategoryEnum = typeof AgeRatingCategoryEnum[keyof typeof AgeRatingCategoryEnum];

export namespace AgeRatingCategoryEnum {
  export type AGERATING_CATEGORY_NULL = typeof AgeRatingCategoryEnum.AGERATING_CATEGORY_NULL;
  export type ESRB = typeof AgeRatingCategoryEnum.ESRB;
  export type PEGI = typeof AgeRatingCategoryEnum.PEGI;
  export type CERO = typeof AgeRatingCategoryEnum.CERO;
  export type USK = typeof AgeRatingCategoryEnum.USK;
  export type GRAC = typeof AgeRatingCategoryEnum.GRAC;
  export type CLASS_IND = typeof AgeRatingCategoryEnum.CLASS_IND;
  export type ACB = typeof AgeRatingCategoryEnum.ACB;
  export type UNRECOGNIZED = typeof AgeRatingCategoryEnum.UNRECOGNIZED;
}

export function ageRatingCategoryEnumFromJSON(object: any): AgeRatingCategoryEnum {
  switch (object) {
    case 0:
    case "AGERATING_CATEGORY_NULL":
      return AgeRatingCategoryEnum.AGERATING_CATEGORY_NULL;
    case 1:
    case "ESRB":
      return AgeRatingCategoryEnum.ESRB;
    case 2:
    case "PEGI":
      return AgeRatingCategoryEnum.PEGI;
    case 3:
    case "CERO":
      return AgeRatingCategoryEnum.CERO;
    case 4:
    case "USK":
      return AgeRatingCategoryEnum.USK;
    case 5:
    case "GRAC":
      return AgeRatingCategoryEnum.GRAC;
    case 6:
    case "CLASS_IND":
      return AgeRatingCategoryEnum.CLASS_IND;
    case 7:
    case "ACB":
      return AgeRatingCategoryEnum.ACB;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AgeRatingCategoryEnum.UNRECOGNIZED;
  }
}

export function ageRatingCategoryEnumToJSON(object: AgeRatingCategoryEnum): string {
  switch (object) {
    case AgeRatingCategoryEnum.AGERATING_CATEGORY_NULL:
      return "AGERATING_CATEGORY_NULL";
    case AgeRatingCategoryEnum.ESRB:
      return "ESRB";
    case AgeRatingCategoryEnum.PEGI:
      return "PEGI";
    case AgeRatingCategoryEnum.CERO:
      return "CERO";
    case AgeRatingCategoryEnum.USK:
      return "USK";
    case AgeRatingCategoryEnum.GRAC:
      return "GRAC";
    case AgeRatingCategoryEnum.CLASS_IND:
      return "CLASS_IND";
    case AgeRatingCategoryEnum.ACB:
      return "ACB";
    case AgeRatingCategoryEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const AgeRatingRatingEnum = {
  /** @deprecated */
  AGERATING_RATING_NULL: 0,
  /** @deprecated */
  THREE: 1,
  /** @deprecated */
  SEVEN: 2,
  /** @deprecated */
  TWELVE: 3,
  /** @deprecated */
  SIXTEEN: 4,
  /** @deprecated */
  EIGHTEEN: 5,
  /** @deprecated */
  RP: 6,
  /** @deprecated */
  EC: 7,
  /** @deprecated */
  E: 8,
  /** @deprecated */
  E10: 9,
  /** @deprecated */
  T: 10,
  /** @deprecated */
  M: 11,
  /** @deprecated */
  AO: 12,
  /** @deprecated */
  CERO_A: 13,
  /** @deprecated */
  CERO_B: 14,
  /** @deprecated */
  CERO_C: 15,
  /** @deprecated */
  CERO_D: 16,
  /** @deprecated */
  CERO_Z: 17,
  /** @deprecated */
  USK_0: 18,
  /** @deprecated */
  USK_6: 19,
  /** @deprecated */
  USK_12: 20,
  /** @deprecated */
  USK_16: 21,
  /** @deprecated */
  USK_18: 22,
  /** @deprecated */
  GRAC_ALL: 23,
  /** @deprecated */
  GRAC_TWELVE: 24,
  /** @deprecated */
  GRAC_FIFTEEN: 25,
  /** @deprecated */
  GRAC_EIGHTEEN: 26,
  /** @deprecated */
  GRAC_TESTING: 27,
  /** @deprecated */
  CLASS_IND_L: 28,
  /** @deprecated */
  CLASS_IND_TEN: 29,
  /** @deprecated */
  CLASS_IND_TWELVE: 30,
  /** @deprecated */
  CLASS_IND_FOURTEEN: 31,
  /** @deprecated */
  CLASS_IND_SIXTEEN: 32,
  /** @deprecated */
  CLASS_IND_EIGHTEEN: 33,
  /** @deprecated */
  ACB_G: 34,
  /** @deprecated */
  ACB_PG: 35,
  /** @deprecated */
  ACB_M: 36,
  /** @deprecated */
  ACB_MA15: 37,
  /** @deprecated */
  ACB_R18: 38,
  /** @deprecated */
  ACB_RC: 39,
  UNRECOGNIZED: -1,
} as const;

export type AgeRatingRatingEnum = typeof AgeRatingRatingEnum[keyof typeof AgeRatingRatingEnum];

export namespace AgeRatingRatingEnum {
  export type AGERATING_RATING_NULL = typeof AgeRatingRatingEnum.AGERATING_RATING_NULL;
  export type THREE = typeof AgeRatingRatingEnum.THREE;
  export type SEVEN = typeof AgeRatingRatingEnum.SEVEN;
  export type TWELVE = typeof AgeRatingRatingEnum.TWELVE;
  export type SIXTEEN = typeof AgeRatingRatingEnum.SIXTEEN;
  export type EIGHTEEN = typeof AgeRatingRatingEnum.EIGHTEEN;
  export type RP = typeof AgeRatingRatingEnum.RP;
  export type EC = typeof AgeRatingRatingEnum.EC;
  export type E = typeof AgeRatingRatingEnum.E;
  export type E10 = typeof AgeRatingRatingEnum.E10;
  export type T = typeof AgeRatingRatingEnum.T;
  export type M = typeof AgeRatingRatingEnum.M;
  export type AO = typeof AgeRatingRatingEnum.AO;
  export type CERO_A = typeof AgeRatingRatingEnum.CERO_A;
  export type CERO_B = typeof AgeRatingRatingEnum.CERO_B;
  export type CERO_C = typeof AgeRatingRatingEnum.CERO_C;
  export type CERO_D = typeof AgeRatingRatingEnum.CERO_D;
  export type CERO_Z = typeof AgeRatingRatingEnum.CERO_Z;
  export type USK_0 = typeof AgeRatingRatingEnum.USK_0;
  export type USK_6 = typeof AgeRatingRatingEnum.USK_6;
  export type USK_12 = typeof AgeRatingRatingEnum.USK_12;
  export type USK_16 = typeof AgeRatingRatingEnum.USK_16;
  export type USK_18 = typeof AgeRatingRatingEnum.USK_18;
  export type GRAC_ALL = typeof AgeRatingRatingEnum.GRAC_ALL;
  export type GRAC_TWELVE = typeof AgeRatingRatingEnum.GRAC_TWELVE;
  export type GRAC_FIFTEEN = typeof AgeRatingRatingEnum.GRAC_FIFTEEN;
  export type GRAC_EIGHTEEN = typeof AgeRatingRatingEnum.GRAC_EIGHTEEN;
  export type GRAC_TESTING = typeof AgeRatingRatingEnum.GRAC_TESTING;
  export type CLASS_IND_L = typeof AgeRatingRatingEnum.CLASS_IND_L;
  export type CLASS_IND_TEN = typeof AgeRatingRatingEnum.CLASS_IND_TEN;
  export type CLASS_IND_TWELVE = typeof AgeRatingRatingEnum.CLASS_IND_TWELVE;
  export type CLASS_IND_FOURTEEN = typeof AgeRatingRatingEnum.CLASS_IND_FOURTEEN;
  export type CLASS_IND_SIXTEEN = typeof AgeRatingRatingEnum.CLASS_IND_SIXTEEN;
  export type CLASS_IND_EIGHTEEN = typeof AgeRatingRatingEnum.CLASS_IND_EIGHTEEN;
  export type ACB_G = typeof AgeRatingRatingEnum.ACB_G;
  export type ACB_PG = typeof AgeRatingRatingEnum.ACB_PG;
  export type ACB_M = typeof AgeRatingRatingEnum.ACB_M;
  export type ACB_MA15 = typeof AgeRatingRatingEnum.ACB_MA15;
  export type ACB_R18 = typeof AgeRatingRatingEnum.ACB_R18;
  export type ACB_RC = typeof AgeRatingRatingEnum.ACB_RC;
  export type UNRECOGNIZED = typeof AgeRatingRatingEnum.UNRECOGNIZED;
}

export function ageRatingRatingEnumFromJSON(object: any): AgeRatingRatingEnum {
  switch (object) {
    case 0:
    case "AGERATING_RATING_NULL":
      return AgeRatingRatingEnum.AGERATING_RATING_NULL;
    case 1:
    case "THREE":
      return AgeRatingRatingEnum.THREE;
    case 2:
    case "SEVEN":
      return AgeRatingRatingEnum.SEVEN;
    case 3:
    case "TWELVE":
      return AgeRatingRatingEnum.TWELVE;
    case 4:
    case "SIXTEEN":
      return AgeRatingRatingEnum.SIXTEEN;
    case 5:
    case "EIGHTEEN":
      return AgeRatingRatingEnum.EIGHTEEN;
    case 6:
    case "RP":
      return AgeRatingRatingEnum.RP;
    case 7:
    case "EC":
      return AgeRatingRatingEnum.EC;
    case 8:
    case "E":
      return AgeRatingRatingEnum.E;
    case 9:
    case "E10":
      return AgeRatingRatingEnum.E10;
    case 10:
    case "T":
      return AgeRatingRatingEnum.T;
    case 11:
    case "M":
      return AgeRatingRatingEnum.M;
    case 12:
    case "AO":
      return AgeRatingRatingEnum.AO;
    case 13:
    case "CERO_A":
      return AgeRatingRatingEnum.CERO_A;
    case 14:
    case "CERO_B":
      return AgeRatingRatingEnum.CERO_B;
    case 15:
    case "CERO_C":
      return AgeRatingRatingEnum.CERO_C;
    case 16:
    case "CERO_D":
      return AgeRatingRatingEnum.CERO_D;
    case 17:
    case "CERO_Z":
      return AgeRatingRatingEnum.CERO_Z;
    case 18:
    case "USK_0":
      return AgeRatingRatingEnum.USK_0;
    case 19:
    case "USK_6":
      return AgeRatingRatingEnum.USK_6;
    case 20:
    case "USK_12":
      return AgeRatingRatingEnum.USK_12;
    case 21:
    case "USK_16":
      return AgeRatingRatingEnum.USK_16;
    case 22:
    case "USK_18":
      return AgeRatingRatingEnum.USK_18;
    case 23:
    case "GRAC_ALL":
      return AgeRatingRatingEnum.GRAC_ALL;
    case 24:
    case "GRAC_TWELVE":
      return AgeRatingRatingEnum.GRAC_TWELVE;
    case 25:
    case "GRAC_FIFTEEN":
      return AgeRatingRatingEnum.GRAC_FIFTEEN;
    case 26:
    case "GRAC_EIGHTEEN":
      return AgeRatingRatingEnum.GRAC_EIGHTEEN;
    case 27:
    case "GRAC_TESTING":
      return AgeRatingRatingEnum.GRAC_TESTING;
    case 28:
    case "CLASS_IND_L":
      return AgeRatingRatingEnum.CLASS_IND_L;
    case 29:
    case "CLASS_IND_TEN":
      return AgeRatingRatingEnum.CLASS_IND_TEN;
    case 30:
    case "CLASS_IND_TWELVE":
      return AgeRatingRatingEnum.CLASS_IND_TWELVE;
    case 31:
    case "CLASS_IND_FOURTEEN":
      return AgeRatingRatingEnum.CLASS_IND_FOURTEEN;
    case 32:
    case "CLASS_IND_SIXTEEN":
      return AgeRatingRatingEnum.CLASS_IND_SIXTEEN;
    case 33:
    case "CLASS_IND_EIGHTEEN":
      return AgeRatingRatingEnum.CLASS_IND_EIGHTEEN;
    case 34:
    case "ACB_G":
      return AgeRatingRatingEnum.ACB_G;
    case 35:
    case "ACB_PG":
      return AgeRatingRatingEnum.ACB_PG;
    case 36:
    case "ACB_M":
      return AgeRatingRatingEnum.ACB_M;
    case 37:
    case "ACB_MA15":
      return AgeRatingRatingEnum.ACB_MA15;
    case 38:
    case "ACB_R18":
      return AgeRatingRatingEnum.ACB_R18;
    case 39:
    case "ACB_RC":
      return AgeRatingRatingEnum.ACB_RC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AgeRatingRatingEnum.UNRECOGNIZED;
  }
}

export function ageRatingRatingEnumToJSON(object: AgeRatingRatingEnum): string {
  switch (object) {
    case AgeRatingRatingEnum.AGERATING_RATING_NULL:
      return "AGERATING_RATING_NULL";
    case AgeRatingRatingEnum.THREE:
      return "THREE";
    case AgeRatingRatingEnum.SEVEN:
      return "SEVEN";
    case AgeRatingRatingEnum.TWELVE:
      return "TWELVE";
    case AgeRatingRatingEnum.SIXTEEN:
      return "SIXTEEN";
    case AgeRatingRatingEnum.EIGHTEEN:
      return "EIGHTEEN";
    case AgeRatingRatingEnum.RP:
      return "RP";
    case AgeRatingRatingEnum.EC:
      return "EC";
    case AgeRatingRatingEnum.E:
      return "E";
    case AgeRatingRatingEnum.E10:
      return "E10";
    case AgeRatingRatingEnum.T:
      return "T";
    case AgeRatingRatingEnum.M:
      return "M";
    case AgeRatingRatingEnum.AO:
      return "AO";
    case AgeRatingRatingEnum.CERO_A:
      return "CERO_A";
    case AgeRatingRatingEnum.CERO_B:
      return "CERO_B";
    case AgeRatingRatingEnum.CERO_C:
      return "CERO_C";
    case AgeRatingRatingEnum.CERO_D:
      return "CERO_D";
    case AgeRatingRatingEnum.CERO_Z:
      return "CERO_Z";
    case AgeRatingRatingEnum.USK_0:
      return "USK_0";
    case AgeRatingRatingEnum.USK_6:
      return "USK_6";
    case AgeRatingRatingEnum.USK_12:
      return "USK_12";
    case AgeRatingRatingEnum.USK_16:
      return "USK_16";
    case AgeRatingRatingEnum.USK_18:
      return "USK_18";
    case AgeRatingRatingEnum.GRAC_ALL:
      return "GRAC_ALL";
    case AgeRatingRatingEnum.GRAC_TWELVE:
      return "GRAC_TWELVE";
    case AgeRatingRatingEnum.GRAC_FIFTEEN:
      return "GRAC_FIFTEEN";
    case AgeRatingRatingEnum.GRAC_EIGHTEEN:
      return "GRAC_EIGHTEEN";
    case AgeRatingRatingEnum.GRAC_TESTING:
      return "GRAC_TESTING";
    case AgeRatingRatingEnum.CLASS_IND_L:
      return "CLASS_IND_L";
    case AgeRatingRatingEnum.CLASS_IND_TEN:
      return "CLASS_IND_TEN";
    case AgeRatingRatingEnum.CLASS_IND_TWELVE:
      return "CLASS_IND_TWELVE";
    case AgeRatingRatingEnum.CLASS_IND_FOURTEEN:
      return "CLASS_IND_FOURTEEN";
    case AgeRatingRatingEnum.CLASS_IND_SIXTEEN:
      return "CLASS_IND_SIXTEEN";
    case AgeRatingRatingEnum.CLASS_IND_EIGHTEEN:
      return "CLASS_IND_EIGHTEEN";
    case AgeRatingRatingEnum.ACB_G:
      return "ACB_G";
    case AgeRatingRatingEnum.ACB_PG:
      return "ACB_PG";
    case AgeRatingRatingEnum.ACB_M:
      return "ACB_M";
    case AgeRatingRatingEnum.ACB_MA15:
      return "ACB_MA15";
    case AgeRatingRatingEnum.ACB_R18:
      return "ACB_R18";
    case AgeRatingRatingEnum.ACB_RC:
      return "ACB_RC";
    case AgeRatingRatingEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const AgeRatingContentDescriptionCategoryEnum = {
  /** @deprecated */
  AGERATINGCONTENTDESCRIPTION_CATEGORY_NULL: 0,
  /** @deprecated */
  ESRB_ALCOHOL_REFERENCE: 1,
  /** @deprecated */
  ESRB_ANIMATED_BLOOD: 2,
  /** @deprecated */
  ESRB_BLOOD: 3,
  /** @deprecated */
  ESRB_BLOOD_AND_GORE: 4,
  /** @deprecated */
  ESRB_CARTOON_VIOLENCE: 5,
  /** @deprecated */
  ESRB_COMIC_MISCHIEF: 6,
  /** @deprecated */
  ESRB_CRUDE_HUMOR: 7,
  /** @deprecated */
  ESRB_DRUG_REFERENCE: 8,
  /** @deprecated */
  ESRB_FANTASY_VIOLENCE: 9,
  /** @deprecated */
  ESRB_INTENSE_VIOLENCE: 10,
  /** @deprecated */
  ESRB_LANGUAGE: 11,
  /** @deprecated */
  ESRB_LYRICS: 12,
  /** @deprecated */
  ESRB_MATURE_HUMOR: 13,
  /** @deprecated */
  ESRB_NUDITY: 14,
  /** @deprecated */
  ESRB_PARTIAL_NUDITY: 15,
  /** @deprecated */
  ESRB_REAL_GAMBLING: 16,
  /** @deprecated */
  ESRB_SEXUAL_CONTENT: 17,
  /** @deprecated */
  ESRB_SEXUAL_THEMES: 18,
  /** @deprecated */
  ESRB_SEXUAL_VIOLENCE: 19,
  /** @deprecated */
  ESRB_SIMULATED_GAMBLING: 20,
  /** @deprecated */
  ESRB_STRONG_LANGUAGE: 21,
  /** @deprecated */
  ESRB_STRONG_LYRICS: 22,
  /** @deprecated */
  ESRB_STRONG_SEXUAL_CONTENT: 23,
  /** @deprecated */
  ESRB_SUGGESTIVE_THEMES: 24,
  /** @deprecated */
  ESRB_TOBACCO_REFERENCE: 25,
  /** @deprecated */
  ESRB_USE_OF_ALCOHOL: 26,
  /** @deprecated */
  ESRB_USE_OF_DRUGS: 27,
  /** @deprecated */
  ESRB_USE_OF_TOBACCO: 28,
  /** @deprecated */
  ESRB_VIOLENCE: 29,
  /** @deprecated */
  ESRB_VIOLENT_REFERENCES: 30,
  /** @deprecated */
  ESRB_ANIMATED_VIOLENCE: 31,
  /** @deprecated */
  ESRB_MILD_LANGUAGE: 32,
  /** @deprecated */
  ESRB_MILD_VIOLENCE: 33,
  /** @deprecated */
  ESRB_USE_OF_DRUGS_AND_ALCOHOL: 34,
  /** @deprecated */
  ESRB_DRUG_AND_ALCOHOL_REFERENCE: 35,
  /** @deprecated */
  ESRB_MILD_SUGGESTIVE_THEMES: 36,
  /** @deprecated */
  ESRB_MILD_CARTOON_VIOLENCE: 37,
  /** @deprecated */
  ESRB_MILD_BLOOD: 38,
  /** @deprecated */
  ESRB_REALISTIC_BLOOD_AND_GORE: 39,
  /** @deprecated */
  ESRB_REALISTIC_VIOLENCE: 40,
  /** @deprecated */
  ESRB_ALCOHOL_AND_TOBACCO_REFERENCE: 41,
  /** @deprecated */
  ESRB_MATURE_SEXUAL_THEMES: 42,
  /** @deprecated */
  ESRB_MILD_ANIMATED_VIOLENCE: 43,
  /** @deprecated */
  ESRB_MILD_SEXUAL_THEMES: 44,
  /** @deprecated */
  ESRB_USE_OF_ALCOHOL_AND_TOBACCO: 45,
  /** @deprecated */
  ESRB_ANIMATED_BLOOD_AND_GORE: 46,
  /** @deprecated */
  ESRB_MILD_FANTASY_VIOLENCE: 47,
  /** @deprecated */
  ESRB_MILD_LYRICS: 48,
  /** @deprecated */
  ESRB_REALISTIC_BLOOD: 49,
  /** @deprecated */
  PEGI_VIOLENCE: 50,
  /** @deprecated */
  PEGI_SEX: 51,
  /** @deprecated */
  PEGI_DRUGS: 52,
  /** @deprecated */
  PEGI_FEAR: 53,
  /** @deprecated */
  PEGI_DISCRIMINATION: 54,
  /** @deprecated */
  PEGI_BAD_LANGUAGE: 55,
  /** @deprecated */
  PEGI_GAMBLING: 56,
  /** @deprecated */
  PEGI_ONLINE_GAMEPLAY: 57,
  /** @deprecated */
  PEGI_IN_GAME_PURCHASES: 58,
  /** @deprecated */
  CERO_LOVE: 59,
  /** @deprecated */
  CERO_SEXUAL_CONTENT: 60,
  /** @deprecated */
  CERO_VIOLENCE: 61,
  /** @deprecated */
  CERO_HORROR: 62,
  /** @deprecated */
  CERO_DRINKING_SMOKING: 63,
  /** @deprecated */
  CERO_GAMBLING: 64,
  /** @deprecated */
  CERO_CRIME: 65,
  /** @deprecated */
  CERO_CONTROLLED_SUBSTANCES: 66,
  /** @deprecated */
  CERO_LANGUAGES_AND_OTHERS: 67,
  /** @deprecated */
  GRAC_SEXUALITY: 68,
  /** @deprecated */
  GRAC_VIOLENCE: 69,
  /** @deprecated */
  GRAC_FEAR_HORROR_THREATENING: 70,
  /** @deprecated */
  GRAC_LANGUAGE: 71,
  /** @deprecated */
  GRAC_ALCOHOL_TOBACCO_DRUG: 72,
  /** @deprecated */
  GRAC_CRIME_ANTI_SOCIAL: 73,
  /** @deprecated */
  GRAC_GAMBLING: 74,
  /** @deprecated */
  CLASS_IND_VIOLENCIA: 75,
  /** @deprecated */
  CLASS_IND_VIOLENCIA_EXTREMA: 76,
  /** @deprecated */
  CLASS_IND_CONTEUDO_SEXUAL: 77,
  /** @deprecated */
  CLASS_IND_NUDEZ: 78,
  /** @deprecated */
  CLASS_IND_SEXO: 79,
  /** @deprecated */
  CLASS_IND_SEXO_EXPLICITO: 80,
  /** @deprecated */
  CLASS_IND_DROGAS: 81,
  /** @deprecated */
  CLASS_IND_DROGAS_LICITAS: 82,
  /** @deprecated */
  CLASS_IND_DROGAS_ILICITAS: 83,
  /** @deprecated */
  CLASS_IND_LINGUAGEM_IMPROPRIA: 84,
  /** @deprecated */
  CLASS_IND_ATOS_CRIMINOSOS: 85,
  UNRECOGNIZED: -1,
} as const;

export type AgeRatingContentDescriptionCategoryEnum =
  typeof AgeRatingContentDescriptionCategoryEnum[keyof typeof AgeRatingContentDescriptionCategoryEnum];

export namespace AgeRatingContentDescriptionCategoryEnum {
  export type AGERATINGCONTENTDESCRIPTION_CATEGORY_NULL =
    typeof AgeRatingContentDescriptionCategoryEnum.AGERATINGCONTENTDESCRIPTION_CATEGORY_NULL;
  export type ESRB_ALCOHOL_REFERENCE = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_ALCOHOL_REFERENCE;
  export type ESRB_ANIMATED_BLOOD = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_ANIMATED_BLOOD;
  export type ESRB_BLOOD = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_BLOOD;
  export type ESRB_BLOOD_AND_GORE = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_BLOOD_AND_GORE;
  export type ESRB_CARTOON_VIOLENCE = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_CARTOON_VIOLENCE;
  export type ESRB_COMIC_MISCHIEF = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_COMIC_MISCHIEF;
  export type ESRB_CRUDE_HUMOR = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_CRUDE_HUMOR;
  export type ESRB_DRUG_REFERENCE = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_DRUG_REFERENCE;
  export type ESRB_FANTASY_VIOLENCE = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_FANTASY_VIOLENCE;
  export type ESRB_INTENSE_VIOLENCE = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_INTENSE_VIOLENCE;
  export type ESRB_LANGUAGE = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_LANGUAGE;
  export type ESRB_LYRICS = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_LYRICS;
  export type ESRB_MATURE_HUMOR = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_MATURE_HUMOR;
  export type ESRB_NUDITY = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_NUDITY;
  export type ESRB_PARTIAL_NUDITY = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_PARTIAL_NUDITY;
  export type ESRB_REAL_GAMBLING = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_REAL_GAMBLING;
  export type ESRB_SEXUAL_CONTENT = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_SEXUAL_CONTENT;
  export type ESRB_SEXUAL_THEMES = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_SEXUAL_THEMES;
  export type ESRB_SEXUAL_VIOLENCE = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_SEXUAL_VIOLENCE;
  export type ESRB_SIMULATED_GAMBLING = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_SIMULATED_GAMBLING;
  export type ESRB_STRONG_LANGUAGE = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_STRONG_LANGUAGE;
  export type ESRB_STRONG_LYRICS = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_STRONG_LYRICS;
  export type ESRB_STRONG_SEXUAL_CONTENT = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_STRONG_SEXUAL_CONTENT;
  export type ESRB_SUGGESTIVE_THEMES = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_SUGGESTIVE_THEMES;
  export type ESRB_TOBACCO_REFERENCE = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_TOBACCO_REFERENCE;
  export type ESRB_USE_OF_ALCOHOL = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_USE_OF_ALCOHOL;
  export type ESRB_USE_OF_DRUGS = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_USE_OF_DRUGS;
  export type ESRB_USE_OF_TOBACCO = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_USE_OF_TOBACCO;
  export type ESRB_VIOLENCE = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_VIOLENCE;
  export type ESRB_VIOLENT_REFERENCES = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_VIOLENT_REFERENCES;
  export type ESRB_ANIMATED_VIOLENCE = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_ANIMATED_VIOLENCE;
  export type ESRB_MILD_LANGUAGE = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_LANGUAGE;
  export type ESRB_MILD_VIOLENCE = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_VIOLENCE;
  export type ESRB_USE_OF_DRUGS_AND_ALCOHOL =
    typeof AgeRatingContentDescriptionCategoryEnum.ESRB_USE_OF_DRUGS_AND_ALCOHOL;
  export type ESRB_DRUG_AND_ALCOHOL_REFERENCE =
    typeof AgeRatingContentDescriptionCategoryEnum.ESRB_DRUG_AND_ALCOHOL_REFERENCE;
  export type ESRB_MILD_SUGGESTIVE_THEMES = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_SUGGESTIVE_THEMES;
  export type ESRB_MILD_CARTOON_VIOLENCE = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_CARTOON_VIOLENCE;
  export type ESRB_MILD_BLOOD = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_BLOOD;
  export type ESRB_REALISTIC_BLOOD_AND_GORE =
    typeof AgeRatingContentDescriptionCategoryEnum.ESRB_REALISTIC_BLOOD_AND_GORE;
  export type ESRB_REALISTIC_VIOLENCE = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_REALISTIC_VIOLENCE;
  export type ESRB_ALCOHOL_AND_TOBACCO_REFERENCE =
    typeof AgeRatingContentDescriptionCategoryEnum.ESRB_ALCOHOL_AND_TOBACCO_REFERENCE;
  export type ESRB_MATURE_SEXUAL_THEMES = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_MATURE_SEXUAL_THEMES;
  export type ESRB_MILD_ANIMATED_VIOLENCE = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_ANIMATED_VIOLENCE;
  export type ESRB_MILD_SEXUAL_THEMES = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_SEXUAL_THEMES;
  export type ESRB_USE_OF_ALCOHOL_AND_TOBACCO =
    typeof AgeRatingContentDescriptionCategoryEnum.ESRB_USE_OF_ALCOHOL_AND_TOBACCO;
  export type ESRB_ANIMATED_BLOOD_AND_GORE =
    typeof AgeRatingContentDescriptionCategoryEnum.ESRB_ANIMATED_BLOOD_AND_GORE;
  export type ESRB_MILD_FANTASY_VIOLENCE = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_FANTASY_VIOLENCE;
  export type ESRB_MILD_LYRICS = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_LYRICS;
  export type ESRB_REALISTIC_BLOOD = typeof AgeRatingContentDescriptionCategoryEnum.ESRB_REALISTIC_BLOOD;
  export type PEGI_VIOLENCE = typeof AgeRatingContentDescriptionCategoryEnum.PEGI_VIOLENCE;
  export type PEGI_SEX = typeof AgeRatingContentDescriptionCategoryEnum.PEGI_SEX;
  export type PEGI_DRUGS = typeof AgeRatingContentDescriptionCategoryEnum.PEGI_DRUGS;
  export type PEGI_FEAR = typeof AgeRatingContentDescriptionCategoryEnum.PEGI_FEAR;
  export type PEGI_DISCRIMINATION = typeof AgeRatingContentDescriptionCategoryEnum.PEGI_DISCRIMINATION;
  export type PEGI_BAD_LANGUAGE = typeof AgeRatingContentDescriptionCategoryEnum.PEGI_BAD_LANGUAGE;
  export type PEGI_GAMBLING = typeof AgeRatingContentDescriptionCategoryEnum.PEGI_GAMBLING;
  export type PEGI_ONLINE_GAMEPLAY = typeof AgeRatingContentDescriptionCategoryEnum.PEGI_ONLINE_GAMEPLAY;
  export type PEGI_IN_GAME_PURCHASES = typeof AgeRatingContentDescriptionCategoryEnum.PEGI_IN_GAME_PURCHASES;
  export type CERO_LOVE = typeof AgeRatingContentDescriptionCategoryEnum.CERO_LOVE;
  export type CERO_SEXUAL_CONTENT = typeof AgeRatingContentDescriptionCategoryEnum.CERO_SEXUAL_CONTENT;
  export type CERO_VIOLENCE = typeof AgeRatingContentDescriptionCategoryEnum.CERO_VIOLENCE;
  export type CERO_HORROR = typeof AgeRatingContentDescriptionCategoryEnum.CERO_HORROR;
  export type CERO_DRINKING_SMOKING = typeof AgeRatingContentDescriptionCategoryEnum.CERO_DRINKING_SMOKING;
  export type CERO_GAMBLING = typeof AgeRatingContentDescriptionCategoryEnum.CERO_GAMBLING;
  export type CERO_CRIME = typeof AgeRatingContentDescriptionCategoryEnum.CERO_CRIME;
  export type CERO_CONTROLLED_SUBSTANCES = typeof AgeRatingContentDescriptionCategoryEnum.CERO_CONTROLLED_SUBSTANCES;
  export type CERO_LANGUAGES_AND_OTHERS = typeof AgeRatingContentDescriptionCategoryEnum.CERO_LANGUAGES_AND_OTHERS;
  export type GRAC_SEXUALITY = typeof AgeRatingContentDescriptionCategoryEnum.GRAC_SEXUALITY;
  export type GRAC_VIOLENCE = typeof AgeRatingContentDescriptionCategoryEnum.GRAC_VIOLENCE;
  export type GRAC_FEAR_HORROR_THREATENING =
    typeof AgeRatingContentDescriptionCategoryEnum.GRAC_FEAR_HORROR_THREATENING;
  export type GRAC_LANGUAGE = typeof AgeRatingContentDescriptionCategoryEnum.GRAC_LANGUAGE;
  export type GRAC_ALCOHOL_TOBACCO_DRUG = typeof AgeRatingContentDescriptionCategoryEnum.GRAC_ALCOHOL_TOBACCO_DRUG;
  export type GRAC_CRIME_ANTI_SOCIAL = typeof AgeRatingContentDescriptionCategoryEnum.GRAC_CRIME_ANTI_SOCIAL;
  export type GRAC_GAMBLING = typeof AgeRatingContentDescriptionCategoryEnum.GRAC_GAMBLING;
  export type CLASS_IND_VIOLENCIA = typeof AgeRatingContentDescriptionCategoryEnum.CLASS_IND_VIOLENCIA;
  export type CLASS_IND_VIOLENCIA_EXTREMA = typeof AgeRatingContentDescriptionCategoryEnum.CLASS_IND_VIOLENCIA_EXTREMA;
  export type CLASS_IND_CONTEUDO_SEXUAL = typeof AgeRatingContentDescriptionCategoryEnum.CLASS_IND_CONTEUDO_SEXUAL;
  export type CLASS_IND_NUDEZ = typeof AgeRatingContentDescriptionCategoryEnum.CLASS_IND_NUDEZ;
  export type CLASS_IND_SEXO = typeof AgeRatingContentDescriptionCategoryEnum.CLASS_IND_SEXO;
  export type CLASS_IND_SEXO_EXPLICITO = typeof AgeRatingContentDescriptionCategoryEnum.CLASS_IND_SEXO_EXPLICITO;
  export type CLASS_IND_DROGAS = typeof AgeRatingContentDescriptionCategoryEnum.CLASS_IND_DROGAS;
  export type CLASS_IND_DROGAS_LICITAS = typeof AgeRatingContentDescriptionCategoryEnum.CLASS_IND_DROGAS_LICITAS;
  export type CLASS_IND_DROGAS_ILICITAS = typeof AgeRatingContentDescriptionCategoryEnum.CLASS_IND_DROGAS_ILICITAS;
  export type CLASS_IND_LINGUAGEM_IMPROPRIA =
    typeof AgeRatingContentDescriptionCategoryEnum.CLASS_IND_LINGUAGEM_IMPROPRIA;
  export type CLASS_IND_ATOS_CRIMINOSOS = typeof AgeRatingContentDescriptionCategoryEnum.CLASS_IND_ATOS_CRIMINOSOS;
  export type UNRECOGNIZED = typeof AgeRatingContentDescriptionCategoryEnum.UNRECOGNIZED;
}

export function ageRatingContentDescriptionCategoryEnumFromJSON(object: any): AgeRatingContentDescriptionCategoryEnum {
  switch (object) {
    case 0:
    case "AGERATINGCONTENTDESCRIPTION_CATEGORY_NULL":
      return AgeRatingContentDescriptionCategoryEnum.AGERATINGCONTENTDESCRIPTION_CATEGORY_NULL;
    case 1:
    case "ESRB_ALCOHOL_REFERENCE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_ALCOHOL_REFERENCE;
    case 2:
    case "ESRB_ANIMATED_BLOOD":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_ANIMATED_BLOOD;
    case 3:
    case "ESRB_BLOOD":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_BLOOD;
    case 4:
    case "ESRB_BLOOD_AND_GORE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_BLOOD_AND_GORE;
    case 5:
    case "ESRB_CARTOON_VIOLENCE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_CARTOON_VIOLENCE;
    case 6:
    case "ESRB_COMIC_MISCHIEF":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_COMIC_MISCHIEF;
    case 7:
    case "ESRB_CRUDE_HUMOR":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_CRUDE_HUMOR;
    case 8:
    case "ESRB_DRUG_REFERENCE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_DRUG_REFERENCE;
    case 9:
    case "ESRB_FANTASY_VIOLENCE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_FANTASY_VIOLENCE;
    case 10:
    case "ESRB_INTENSE_VIOLENCE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_INTENSE_VIOLENCE;
    case 11:
    case "ESRB_LANGUAGE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_LANGUAGE;
    case 12:
    case "ESRB_LYRICS":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_LYRICS;
    case 13:
    case "ESRB_MATURE_HUMOR":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_MATURE_HUMOR;
    case 14:
    case "ESRB_NUDITY":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_NUDITY;
    case 15:
    case "ESRB_PARTIAL_NUDITY":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_PARTIAL_NUDITY;
    case 16:
    case "ESRB_REAL_GAMBLING":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_REAL_GAMBLING;
    case 17:
    case "ESRB_SEXUAL_CONTENT":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_SEXUAL_CONTENT;
    case 18:
    case "ESRB_SEXUAL_THEMES":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_SEXUAL_THEMES;
    case 19:
    case "ESRB_SEXUAL_VIOLENCE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_SEXUAL_VIOLENCE;
    case 20:
    case "ESRB_SIMULATED_GAMBLING":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_SIMULATED_GAMBLING;
    case 21:
    case "ESRB_STRONG_LANGUAGE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_STRONG_LANGUAGE;
    case 22:
    case "ESRB_STRONG_LYRICS":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_STRONG_LYRICS;
    case 23:
    case "ESRB_STRONG_SEXUAL_CONTENT":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_STRONG_SEXUAL_CONTENT;
    case 24:
    case "ESRB_SUGGESTIVE_THEMES":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_SUGGESTIVE_THEMES;
    case 25:
    case "ESRB_TOBACCO_REFERENCE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_TOBACCO_REFERENCE;
    case 26:
    case "ESRB_USE_OF_ALCOHOL":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_USE_OF_ALCOHOL;
    case 27:
    case "ESRB_USE_OF_DRUGS":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_USE_OF_DRUGS;
    case 28:
    case "ESRB_USE_OF_TOBACCO":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_USE_OF_TOBACCO;
    case 29:
    case "ESRB_VIOLENCE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_VIOLENCE;
    case 30:
    case "ESRB_VIOLENT_REFERENCES":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_VIOLENT_REFERENCES;
    case 31:
    case "ESRB_ANIMATED_VIOLENCE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_ANIMATED_VIOLENCE;
    case 32:
    case "ESRB_MILD_LANGUAGE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_LANGUAGE;
    case 33:
    case "ESRB_MILD_VIOLENCE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_VIOLENCE;
    case 34:
    case "ESRB_USE_OF_DRUGS_AND_ALCOHOL":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_USE_OF_DRUGS_AND_ALCOHOL;
    case 35:
    case "ESRB_DRUG_AND_ALCOHOL_REFERENCE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_DRUG_AND_ALCOHOL_REFERENCE;
    case 36:
    case "ESRB_MILD_SUGGESTIVE_THEMES":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_SUGGESTIVE_THEMES;
    case 37:
    case "ESRB_MILD_CARTOON_VIOLENCE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_CARTOON_VIOLENCE;
    case 38:
    case "ESRB_MILD_BLOOD":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_BLOOD;
    case 39:
    case "ESRB_REALISTIC_BLOOD_AND_GORE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_REALISTIC_BLOOD_AND_GORE;
    case 40:
    case "ESRB_REALISTIC_VIOLENCE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_REALISTIC_VIOLENCE;
    case 41:
    case "ESRB_ALCOHOL_AND_TOBACCO_REFERENCE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_ALCOHOL_AND_TOBACCO_REFERENCE;
    case 42:
    case "ESRB_MATURE_SEXUAL_THEMES":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_MATURE_SEXUAL_THEMES;
    case 43:
    case "ESRB_MILD_ANIMATED_VIOLENCE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_ANIMATED_VIOLENCE;
    case 44:
    case "ESRB_MILD_SEXUAL_THEMES":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_SEXUAL_THEMES;
    case 45:
    case "ESRB_USE_OF_ALCOHOL_AND_TOBACCO":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_USE_OF_ALCOHOL_AND_TOBACCO;
    case 46:
    case "ESRB_ANIMATED_BLOOD_AND_GORE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_ANIMATED_BLOOD_AND_GORE;
    case 47:
    case "ESRB_MILD_FANTASY_VIOLENCE":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_FANTASY_VIOLENCE;
    case 48:
    case "ESRB_MILD_LYRICS":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_LYRICS;
    case 49:
    case "ESRB_REALISTIC_BLOOD":
      return AgeRatingContentDescriptionCategoryEnum.ESRB_REALISTIC_BLOOD;
    case 50:
    case "PEGI_VIOLENCE":
      return AgeRatingContentDescriptionCategoryEnum.PEGI_VIOLENCE;
    case 51:
    case "PEGI_SEX":
      return AgeRatingContentDescriptionCategoryEnum.PEGI_SEX;
    case 52:
    case "PEGI_DRUGS":
      return AgeRatingContentDescriptionCategoryEnum.PEGI_DRUGS;
    case 53:
    case "PEGI_FEAR":
      return AgeRatingContentDescriptionCategoryEnum.PEGI_FEAR;
    case 54:
    case "PEGI_DISCRIMINATION":
      return AgeRatingContentDescriptionCategoryEnum.PEGI_DISCRIMINATION;
    case 55:
    case "PEGI_BAD_LANGUAGE":
      return AgeRatingContentDescriptionCategoryEnum.PEGI_BAD_LANGUAGE;
    case 56:
    case "PEGI_GAMBLING":
      return AgeRatingContentDescriptionCategoryEnum.PEGI_GAMBLING;
    case 57:
    case "PEGI_ONLINE_GAMEPLAY":
      return AgeRatingContentDescriptionCategoryEnum.PEGI_ONLINE_GAMEPLAY;
    case 58:
    case "PEGI_IN_GAME_PURCHASES":
      return AgeRatingContentDescriptionCategoryEnum.PEGI_IN_GAME_PURCHASES;
    case 59:
    case "CERO_LOVE":
      return AgeRatingContentDescriptionCategoryEnum.CERO_LOVE;
    case 60:
    case "CERO_SEXUAL_CONTENT":
      return AgeRatingContentDescriptionCategoryEnum.CERO_SEXUAL_CONTENT;
    case 61:
    case "CERO_VIOLENCE":
      return AgeRatingContentDescriptionCategoryEnum.CERO_VIOLENCE;
    case 62:
    case "CERO_HORROR":
      return AgeRatingContentDescriptionCategoryEnum.CERO_HORROR;
    case 63:
    case "CERO_DRINKING_SMOKING":
      return AgeRatingContentDescriptionCategoryEnum.CERO_DRINKING_SMOKING;
    case 64:
    case "CERO_GAMBLING":
      return AgeRatingContentDescriptionCategoryEnum.CERO_GAMBLING;
    case 65:
    case "CERO_CRIME":
      return AgeRatingContentDescriptionCategoryEnum.CERO_CRIME;
    case 66:
    case "CERO_CONTROLLED_SUBSTANCES":
      return AgeRatingContentDescriptionCategoryEnum.CERO_CONTROLLED_SUBSTANCES;
    case 67:
    case "CERO_LANGUAGES_AND_OTHERS":
      return AgeRatingContentDescriptionCategoryEnum.CERO_LANGUAGES_AND_OTHERS;
    case 68:
    case "GRAC_SEXUALITY":
      return AgeRatingContentDescriptionCategoryEnum.GRAC_SEXUALITY;
    case 69:
    case "GRAC_VIOLENCE":
      return AgeRatingContentDescriptionCategoryEnum.GRAC_VIOLENCE;
    case 70:
    case "GRAC_FEAR_HORROR_THREATENING":
      return AgeRatingContentDescriptionCategoryEnum.GRAC_FEAR_HORROR_THREATENING;
    case 71:
    case "GRAC_LANGUAGE":
      return AgeRatingContentDescriptionCategoryEnum.GRAC_LANGUAGE;
    case 72:
    case "GRAC_ALCOHOL_TOBACCO_DRUG":
      return AgeRatingContentDescriptionCategoryEnum.GRAC_ALCOHOL_TOBACCO_DRUG;
    case 73:
    case "GRAC_CRIME_ANTI_SOCIAL":
      return AgeRatingContentDescriptionCategoryEnum.GRAC_CRIME_ANTI_SOCIAL;
    case 74:
    case "GRAC_GAMBLING":
      return AgeRatingContentDescriptionCategoryEnum.GRAC_GAMBLING;
    case 75:
    case "CLASS_IND_VIOLENCIA":
      return AgeRatingContentDescriptionCategoryEnum.CLASS_IND_VIOLENCIA;
    case 76:
    case "CLASS_IND_VIOLENCIA_EXTREMA":
      return AgeRatingContentDescriptionCategoryEnum.CLASS_IND_VIOLENCIA_EXTREMA;
    case 77:
    case "CLASS_IND_CONTEUDO_SEXUAL":
      return AgeRatingContentDescriptionCategoryEnum.CLASS_IND_CONTEUDO_SEXUAL;
    case 78:
    case "CLASS_IND_NUDEZ":
      return AgeRatingContentDescriptionCategoryEnum.CLASS_IND_NUDEZ;
    case 79:
    case "CLASS_IND_SEXO":
      return AgeRatingContentDescriptionCategoryEnum.CLASS_IND_SEXO;
    case 80:
    case "CLASS_IND_SEXO_EXPLICITO":
      return AgeRatingContentDescriptionCategoryEnum.CLASS_IND_SEXO_EXPLICITO;
    case 81:
    case "CLASS_IND_DROGAS":
      return AgeRatingContentDescriptionCategoryEnum.CLASS_IND_DROGAS;
    case 82:
    case "CLASS_IND_DROGAS_LICITAS":
      return AgeRatingContentDescriptionCategoryEnum.CLASS_IND_DROGAS_LICITAS;
    case 83:
    case "CLASS_IND_DROGAS_ILICITAS":
      return AgeRatingContentDescriptionCategoryEnum.CLASS_IND_DROGAS_ILICITAS;
    case 84:
    case "CLASS_IND_LINGUAGEM_IMPROPRIA":
      return AgeRatingContentDescriptionCategoryEnum.CLASS_IND_LINGUAGEM_IMPROPRIA;
    case 85:
    case "CLASS_IND_ATOS_CRIMINOSOS":
      return AgeRatingContentDescriptionCategoryEnum.CLASS_IND_ATOS_CRIMINOSOS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AgeRatingContentDescriptionCategoryEnum.UNRECOGNIZED;
  }
}

export function ageRatingContentDescriptionCategoryEnumToJSON(object: AgeRatingContentDescriptionCategoryEnum): string {
  switch (object) {
    case AgeRatingContentDescriptionCategoryEnum.AGERATINGCONTENTDESCRIPTION_CATEGORY_NULL:
      return "AGERATINGCONTENTDESCRIPTION_CATEGORY_NULL";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_ALCOHOL_REFERENCE:
      return "ESRB_ALCOHOL_REFERENCE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_ANIMATED_BLOOD:
      return "ESRB_ANIMATED_BLOOD";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_BLOOD:
      return "ESRB_BLOOD";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_BLOOD_AND_GORE:
      return "ESRB_BLOOD_AND_GORE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_CARTOON_VIOLENCE:
      return "ESRB_CARTOON_VIOLENCE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_COMIC_MISCHIEF:
      return "ESRB_COMIC_MISCHIEF";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_CRUDE_HUMOR:
      return "ESRB_CRUDE_HUMOR";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_DRUG_REFERENCE:
      return "ESRB_DRUG_REFERENCE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_FANTASY_VIOLENCE:
      return "ESRB_FANTASY_VIOLENCE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_INTENSE_VIOLENCE:
      return "ESRB_INTENSE_VIOLENCE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_LANGUAGE:
      return "ESRB_LANGUAGE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_LYRICS:
      return "ESRB_LYRICS";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_MATURE_HUMOR:
      return "ESRB_MATURE_HUMOR";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_NUDITY:
      return "ESRB_NUDITY";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_PARTIAL_NUDITY:
      return "ESRB_PARTIAL_NUDITY";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_REAL_GAMBLING:
      return "ESRB_REAL_GAMBLING";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_SEXUAL_CONTENT:
      return "ESRB_SEXUAL_CONTENT";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_SEXUAL_THEMES:
      return "ESRB_SEXUAL_THEMES";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_SEXUAL_VIOLENCE:
      return "ESRB_SEXUAL_VIOLENCE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_SIMULATED_GAMBLING:
      return "ESRB_SIMULATED_GAMBLING";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_STRONG_LANGUAGE:
      return "ESRB_STRONG_LANGUAGE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_STRONG_LYRICS:
      return "ESRB_STRONG_LYRICS";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_STRONG_SEXUAL_CONTENT:
      return "ESRB_STRONG_SEXUAL_CONTENT";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_SUGGESTIVE_THEMES:
      return "ESRB_SUGGESTIVE_THEMES";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_TOBACCO_REFERENCE:
      return "ESRB_TOBACCO_REFERENCE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_USE_OF_ALCOHOL:
      return "ESRB_USE_OF_ALCOHOL";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_USE_OF_DRUGS:
      return "ESRB_USE_OF_DRUGS";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_USE_OF_TOBACCO:
      return "ESRB_USE_OF_TOBACCO";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_VIOLENCE:
      return "ESRB_VIOLENCE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_VIOLENT_REFERENCES:
      return "ESRB_VIOLENT_REFERENCES";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_ANIMATED_VIOLENCE:
      return "ESRB_ANIMATED_VIOLENCE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_LANGUAGE:
      return "ESRB_MILD_LANGUAGE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_VIOLENCE:
      return "ESRB_MILD_VIOLENCE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_USE_OF_DRUGS_AND_ALCOHOL:
      return "ESRB_USE_OF_DRUGS_AND_ALCOHOL";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_DRUG_AND_ALCOHOL_REFERENCE:
      return "ESRB_DRUG_AND_ALCOHOL_REFERENCE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_SUGGESTIVE_THEMES:
      return "ESRB_MILD_SUGGESTIVE_THEMES";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_CARTOON_VIOLENCE:
      return "ESRB_MILD_CARTOON_VIOLENCE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_BLOOD:
      return "ESRB_MILD_BLOOD";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_REALISTIC_BLOOD_AND_GORE:
      return "ESRB_REALISTIC_BLOOD_AND_GORE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_REALISTIC_VIOLENCE:
      return "ESRB_REALISTIC_VIOLENCE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_ALCOHOL_AND_TOBACCO_REFERENCE:
      return "ESRB_ALCOHOL_AND_TOBACCO_REFERENCE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_MATURE_SEXUAL_THEMES:
      return "ESRB_MATURE_SEXUAL_THEMES";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_ANIMATED_VIOLENCE:
      return "ESRB_MILD_ANIMATED_VIOLENCE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_SEXUAL_THEMES:
      return "ESRB_MILD_SEXUAL_THEMES";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_USE_OF_ALCOHOL_AND_TOBACCO:
      return "ESRB_USE_OF_ALCOHOL_AND_TOBACCO";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_ANIMATED_BLOOD_AND_GORE:
      return "ESRB_ANIMATED_BLOOD_AND_GORE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_FANTASY_VIOLENCE:
      return "ESRB_MILD_FANTASY_VIOLENCE";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_MILD_LYRICS:
      return "ESRB_MILD_LYRICS";
    case AgeRatingContentDescriptionCategoryEnum.ESRB_REALISTIC_BLOOD:
      return "ESRB_REALISTIC_BLOOD";
    case AgeRatingContentDescriptionCategoryEnum.PEGI_VIOLENCE:
      return "PEGI_VIOLENCE";
    case AgeRatingContentDescriptionCategoryEnum.PEGI_SEX:
      return "PEGI_SEX";
    case AgeRatingContentDescriptionCategoryEnum.PEGI_DRUGS:
      return "PEGI_DRUGS";
    case AgeRatingContentDescriptionCategoryEnum.PEGI_FEAR:
      return "PEGI_FEAR";
    case AgeRatingContentDescriptionCategoryEnum.PEGI_DISCRIMINATION:
      return "PEGI_DISCRIMINATION";
    case AgeRatingContentDescriptionCategoryEnum.PEGI_BAD_LANGUAGE:
      return "PEGI_BAD_LANGUAGE";
    case AgeRatingContentDescriptionCategoryEnum.PEGI_GAMBLING:
      return "PEGI_GAMBLING";
    case AgeRatingContentDescriptionCategoryEnum.PEGI_ONLINE_GAMEPLAY:
      return "PEGI_ONLINE_GAMEPLAY";
    case AgeRatingContentDescriptionCategoryEnum.PEGI_IN_GAME_PURCHASES:
      return "PEGI_IN_GAME_PURCHASES";
    case AgeRatingContentDescriptionCategoryEnum.CERO_LOVE:
      return "CERO_LOVE";
    case AgeRatingContentDescriptionCategoryEnum.CERO_SEXUAL_CONTENT:
      return "CERO_SEXUAL_CONTENT";
    case AgeRatingContentDescriptionCategoryEnum.CERO_VIOLENCE:
      return "CERO_VIOLENCE";
    case AgeRatingContentDescriptionCategoryEnum.CERO_HORROR:
      return "CERO_HORROR";
    case AgeRatingContentDescriptionCategoryEnum.CERO_DRINKING_SMOKING:
      return "CERO_DRINKING_SMOKING";
    case AgeRatingContentDescriptionCategoryEnum.CERO_GAMBLING:
      return "CERO_GAMBLING";
    case AgeRatingContentDescriptionCategoryEnum.CERO_CRIME:
      return "CERO_CRIME";
    case AgeRatingContentDescriptionCategoryEnum.CERO_CONTROLLED_SUBSTANCES:
      return "CERO_CONTROLLED_SUBSTANCES";
    case AgeRatingContentDescriptionCategoryEnum.CERO_LANGUAGES_AND_OTHERS:
      return "CERO_LANGUAGES_AND_OTHERS";
    case AgeRatingContentDescriptionCategoryEnum.GRAC_SEXUALITY:
      return "GRAC_SEXUALITY";
    case AgeRatingContentDescriptionCategoryEnum.GRAC_VIOLENCE:
      return "GRAC_VIOLENCE";
    case AgeRatingContentDescriptionCategoryEnum.GRAC_FEAR_HORROR_THREATENING:
      return "GRAC_FEAR_HORROR_THREATENING";
    case AgeRatingContentDescriptionCategoryEnum.GRAC_LANGUAGE:
      return "GRAC_LANGUAGE";
    case AgeRatingContentDescriptionCategoryEnum.GRAC_ALCOHOL_TOBACCO_DRUG:
      return "GRAC_ALCOHOL_TOBACCO_DRUG";
    case AgeRatingContentDescriptionCategoryEnum.GRAC_CRIME_ANTI_SOCIAL:
      return "GRAC_CRIME_ANTI_SOCIAL";
    case AgeRatingContentDescriptionCategoryEnum.GRAC_GAMBLING:
      return "GRAC_GAMBLING";
    case AgeRatingContentDescriptionCategoryEnum.CLASS_IND_VIOLENCIA:
      return "CLASS_IND_VIOLENCIA";
    case AgeRatingContentDescriptionCategoryEnum.CLASS_IND_VIOLENCIA_EXTREMA:
      return "CLASS_IND_VIOLENCIA_EXTREMA";
    case AgeRatingContentDescriptionCategoryEnum.CLASS_IND_CONTEUDO_SEXUAL:
      return "CLASS_IND_CONTEUDO_SEXUAL";
    case AgeRatingContentDescriptionCategoryEnum.CLASS_IND_NUDEZ:
      return "CLASS_IND_NUDEZ";
    case AgeRatingContentDescriptionCategoryEnum.CLASS_IND_SEXO:
      return "CLASS_IND_SEXO";
    case AgeRatingContentDescriptionCategoryEnum.CLASS_IND_SEXO_EXPLICITO:
      return "CLASS_IND_SEXO_EXPLICITO";
    case AgeRatingContentDescriptionCategoryEnum.CLASS_IND_DROGAS:
      return "CLASS_IND_DROGAS";
    case AgeRatingContentDescriptionCategoryEnum.CLASS_IND_DROGAS_LICITAS:
      return "CLASS_IND_DROGAS_LICITAS";
    case AgeRatingContentDescriptionCategoryEnum.CLASS_IND_DROGAS_ILICITAS:
      return "CLASS_IND_DROGAS_ILICITAS";
    case AgeRatingContentDescriptionCategoryEnum.CLASS_IND_LINGUAGEM_IMPROPRIA:
      return "CLASS_IND_LINGUAGEM_IMPROPRIA";
    case AgeRatingContentDescriptionCategoryEnum.CLASS_IND_ATOS_CRIMINOSOS:
      return "CLASS_IND_ATOS_CRIMINOSOS";
    case AgeRatingContentDescriptionCategoryEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const GenderGenderEnum = {
  /** @deprecated */
  MALE: 0,
  /** @deprecated */
  FEMALE: 1,
  /** @deprecated */
  OTHER: 2,
  UNRECOGNIZED: -1,
} as const;

export type GenderGenderEnum = typeof GenderGenderEnum[keyof typeof GenderGenderEnum];

export namespace GenderGenderEnum {
  export type MALE = typeof GenderGenderEnum.MALE;
  export type FEMALE = typeof GenderGenderEnum.FEMALE;
  export type OTHER = typeof GenderGenderEnum.OTHER;
  export type UNRECOGNIZED = typeof GenderGenderEnum.UNRECOGNIZED;
}

export function genderGenderEnumFromJSON(object: any): GenderGenderEnum {
  switch (object) {
    case 0:
    case "MALE":
      return GenderGenderEnum.MALE;
    case 1:
    case "FEMALE":
      return GenderGenderEnum.FEMALE;
    case 2:
    case "OTHER":
      return GenderGenderEnum.OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GenderGenderEnum.UNRECOGNIZED;
  }
}

export function genderGenderEnumToJSON(object: GenderGenderEnum): string {
  switch (object) {
    case GenderGenderEnum.MALE:
      return "MALE";
    case GenderGenderEnum.FEMALE:
      return "FEMALE";
    case GenderGenderEnum.OTHER:
      return "OTHER";
    case GenderGenderEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const CharacterSpeciesEnum = {
  /** @deprecated */
  CHARACTER_SPECIES_NULL: 0,
  /** @deprecated */
  HUMAN: 1,
  /** @deprecated */
  ALIEN: 2,
  /** @deprecated */
  ANIMAL: 3,
  /** @deprecated */
  ANDROID: 4,
  /** @deprecated */
  UNKNOWN: 5,
  UNRECOGNIZED: -1,
} as const;

export type CharacterSpeciesEnum = typeof CharacterSpeciesEnum[keyof typeof CharacterSpeciesEnum];

export namespace CharacterSpeciesEnum {
  export type CHARACTER_SPECIES_NULL = typeof CharacterSpeciesEnum.CHARACTER_SPECIES_NULL;
  export type HUMAN = typeof CharacterSpeciesEnum.HUMAN;
  export type ALIEN = typeof CharacterSpeciesEnum.ALIEN;
  export type ANIMAL = typeof CharacterSpeciesEnum.ANIMAL;
  export type ANDROID = typeof CharacterSpeciesEnum.ANDROID;
  export type UNKNOWN = typeof CharacterSpeciesEnum.UNKNOWN;
  export type UNRECOGNIZED = typeof CharacterSpeciesEnum.UNRECOGNIZED;
}

export function characterSpeciesEnumFromJSON(object: any): CharacterSpeciesEnum {
  switch (object) {
    case 0:
    case "CHARACTER_SPECIES_NULL":
      return CharacterSpeciesEnum.CHARACTER_SPECIES_NULL;
    case 1:
    case "HUMAN":
      return CharacterSpeciesEnum.HUMAN;
    case 2:
    case "ALIEN":
      return CharacterSpeciesEnum.ALIEN;
    case 3:
    case "ANIMAL":
      return CharacterSpeciesEnum.ANIMAL;
    case 4:
    case "ANDROID":
      return CharacterSpeciesEnum.ANDROID;
    case 5:
    case "UNKNOWN":
      return CharacterSpeciesEnum.UNKNOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CharacterSpeciesEnum.UNRECOGNIZED;
  }
}

export function characterSpeciesEnumToJSON(object: CharacterSpeciesEnum): string {
  switch (object) {
    case CharacterSpeciesEnum.CHARACTER_SPECIES_NULL:
      return "CHARACTER_SPECIES_NULL";
    case CharacterSpeciesEnum.HUMAN:
      return "HUMAN";
    case CharacterSpeciesEnum.ALIEN:
      return "ALIEN";
    case CharacterSpeciesEnum.ANIMAL:
      return "ANIMAL";
    case CharacterSpeciesEnum.ANDROID:
      return "ANDROID";
    case CharacterSpeciesEnum.UNKNOWN:
      return "UNKNOWN";
    case CharacterSpeciesEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const DateFormatChangeDateCategoryEnum = {
  /** @deprecated */
  YYYYMMMMDD: 0,
  /** @deprecated */
  YYYYMMMM: 1,
  /** @deprecated */
  YYYY: 2,
  /** @deprecated */
  YYYYQ1: 3,
  /** @deprecated */
  YYYYQ2: 4,
  /** @deprecated */
  YYYYQ3: 5,
  /** @deprecated */
  YYYYQ4: 6,
  /** @deprecated */
  TBD: 7,
  UNRECOGNIZED: -1,
} as const;

export type DateFormatChangeDateCategoryEnum =
  typeof DateFormatChangeDateCategoryEnum[keyof typeof DateFormatChangeDateCategoryEnum];

export namespace DateFormatChangeDateCategoryEnum {
  export type YYYYMMMMDD = typeof DateFormatChangeDateCategoryEnum.YYYYMMMMDD;
  export type YYYYMMMM = typeof DateFormatChangeDateCategoryEnum.YYYYMMMM;
  export type YYYY = typeof DateFormatChangeDateCategoryEnum.YYYY;
  export type YYYYQ1 = typeof DateFormatChangeDateCategoryEnum.YYYYQ1;
  export type YYYYQ2 = typeof DateFormatChangeDateCategoryEnum.YYYYQ2;
  export type YYYYQ3 = typeof DateFormatChangeDateCategoryEnum.YYYYQ3;
  export type YYYYQ4 = typeof DateFormatChangeDateCategoryEnum.YYYYQ4;
  export type TBD = typeof DateFormatChangeDateCategoryEnum.TBD;
  export type UNRECOGNIZED = typeof DateFormatChangeDateCategoryEnum.UNRECOGNIZED;
}

export function dateFormatChangeDateCategoryEnumFromJSON(object: any): DateFormatChangeDateCategoryEnum {
  switch (object) {
    case 0:
    case "YYYYMMMMDD":
      return DateFormatChangeDateCategoryEnum.YYYYMMMMDD;
    case 1:
    case "YYYYMMMM":
      return DateFormatChangeDateCategoryEnum.YYYYMMMM;
    case 2:
    case "YYYY":
      return DateFormatChangeDateCategoryEnum.YYYY;
    case 3:
    case "YYYYQ1":
      return DateFormatChangeDateCategoryEnum.YYYYQ1;
    case 4:
    case "YYYYQ2":
      return DateFormatChangeDateCategoryEnum.YYYYQ2;
    case 5:
    case "YYYYQ3":
      return DateFormatChangeDateCategoryEnum.YYYYQ3;
    case 6:
    case "YYYYQ4":
      return DateFormatChangeDateCategoryEnum.YYYYQ4;
    case 7:
    case "TBD":
      return DateFormatChangeDateCategoryEnum.TBD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DateFormatChangeDateCategoryEnum.UNRECOGNIZED;
  }
}

export function dateFormatChangeDateCategoryEnumToJSON(object: DateFormatChangeDateCategoryEnum): string {
  switch (object) {
    case DateFormatChangeDateCategoryEnum.YYYYMMMMDD:
      return "YYYYMMMMDD";
    case DateFormatChangeDateCategoryEnum.YYYYMMMM:
      return "YYYYMMMM";
    case DateFormatChangeDateCategoryEnum.YYYY:
      return "YYYY";
    case DateFormatChangeDateCategoryEnum.YYYYQ1:
      return "YYYYQ1";
    case DateFormatChangeDateCategoryEnum.YYYYQ2:
      return "YYYYQ2";
    case DateFormatChangeDateCategoryEnum.YYYYQ3:
      return "YYYYQ3";
    case DateFormatChangeDateCategoryEnum.YYYYQ4:
      return "YYYYQ4";
    case DateFormatChangeDateCategoryEnum.TBD:
      return "TBD";
    case DateFormatChangeDateCategoryEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const WebsiteCategoryEnum = {
  /** @deprecated */
  WEBSITE_CATEGORY_NULL: 0,
  /** @deprecated */
  WEBSITE_OFFICIAL: 1,
  /** @deprecated */
  WEBSITE_WIKIA: 2,
  /** @deprecated */
  WEBSITE_WIKIPEDIA: 3,
  /** @deprecated */
  WEBSITE_FACEBOOK: 4,
  /** @deprecated */
  WEBSITE_TWITTER: 5,
  /** @deprecated */
  WEBSITE_TWITCH: 6,
  /** @deprecated */
  WEBSITE_INSTAGRAM: 8,
  /** @deprecated */
  WEBSITE_YOUTUBE: 9,
  /** @deprecated */
  WEBSITE_IPHONE: 10,
  /** @deprecated */
  WEBSITE_IPAD: 11,
  /** @deprecated */
  WEBSITE_ANDROID: 12,
  /** @deprecated */
  WEBSITE_STEAM: 13,
  /** @deprecated */
  WEBSITE_REDDIT: 14,
  /** @deprecated */
  WEBSITE_ITCH: 15,
  /** @deprecated */
  WEBSITE_EPICGAMES: 16,
  /** @deprecated */
  WEBSITE_GOG: 17,
  /** @deprecated */
  WEBSITE_DISCORD: 18,
  /** @deprecated */
  WEBSITE_BLUESKY: 19,
  UNRECOGNIZED: -1,
} as const;

export type WebsiteCategoryEnum = typeof WebsiteCategoryEnum[keyof typeof WebsiteCategoryEnum];

export namespace WebsiteCategoryEnum {
  export type WEBSITE_CATEGORY_NULL = typeof WebsiteCategoryEnum.WEBSITE_CATEGORY_NULL;
  export type WEBSITE_OFFICIAL = typeof WebsiteCategoryEnum.WEBSITE_OFFICIAL;
  export type WEBSITE_WIKIA = typeof WebsiteCategoryEnum.WEBSITE_WIKIA;
  export type WEBSITE_WIKIPEDIA = typeof WebsiteCategoryEnum.WEBSITE_WIKIPEDIA;
  export type WEBSITE_FACEBOOK = typeof WebsiteCategoryEnum.WEBSITE_FACEBOOK;
  export type WEBSITE_TWITTER = typeof WebsiteCategoryEnum.WEBSITE_TWITTER;
  export type WEBSITE_TWITCH = typeof WebsiteCategoryEnum.WEBSITE_TWITCH;
  export type WEBSITE_INSTAGRAM = typeof WebsiteCategoryEnum.WEBSITE_INSTAGRAM;
  export type WEBSITE_YOUTUBE = typeof WebsiteCategoryEnum.WEBSITE_YOUTUBE;
  export type WEBSITE_IPHONE = typeof WebsiteCategoryEnum.WEBSITE_IPHONE;
  export type WEBSITE_IPAD = typeof WebsiteCategoryEnum.WEBSITE_IPAD;
  export type WEBSITE_ANDROID = typeof WebsiteCategoryEnum.WEBSITE_ANDROID;
  export type WEBSITE_STEAM = typeof WebsiteCategoryEnum.WEBSITE_STEAM;
  export type WEBSITE_REDDIT = typeof WebsiteCategoryEnum.WEBSITE_REDDIT;
  export type WEBSITE_ITCH = typeof WebsiteCategoryEnum.WEBSITE_ITCH;
  export type WEBSITE_EPICGAMES = typeof WebsiteCategoryEnum.WEBSITE_EPICGAMES;
  export type WEBSITE_GOG = typeof WebsiteCategoryEnum.WEBSITE_GOG;
  export type WEBSITE_DISCORD = typeof WebsiteCategoryEnum.WEBSITE_DISCORD;
  export type WEBSITE_BLUESKY = typeof WebsiteCategoryEnum.WEBSITE_BLUESKY;
  export type UNRECOGNIZED = typeof WebsiteCategoryEnum.UNRECOGNIZED;
}

export function websiteCategoryEnumFromJSON(object: any): WebsiteCategoryEnum {
  switch (object) {
    case 0:
    case "WEBSITE_CATEGORY_NULL":
      return WebsiteCategoryEnum.WEBSITE_CATEGORY_NULL;
    case 1:
    case "WEBSITE_OFFICIAL":
      return WebsiteCategoryEnum.WEBSITE_OFFICIAL;
    case 2:
    case "WEBSITE_WIKIA":
      return WebsiteCategoryEnum.WEBSITE_WIKIA;
    case 3:
    case "WEBSITE_WIKIPEDIA":
      return WebsiteCategoryEnum.WEBSITE_WIKIPEDIA;
    case 4:
    case "WEBSITE_FACEBOOK":
      return WebsiteCategoryEnum.WEBSITE_FACEBOOK;
    case 5:
    case "WEBSITE_TWITTER":
      return WebsiteCategoryEnum.WEBSITE_TWITTER;
    case 6:
    case "WEBSITE_TWITCH":
      return WebsiteCategoryEnum.WEBSITE_TWITCH;
    case 8:
    case "WEBSITE_INSTAGRAM":
      return WebsiteCategoryEnum.WEBSITE_INSTAGRAM;
    case 9:
    case "WEBSITE_YOUTUBE":
      return WebsiteCategoryEnum.WEBSITE_YOUTUBE;
    case 10:
    case "WEBSITE_IPHONE":
      return WebsiteCategoryEnum.WEBSITE_IPHONE;
    case 11:
    case "WEBSITE_IPAD":
      return WebsiteCategoryEnum.WEBSITE_IPAD;
    case 12:
    case "WEBSITE_ANDROID":
      return WebsiteCategoryEnum.WEBSITE_ANDROID;
    case 13:
    case "WEBSITE_STEAM":
      return WebsiteCategoryEnum.WEBSITE_STEAM;
    case 14:
    case "WEBSITE_REDDIT":
      return WebsiteCategoryEnum.WEBSITE_REDDIT;
    case 15:
    case "WEBSITE_ITCH":
      return WebsiteCategoryEnum.WEBSITE_ITCH;
    case 16:
    case "WEBSITE_EPICGAMES":
      return WebsiteCategoryEnum.WEBSITE_EPICGAMES;
    case 17:
    case "WEBSITE_GOG":
      return WebsiteCategoryEnum.WEBSITE_GOG;
    case 18:
    case "WEBSITE_DISCORD":
      return WebsiteCategoryEnum.WEBSITE_DISCORD;
    case 19:
    case "WEBSITE_BLUESKY":
      return WebsiteCategoryEnum.WEBSITE_BLUESKY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WebsiteCategoryEnum.UNRECOGNIZED;
  }
}

export function websiteCategoryEnumToJSON(object: WebsiteCategoryEnum): string {
  switch (object) {
    case WebsiteCategoryEnum.WEBSITE_CATEGORY_NULL:
      return "WEBSITE_CATEGORY_NULL";
    case WebsiteCategoryEnum.WEBSITE_OFFICIAL:
      return "WEBSITE_OFFICIAL";
    case WebsiteCategoryEnum.WEBSITE_WIKIA:
      return "WEBSITE_WIKIA";
    case WebsiteCategoryEnum.WEBSITE_WIKIPEDIA:
      return "WEBSITE_WIKIPEDIA";
    case WebsiteCategoryEnum.WEBSITE_FACEBOOK:
      return "WEBSITE_FACEBOOK";
    case WebsiteCategoryEnum.WEBSITE_TWITTER:
      return "WEBSITE_TWITTER";
    case WebsiteCategoryEnum.WEBSITE_TWITCH:
      return "WEBSITE_TWITCH";
    case WebsiteCategoryEnum.WEBSITE_INSTAGRAM:
      return "WEBSITE_INSTAGRAM";
    case WebsiteCategoryEnum.WEBSITE_YOUTUBE:
      return "WEBSITE_YOUTUBE";
    case WebsiteCategoryEnum.WEBSITE_IPHONE:
      return "WEBSITE_IPHONE";
    case WebsiteCategoryEnum.WEBSITE_IPAD:
      return "WEBSITE_IPAD";
    case WebsiteCategoryEnum.WEBSITE_ANDROID:
      return "WEBSITE_ANDROID";
    case WebsiteCategoryEnum.WEBSITE_STEAM:
      return "WEBSITE_STEAM";
    case WebsiteCategoryEnum.WEBSITE_REDDIT:
      return "WEBSITE_REDDIT";
    case WebsiteCategoryEnum.WEBSITE_ITCH:
      return "WEBSITE_ITCH";
    case WebsiteCategoryEnum.WEBSITE_EPICGAMES:
      return "WEBSITE_EPICGAMES";
    case WebsiteCategoryEnum.WEBSITE_GOG:
      return "WEBSITE_GOG";
    case WebsiteCategoryEnum.WEBSITE_DISCORD:
      return "WEBSITE_DISCORD";
    case WebsiteCategoryEnum.WEBSITE_BLUESKY:
      return "WEBSITE_BLUESKY";
    case WebsiteCategoryEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const ExternalGameCategoryEnum = {
  /** @deprecated */
  EXTERNALGAME_CATEGORY_NULL: 0,
  /** @deprecated */
  EXTERNALGAME_STEAM: 1,
  /** @deprecated */
  EXTERNALGAME_GOG: 5,
  /** @deprecated */
  EXTERNALGAME_YOUTUBE: 10,
  /** @deprecated */
  EXTERNALGAME_MICROSOFT: 11,
  /** @deprecated */
  EXTERNALGAME_APPLE: 13,
  /** @deprecated */
  EXTERNALGAME_TWITCH: 14,
  /** @deprecated */
  EXTERNALGAME_ANDROID: 15,
  /** @deprecated */
  EXTERNALGAME_AMAZON_ASIN: 20,
  /** @deprecated */
  EXTERNALGAME_AMAZON_LUNA: 22,
  /** @deprecated */
  EXTERNALGAME_AMAZON_ADG: 23,
  /** @deprecated */
  EXTERNALGAME_EPIC_GAME_STORE: 26,
  /** @deprecated */
  EXTERNALGAME_OCULUS: 28,
  /** @deprecated */
  EXTERNALGAME_UTOMIK: 29,
  /** @deprecated */
  EXTERNALGAME_ITCH_IO: 30,
  /** @deprecated */
  EXTERNALGAME_XBOX_MARKETPLACE: 31,
  /** @deprecated */
  EXTERNALGAME_KARTRIDGE: 32,
  /** @deprecated */
  EXTERNALGAME_PLAYSTATION_STORE_US: 36,
  /** @deprecated */
  EXTERNALGAME_FOCUS_ENTERTAINMENT: 37,
  /** @deprecated */
  EXTERNALGAME_XBOX_GAME_PASS_ULTIMATE_CLOUD: 54,
  /** @deprecated */
  EXTERNALGAME_GAMEJOLT: 55,
  UNRECOGNIZED: -1,
} as const;

export type ExternalGameCategoryEnum = typeof ExternalGameCategoryEnum[keyof typeof ExternalGameCategoryEnum];

export namespace ExternalGameCategoryEnum {
  export type EXTERNALGAME_CATEGORY_NULL = typeof ExternalGameCategoryEnum.EXTERNALGAME_CATEGORY_NULL;
  export type EXTERNALGAME_STEAM = typeof ExternalGameCategoryEnum.EXTERNALGAME_STEAM;
  export type EXTERNALGAME_GOG = typeof ExternalGameCategoryEnum.EXTERNALGAME_GOG;
  export type EXTERNALGAME_YOUTUBE = typeof ExternalGameCategoryEnum.EXTERNALGAME_YOUTUBE;
  export type EXTERNALGAME_MICROSOFT = typeof ExternalGameCategoryEnum.EXTERNALGAME_MICROSOFT;
  export type EXTERNALGAME_APPLE = typeof ExternalGameCategoryEnum.EXTERNALGAME_APPLE;
  export type EXTERNALGAME_TWITCH = typeof ExternalGameCategoryEnum.EXTERNALGAME_TWITCH;
  export type EXTERNALGAME_ANDROID = typeof ExternalGameCategoryEnum.EXTERNALGAME_ANDROID;
  export type EXTERNALGAME_AMAZON_ASIN = typeof ExternalGameCategoryEnum.EXTERNALGAME_AMAZON_ASIN;
  export type EXTERNALGAME_AMAZON_LUNA = typeof ExternalGameCategoryEnum.EXTERNALGAME_AMAZON_LUNA;
  export type EXTERNALGAME_AMAZON_ADG = typeof ExternalGameCategoryEnum.EXTERNALGAME_AMAZON_ADG;
  export type EXTERNALGAME_EPIC_GAME_STORE = typeof ExternalGameCategoryEnum.EXTERNALGAME_EPIC_GAME_STORE;
  export type EXTERNALGAME_OCULUS = typeof ExternalGameCategoryEnum.EXTERNALGAME_OCULUS;
  export type EXTERNALGAME_UTOMIK = typeof ExternalGameCategoryEnum.EXTERNALGAME_UTOMIK;
  export type EXTERNALGAME_ITCH_IO = typeof ExternalGameCategoryEnum.EXTERNALGAME_ITCH_IO;
  export type EXTERNALGAME_XBOX_MARKETPLACE = typeof ExternalGameCategoryEnum.EXTERNALGAME_XBOX_MARKETPLACE;
  export type EXTERNALGAME_KARTRIDGE = typeof ExternalGameCategoryEnum.EXTERNALGAME_KARTRIDGE;
  export type EXTERNALGAME_PLAYSTATION_STORE_US = typeof ExternalGameCategoryEnum.EXTERNALGAME_PLAYSTATION_STORE_US;
  export type EXTERNALGAME_FOCUS_ENTERTAINMENT = typeof ExternalGameCategoryEnum.EXTERNALGAME_FOCUS_ENTERTAINMENT;
  export type EXTERNALGAME_XBOX_GAME_PASS_ULTIMATE_CLOUD =
    typeof ExternalGameCategoryEnum.EXTERNALGAME_XBOX_GAME_PASS_ULTIMATE_CLOUD;
  export type EXTERNALGAME_GAMEJOLT = typeof ExternalGameCategoryEnum.EXTERNALGAME_GAMEJOLT;
  export type UNRECOGNIZED = typeof ExternalGameCategoryEnum.UNRECOGNIZED;
}

export function externalGameCategoryEnumFromJSON(object: any): ExternalGameCategoryEnum {
  switch (object) {
    case 0:
    case "EXTERNALGAME_CATEGORY_NULL":
      return ExternalGameCategoryEnum.EXTERNALGAME_CATEGORY_NULL;
    case 1:
    case "EXTERNALGAME_STEAM":
      return ExternalGameCategoryEnum.EXTERNALGAME_STEAM;
    case 5:
    case "EXTERNALGAME_GOG":
      return ExternalGameCategoryEnum.EXTERNALGAME_GOG;
    case 10:
    case "EXTERNALGAME_YOUTUBE":
      return ExternalGameCategoryEnum.EXTERNALGAME_YOUTUBE;
    case 11:
    case "EXTERNALGAME_MICROSOFT":
      return ExternalGameCategoryEnum.EXTERNALGAME_MICROSOFT;
    case 13:
    case "EXTERNALGAME_APPLE":
      return ExternalGameCategoryEnum.EXTERNALGAME_APPLE;
    case 14:
    case "EXTERNALGAME_TWITCH":
      return ExternalGameCategoryEnum.EXTERNALGAME_TWITCH;
    case 15:
    case "EXTERNALGAME_ANDROID":
      return ExternalGameCategoryEnum.EXTERNALGAME_ANDROID;
    case 20:
    case "EXTERNALGAME_AMAZON_ASIN":
      return ExternalGameCategoryEnum.EXTERNALGAME_AMAZON_ASIN;
    case 22:
    case "EXTERNALGAME_AMAZON_LUNA":
      return ExternalGameCategoryEnum.EXTERNALGAME_AMAZON_LUNA;
    case 23:
    case "EXTERNALGAME_AMAZON_ADG":
      return ExternalGameCategoryEnum.EXTERNALGAME_AMAZON_ADG;
    case 26:
    case "EXTERNALGAME_EPIC_GAME_STORE":
      return ExternalGameCategoryEnum.EXTERNALGAME_EPIC_GAME_STORE;
    case 28:
    case "EXTERNALGAME_OCULUS":
      return ExternalGameCategoryEnum.EXTERNALGAME_OCULUS;
    case 29:
    case "EXTERNALGAME_UTOMIK":
      return ExternalGameCategoryEnum.EXTERNALGAME_UTOMIK;
    case 30:
    case "EXTERNALGAME_ITCH_IO":
      return ExternalGameCategoryEnum.EXTERNALGAME_ITCH_IO;
    case 31:
    case "EXTERNALGAME_XBOX_MARKETPLACE":
      return ExternalGameCategoryEnum.EXTERNALGAME_XBOX_MARKETPLACE;
    case 32:
    case "EXTERNALGAME_KARTRIDGE":
      return ExternalGameCategoryEnum.EXTERNALGAME_KARTRIDGE;
    case 36:
    case "EXTERNALGAME_PLAYSTATION_STORE_US":
      return ExternalGameCategoryEnum.EXTERNALGAME_PLAYSTATION_STORE_US;
    case 37:
    case "EXTERNALGAME_FOCUS_ENTERTAINMENT":
      return ExternalGameCategoryEnum.EXTERNALGAME_FOCUS_ENTERTAINMENT;
    case 54:
    case "EXTERNALGAME_XBOX_GAME_PASS_ULTIMATE_CLOUD":
      return ExternalGameCategoryEnum.EXTERNALGAME_XBOX_GAME_PASS_ULTIMATE_CLOUD;
    case 55:
    case "EXTERNALGAME_GAMEJOLT":
      return ExternalGameCategoryEnum.EXTERNALGAME_GAMEJOLT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExternalGameCategoryEnum.UNRECOGNIZED;
  }
}

export function externalGameCategoryEnumToJSON(object: ExternalGameCategoryEnum): string {
  switch (object) {
    case ExternalGameCategoryEnum.EXTERNALGAME_CATEGORY_NULL:
      return "EXTERNALGAME_CATEGORY_NULL";
    case ExternalGameCategoryEnum.EXTERNALGAME_STEAM:
      return "EXTERNALGAME_STEAM";
    case ExternalGameCategoryEnum.EXTERNALGAME_GOG:
      return "EXTERNALGAME_GOG";
    case ExternalGameCategoryEnum.EXTERNALGAME_YOUTUBE:
      return "EXTERNALGAME_YOUTUBE";
    case ExternalGameCategoryEnum.EXTERNALGAME_MICROSOFT:
      return "EXTERNALGAME_MICROSOFT";
    case ExternalGameCategoryEnum.EXTERNALGAME_APPLE:
      return "EXTERNALGAME_APPLE";
    case ExternalGameCategoryEnum.EXTERNALGAME_TWITCH:
      return "EXTERNALGAME_TWITCH";
    case ExternalGameCategoryEnum.EXTERNALGAME_ANDROID:
      return "EXTERNALGAME_ANDROID";
    case ExternalGameCategoryEnum.EXTERNALGAME_AMAZON_ASIN:
      return "EXTERNALGAME_AMAZON_ASIN";
    case ExternalGameCategoryEnum.EXTERNALGAME_AMAZON_LUNA:
      return "EXTERNALGAME_AMAZON_LUNA";
    case ExternalGameCategoryEnum.EXTERNALGAME_AMAZON_ADG:
      return "EXTERNALGAME_AMAZON_ADG";
    case ExternalGameCategoryEnum.EXTERNALGAME_EPIC_GAME_STORE:
      return "EXTERNALGAME_EPIC_GAME_STORE";
    case ExternalGameCategoryEnum.EXTERNALGAME_OCULUS:
      return "EXTERNALGAME_OCULUS";
    case ExternalGameCategoryEnum.EXTERNALGAME_UTOMIK:
      return "EXTERNALGAME_UTOMIK";
    case ExternalGameCategoryEnum.EXTERNALGAME_ITCH_IO:
      return "EXTERNALGAME_ITCH_IO";
    case ExternalGameCategoryEnum.EXTERNALGAME_XBOX_MARKETPLACE:
      return "EXTERNALGAME_XBOX_MARKETPLACE";
    case ExternalGameCategoryEnum.EXTERNALGAME_KARTRIDGE:
      return "EXTERNALGAME_KARTRIDGE";
    case ExternalGameCategoryEnum.EXTERNALGAME_PLAYSTATION_STORE_US:
      return "EXTERNALGAME_PLAYSTATION_STORE_US";
    case ExternalGameCategoryEnum.EXTERNALGAME_FOCUS_ENTERTAINMENT:
      return "EXTERNALGAME_FOCUS_ENTERTAINMENT";
    case ExternalGameCategoryEnum.EXTERNALGAME_XBOX_GAME_PASS_ULTIMATE_CLOUD:
      return "EXTERNALGAME_XBOX_GAME_PASS_ULTIMATE_CLOUD";
    case ExternalGameCategoryEnum.EXTERNALGAME_GAMEJOLT:
      return "EXTERNALGAME_GAMEJOLT";
    case ExternalGameCategoryEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const ExternalGameMediaEnum = {
  /** @deprecated */
  EXTERNALGAME_MEDIA_NULL: 0,
  /** @deprecated */
  EXTERNALGAME_DIGITAL: 1,
  /** @deprecated */
  EXTERNALGAME_PHYSICAL: 2,
  UNRECOGNIZED: -1,
} as const;

export type ExternalGameMediaEnum = typeof ExternalGameMediaEnum[keyof typeof ExternalGameMediaEnum];

export namespace ExternalGameMediaEnum {
  export type EXTERNALGAME_MEDIA_NULL = typeof ExternalGameMediaEnum.EXTERNALGAME_MEDIA_NULL;
  export type EXTERNALGAME_DIGITAL = typeof ExternalGameMediaEnum.EXTERNALGAME_DIGITAL;
  export type EXTERNALGAME_PHYSICAL = typeof ExternalGameMediaEnum.EXTERNALGAME_PHYSICAL;
  export type UNRECOGNIZED = typeof ExternalGameMediaEnum.UNRECOGNIZED;
}

export function externalGameMediaEnumFromJSON(object: any): ExternalGameMediaEnum {
  switch (object) {
    case 0:
    case "EXTERNALGAME_MEDIA_NULL":
      return ExternalGameMediaEnum.EXTERNALGAME_MEDIA_NULL;
    case 1:
    case "EXTERNALGAME_DIGITAL":
      return ExternalGameMediaEnum.EXTERNALGAME_DIGITAL;
    case 2:
    case "EXTERNALGAME_PHYSICAL":
      return ExternalGameMediaEnum.EXTERNALGAME_PHYSICAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExternalGameMediaEnum.UNRECOGNIZED;
  }
}

export function externalGameMediaEnumToJSON(object: ExternalGameMediaEnum): string {
  switch (object) {
    case ExternalGameMediaEnum.EXTERNALGAME_MEDIA_NULL:
      return "EXTERNALGAME_MEDIA_NULL";
    case ExternalGameMediaEnum.EXTERNALGAME_DIGITAL:
      return "EXTERNALGAME_DIGITAL";
    case ExternalGameMediaEnum.EXTERNALGAME_PHYSICAL:
      return "EXTERNALGAME_PHYSICAL";
    case ExternalGameMediaEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const GameCategoryEnum = {
  /** @deprecated */
  MAIN_GAME: 0,
  /** @deprecated */
  DLC_ADDON: 1,
  /** @deprecated */
  EXPANSION: 2,
  /** @deprecated */
  BUNDLE: 3,
  /** @deprecated */
  STANDALONE_EXPANSION: 4,
  /** @deprecated */
  MOD: 5,
  /** @deprecated */
  EPISODE: 6,
  /** @deprecated */
  SEASON: 7,
  /** @deprecated */
  REMAKE: 8,
  /** @deprecated */
  REMASTER: 9,
  /** @deprecated */
  EXPANDED_GAME: 10,
  /** @deprecated */
  PORT: 11,
  /** @deprecated */
  FORK: 12,
  /** @deprecated */
  PACK: 13,
  /** @deprecated */
  UPDATE: 14,
  UNRECOGNIZED: -1,
} as const;

export type GameCategoryEnum = typeof GameCategoryEnum[keyof typeof GameCategoryEnum];

export namespace GameCategoryEnum {
  export type MAIN_GAME = typeof GameCategoryEnum.MAIN_GAME;
  export type DLC_ADDON = typeof GameCategoryEnum.DLC_ADDON;
  export type EXPANSION = typeof GameCategoryEnum.EXPANSION;
  export type BUNDLE = typeof GameCategoryEnum.BUNDLE;
  export type STANDALONE_EXPANSION = typeof GameCategoryEnum.STANDALONE_EXPANSION;
  export type MOD = typeof GameCategoryEnum.MOD;
  export type EPISODE = typeof GameCategoryEnum.EPISODE;
  export type SEASON = typeof GameCategoryEnum.SEASON;
  export type REMAKE = typeof GameCategoryEnum.REMAKE;
  export type REMASTER = typeof GameCategoryEnum.REMASTER;
  export type EXPANDED_GAME = typeof GameCategoryEnum.EXPANDED_GAME;
  export type PORT = typeof GameCategoryEnum.PORT;
  export type FORK = typeof GameCategoryEnum.FORK;
  export type PACK = typeof GameCategoryEnum.PACK;
  export type UPDATE = typeof GameCategoryEnum.UPDATE;
  export type UNRECOGNIZED = typeof GameCategoryEnum.UNRECOGNIZED;
}

export function gameCategoryEnumFromJSON(object: any): GameCategoryEnum {
  switch (object) {
    case 0:
    case "MAIN_GAME":
      return GameCategoryEnum.MAIN_GAME;
    case 1:
    case "DLC_ADDON":
      return GameCategoryEnum.DLC_ADDON;
    case 2:
    case "EXPANSION":
      return GameCategoryEnum.EXPANSION;
    case 3:
    case "BUNDLE":
      return GameCategoryEnum.BUNDLE;
    case 4:
    case "STANDALONE_EXPANSION":
      return GameCategoryEnum.STANDALONE_EXPANSION;
    case 5:
    case "MOD":
      return GameCategoryEnum.MOD;
    case 6:
    case "EPISODE":
      return GameCategoryEnum.EPISODE;
    case 7:
    case "SEASON":
      return GameCategoryEnum.SEASON;
    case 8:
    case "REMAKE":
      return GameCategoryEnum.REMAKE;
    case 9:
    case "REMASTER":
      return GameCategoryEnum.REMASTER;
    case 10:
    case "EXPANDED_GAME":
      return GameCategoryEnum.EXPANDED_GAME;
    case 11:
    case "PORT":
      return GameCategoryEnum.PORT;
    case 12:
    case "FORK":
      return GameCategoryEnum.FORK;
    case 13:
    case "PACK":
      return GameCategoryEnum.PACK;
    case 14:
    case "UPDATE":
      return GameCategoryEnum.UPDATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GameCategoryEnum.UNRECOGNIZED;
  }
}

export function gameCategoryEnumToJSON(object: GameCategoryEnum): string {
  switch (object) {
    case GameCategoryEnum.MAIN_GAME:
      return "MAIN_GAME";
    case GameCategoryEnum.DLC_ADDON:
      return "DLC_ADDON";
    case GameCategoryEnum.EXPANSION:
      return "EXPANSION";
    case GameCategoryEnum.BUNDLE:
      return "BUNDLE";
    case GameCategoryEnum.STANDALONE_EXPANSION:
      return "STANDALONE_EXPANSION";
    case GameCategoryEnum.MOD:
      return "MOD";
    case GameCategoryEnum.EPISODE:
      return "EPISODE";
    case GameCategoryEnum.SEASON:
      return "SEASON";
    case GameCategoryEnum.REMAKE:
      return "REMAKE";
    case GameCategoryEnum.REMASTER:
      return "REMASTER";
    case GameCategoryEnum.EXPANDED_GAME:
      return "EXPANDED_GAME";
    case GameCategoryEnum.PORT:
      return "PORT";
    case GameCategoryEnum.FORK:
      return "FORK";
    case GameCategoryEnum.PACK:
      return "PACK";
    case GameCategoryEnum.UPDATE:
      return "UPDATE";
    case GameCategoryEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const GameStatusEnum = {
  /** @deprecated */
  RELEASED: 0,
  /** @deprecated */
  ALPHA: 2,
  /** @deprecated */
  BETA: 3,
  /** @deprecated */
  EARLY_ACCESS: 4,
  /** @deprecated */
  OFFLINE: 5,
  /** @deprecated */
  CANCELLED: 6,
  /** @deprecated */
  RUMORED: 7,
  /** @deprecated */
  DELISTED: 8,
  UNRECOGNIZED: -1,
} as const;

export type GameStatusEnum = typeof GameStatusEnum[keyof typeof GameStatusEnum];

export namespace GameStatusEnum {
  export type RELEASED = typeof GameStatusEnum.RELEASED;
  export type ALPHA = typeof GameStatusEnum.ALPHA;
  export type BETA = typeof GameStatusEnum.BETA;
  export type EARLY_ACCESS = typeof GameStatusEnum.EARLY_ACCESS;
  export type OFFLINE = typeof GameStatusEnum.OFFLINE;
  export type CANCELLED = typeof GameStatusEnum.CANCELLED;
  export type RUMORED = typeof GameStatusEnum.RUMORED;
  export type DELISTED = typeof GameStatusEnum.DELISTED;
  export type UNRECOGNIZED = typeof GameStatusEnum.UNRECOGNIZED;
}

export function gameStatusEnumFromJSON(object: any): GameStatusEnum {
  switch (object) {
    case 0:
    case "RELEASED":
      return GameStatusEnum.RELEASED;
    case 2:
    case "ALPHA":
      return GameStatusEnum.ALPHA;
    case 3:
    case "BETA":
      return GameStatusEnum.BETA;
    case 4:
    case "EARLY_ACCESS":
      return GameStatusEnum.EARLY_ACCESS;
    case 5:
    case "OFFLINE":
      return GameStatusEnum.OFFLINE;
    case 6:
    case "CANCELLED":
      return GameStatusEnum.CANCELLED;
    case 7:
    case "RUMORED":
      return GameStatusEnum.RUMORED;
    case 8:
    case "DELISTED":
      return GameStatusEnum.DELISTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GameStatusEnum.UNRECOGNIZED;
  }
}

export function gameStatusEnumToJSON(object: GameStatusEnum): string {
  switch (object) {
    case GameStatusEnum.RELEASED:
      return "RELEASED";
    case GameStatusEnum.ALPHA:
      return "ALPHA";
    case GameStatusEnum.BETA:
      return "BETA";
    case GameStatusEnum.EARLY_ACCESS:
      return "EARLY_ACCESS";
    case GameStatusEnum.OFFLINE:
      return "OFFLINE";
    case GameStatusEnum.CANCELLED:
      return "CANCELLED";
    case GameStatusEnum.RUMORED:
      return "RUMORED";
    case GameStatusEnum.DELISTED:
      return "DELISTED";
    case GameStatusEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const GameVersionFeatureCategoryEnum = { BOOLEAN: 0, DESCRIPTION: 1, UNRECOGNIZED: -1 } as const;

export type GameVersionFeatureCategoryEnum =
  typeof GameVersionFeatureCategoryEnum[keyof typeof GameVersionFeatureCategoryEnum];

export namespace GameVersionFeatureCategoryEnum {
  export type BOOLEAN = typeof GameVersionFeatureCategoryEnum.BOOLEAN;
  export type DESCRIPTION = typeof GameVersionFeatureCategoryEnum.DESCRIPTION;
  export type UNRECOGNIZED = typeof GameVersionFeatureCategoryEnum.UNRECOGNIZED;
}

export function gameVersionFeatureCategoryEnumFromJSON(object: any): GameVersionFeatureCategoryEnum {
  switch (object) {
    case 0:
    case "BOOLEAN":
      return GameVersionFeatureCategoryEnum.BOOLEAN;
    case 1:
    case "DESCRIPTION":
      return GameVersionFeatureCategoryEnum.DESCRIPTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GameVersionFeatureCategoryEnum.UNRECOGNIZED;
  }
}

export function gameVersionFeatureCategoryEnumToJSON(object: GameVersionFeatureCategoryEnum): string {
  switch (object) {
    case GameVersionFeatureCategoryEnum.BOOLEAN:
      return "BOOLEAN";
    case GameVersionFeatureCategoryEnum.DESCRIPTION:
      return "DESCRIPTION";
    case GameVersionFeatureCategoryEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const GameVersionFeatureValueIncludedFeatureEnum = {
  NOT_INCLUDED: 0,
  INCLUDED: 1,
  PRE_ORDER_ONLY: 2,
  UNRECOGNIZED: -1,
} as const;

export type GameVersionFeatureValueIncludedFeatureEnum =
  typeof GameVersionFeatureValueIncludedFeatureEnum[keyof typeof GameVersionFeatureValueIncludedFeatureEnum];

export namespace GameVersionFeatureValueIncludedFeatureEnum {
  export type NOT_INCLUDED = typeof GameVersionFeatureValueIncludedFeatureEnum.NOT_INCLUDED;
  export type INCLUDED = typeof GameVersionFeatureValueIncludedFeatureEnum.INCLUDED;
  export type PRE_ORDER_ONLY = typeof GameVersionFeatureValueIncludedFeatureEnum.PRE_ORDER_ONLY;
  export type UNRECOGNIZED = typeof GameVersionFeatureValueIncludedFeatureEnum.UNRECOGNIZED;
}

export function gameVersionFeatureValueIncludedFeatureEnumFromJSON(
  object: any,
): GameVersionFeatureValueIncludedFeatureEnum {
  switch (object) {
    case 0:
    case "NOT_INCLUDED":
      return GameVersionFeatureValueIncludedFeatureEnum.NOT_INCLUDED;
    case 1:
    case "INCLUDED":
      return GameVersionFeatureValueIncludedFeatureEnum.INCLUDED;
    case 2:
    case "PRE_ORDER_ONLY":
      return GameVersionFeatureValueIncludedFeatureEnum.PRE_ORDER_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GameVersionFeatureValueIncludedFeatureEnum.UNRECOGNIZED;
  }
}

export function gameVersionFeatureValueIncludedFeatureEnumToJSON(
  object: GameVersionFeatureValueIncludedFeatureEnum,
): string {
  switch (object) {
    case GameVersionFeatureValueIncludedFeatureEnum.NOT_INCLUDED:
      return "NOT_INCLUDED";
    case GameVersionFeatureValueIncludedFeatureEnum.INCLUDED:
      return "INCLUDED";
    case GameVersionFeatureValueIncludedFeatureEnum.PRE_ORDER_ONLY:
      return "PRE_ORDER_ONLY";
    case GameVersionFeatureValueIncludedFeatureEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const PlatformCategoryEnum = {
  /** @deprecated */
  PLATFORM_CATEGORY_NULL: 0,
  /** @deprecated */
  CONSOLE: 1,
  /** @deprecated */
  ARCADE: 2,
  /** @deprecated */
  PLATFORM: 3,
  /** @deprecated */
  OPERATING_SYSTEM: 4,
  /** @deprecated */
  PORTABLE_CONSOLE: 5,
  /** @deprecated */
  COMPUTER: 6,
  UNRECOGNIZED: -1,
} as const;

export type PlatformCategoryEnum = typeof PlatformCategoryEnum[keyof typeof PlatformCategoryEnum];

export namespace PlatformCategoryEnum {
  export type PLATFORM_CATEGORY_NULL = typeof PlatformCategoryEnum.PLATFORM_CATEGORY_NULL;
  export type CONSOLE = typeof PlatformCategoryEnum.CONSOLE;
  export type ARCADE = typeof PlatformCategoryEnum.ARCADE;
  export type PLATFORM = typeof PlatformCategoryEnum.PLATFORM;
  export type OPERATING_SYSTEM = typeof PlatformCategoryEnum.OPERATING_SYSTEM;
  export type PORTABLE_CONSOLE = typeof PlatformCategoryEnum.PORTABLE_CONSOLE;
  export type COMPUTER = typeof PlatformCategoryEnum.COMPUTER;
  export type UNRECOGNIZED = typeof PlatformCategoryEnum.UNRECOGNIZED;
}

export function platformCategoryEnumFromJSON(object: any): PlatformCategoryEnum {
  switch (object) {
    case 0:
    case "PLATFORM_CATEGORY_NULL":
      return PlatformCategoryEnum.PLATFORM_CATEGORY_NULL;
    case 1:
    case "CONSOLE":
      return PlatformCategoryEnum.CONSOLE;
    case 2:
    case "ARCADE":
      return PlatformCategoryEnum.ARCADE;
    case 3:
    case "PLATFORM":
      return PlatformCategoryEnum.PLATFORM;
    case 4:
    case "OPERATING_SYSTEM":
      return PlatformCategoryEnum.OPERATING_SYSTEM;
    case 5:
    case "PORTABLE_CONSOLE":
      return PlatformCategoryEnum.PORTABLE_CONSOLE;
    case 6:
    case "COMPUTER":
      return PlatformCategoryEnum.COMPUTER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PlatformCategoryEnum.UNRECOGNIZED;
  }
}

export function platformCategoryEnumToJSON(object: PlatformCategoryEnum): string {
  switch (object) {
    case PlatformCategoryEnum.PLATFORM_CATEGORY_NULL:
      return "PLATFORM_CATEGORY_NULL";
    case PlatformCategoryEnum.CONSOLE:
      return "CONSOLE";
    case PlatformCategoryEnum.ARCADE:
      return "ARCADE";
    case PlatformCategoryEnum.PLATFORM:
      return "PLATFORM";
    case PlatformCategoryEnum.OPERATING_SYSTEM:
      return "OPERATING_SYSTEM";
    case PlatformCategoryEnum.PORTABLE_CONSOLE:
      return "PORTABLE_CONSOLE";
    case PlatformCategoryEnum.COMPUTER:
      return "COMPUTER";
    case PlatformCategoryEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const RegionRegionEnum = {
  /** @deprecated */
  REGION_REGION_NULL: 0,
  /** @deprecated */
  EUROPE: 1,
  /** @deprecated */
  NORTH_AMERICA: 2,
  /** @deprecated */
  AUSTRALIA: 3,
  /** @deprecated */
  NEW_ZEALAND: 4,
  /** @deprecated */
  JAPAN: 5,
  /** @deprecated */
  CHINA: 6,
  /** @deprecated */
  ASIA: 7,
  /** @deprecated */
  WORLDWIDE: 8,
  /** @deprecated */
  KOREA: 9,
  /** @deprecated */
  BRAZIL: 10,
  UNRECOGNIZED: -1,
} as const;

export type RegionRegionEnum = typeof RegionRegionEnum[keyof typeof RegionRegionEnum];

export namespace RegionRegionEnum {
  export type REGION_REGION_NULL = typeof RegionRegionEnum.REGION_REGION_NULL;
  export type EUROPE = typeof RegionRegionEnum.EUROPE;
  export type NORTH_AMERICA = typeof RegionRegionEnum.NORTH_AMERICA;
  export type AUSTRALIA = typeof RegionRegionEnum.AUSTRALIA;
  export type NEW_ZEALAND = typeof RegionRegionEnum.NEW_ZEALAND;
  export type JAPAN = typeof RegionRegionEnum.JAPAN;
  export type CHINA = typeof RegionRegionEnum.CHINA;
  export type ASIA = typeof RegionRegionEnum.ASIA;
  export type WORLDWIDE = typeof RegionRegionEnum.WORLDWIDE;
  export type KOREA = typeof RegionRegionEnum.KOREA;
  export type BRAZIL = typeof RegionRegionEnum.BRAZIL;
  export type UNRECOGNIZED = typeof RegionRegionEnum.UNRECOGNIZED;
}

export function regionRegionEnumFromJSON(object: any): RegionRegionEnum {
  switch (object) {
    case 0:
    case "REGION_REGION_NULL":
      return RegionRegionEnum.REGION_REGION_NULL;
    case 1:
    case "EUROPE":
      return RegionRegionEnum.EUROPE;
    case 2:
    case "NORTH_AMERICA":
      return RegionRegionEnum.NORTH_AMERICA;
    case 3:
    case "AUSTRALIA":
      return RegionRegionEnum.AUSTRALIA;
    case 4:
    case "NEW_ZEALAND":
      return RegionRegionEnum.NEW_ZEALAND;
    case 5:
    case "JAPAN":
      return RegionRegionEnum.JAPAN;
    case 6:
    case "CHINA":
      return RegionRegionEnum.CHINA;
    case 7:
    case "ASIA":
      return RegionRegionEnum.ASIA;
    case 8:
    case "WORLDWIDE":
      return RegionRegionEnum.WORLDWIDE;
    case 9:
    case "KOREA":
      return RegionRegionEnum.KOREA;
    case 10:
    case "BRAZIL":
      return RegionRegionEnum.BRAZIL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RegionRegionEnum.UNRECOGNIZED;
  }
}

export function regionRegionEnumToJSON(object: RegionRegionEnum): string {
  switch (object) {
    case RegionRegionEnum.REGION_REGION_NULL:
      return "REGION_REGION_NULL";
    case RegionRegionEnum.EUROPE:
      return "EUROPE";
    case RegionRegionEnum.NORTH_AMERICA:
      return "NORTH_AMERICA";
    case RegionRegionEnum.AUSTRALIA:
      return "AUSTRALIA";
    case RegionRegionEnum.NEW_ZEALAND:
      return "NEW_ZEALAND";
    case RegionRegionEnum.JAPAN:
      return "JAPAN";
    case RegionRegionEnum.CHINA:
      return "CHINA";
    case RegionRegionEnum.ASIA:
      return "ASIA";
    case RegionRegionEnum.WORLDWIDE:
      return "WORLDWIDE";
    case RegionRegionEnum.KOREA:
      return "KOREA";
    case RegionRegionEnum.BRAZIL:
      return "BRAZIL";
    case RegionRegionEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const PopularitySourcePopularitySourceEnum = {
  /** @deprecated */
  POPULARITYSOURCE_POPULARITY_SOURCE_NULL: 0,
  /** @deprecated */
  IGDB: 121,
  UNRECOGNIZED: -1,
} as const;

export type PopularitySourcePopularitySourceEnum =
  typeof PopularitySourcePopularitySourceEnum[keyof typeof PopularitySourcePopularitySourceEnum];

export namespace PopularitySourcePopularitySourceEnum {
  export type POPULARITYSOURCE_POPULARITY_SOURCE_NULL =
    typeof PopularitySourcePopularitySourceEnum.POPULARITYSOURCE_POPULARITY_SOURCE_NULL;
  export type IGDB = typeof PopularitySourcePopularitySourceEnum.IGDB;
  export type UNRECOGNIZED = typeof PopularitySourcePopularitySourceEnum.UNRECOGNIZED;
}

export function popularitySourcePopularitySourceEnumFromJSON(object: any): PopularitySourcePopularitySourceEnum {
  switch (object) {
    case 0:
    case "POPULARITYSOURCE_POPULARITY_SOURCE_NULL":
      return PopularitySourcePopularitySourceEnum.POPULARITYSOURCE_POPULARITY_SOURCE_NULL;
    case 121:
    case "IGDB":
      return PopularitySourcePopularitySourceEnum.IGDB;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PopularitySourcePopularitySourceEnum.UNRECOGNIZED;
  }
}

export function popularitySourcePopularitySourceEnumToJSON(object: PopularitySourcePopularitySourceEnum): string {
  switch (object) {
    case PopularitySourcePopularitySourceEnum.POPULARITYSOURCE_POPULARITY_SOURCE_NULL:
      return "POPULARITYSOURCE_POPULARITY_SOURCE_NULL";
    case PopularitySourcePopularitySourceEnum.IGDB:
      return "IGDB";
    case PopularitySourcePopularitySourceEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export const TestDummyEnumTestEnum = { TESTDUMMY_ENUM_TEST_NULL: 0, ENUM1: 1, ENUM2: 2, UNRECOGNIZED: -1 } as const;

export type TestDummyEnumTestEnum = typeof TestDummyEnumTestEnum[keyof typeof TestDummyEnumTestEnum];

export namespace TestDummyEnumTestEnum {
  export type TESTDUMMY_ENUM_TEST_NULL = typeof TestDummyEnumTestEnum.TESTDUMMY_ENUM_TEST_NULL;
  export type ENUM1 = typeof TestDummyEnumTestEnum.ENUM1;
  export type ENUM2 = typeof TestDummyEnumTestEnum.ENUM2;
  export type UNRECOGNIZED = typeof TestDummyEnumTestEnum.UNRECOGNIZED;
}

export function testDummyEnumTestEnumFromJSON(object: any): TestDummyEnumTestEnum {
  switch (object) {
    case 0:
    case "TESTDUMMY_ENUM_TEST_NULL":
      return TestDummyEnumTestEnum.TESTDUMMY_ENUM_TEST_NULL;
    case 1:
    case "ENUM1":
      return TestDummyEnumTestEnum.ENUM1;
    case 2:
    case "ENUM2":
      return TestDummyEnumTestEnum.ENUM2;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TestDummyEnumTestEnum.UNRECOGNIZED;
  }
}

export function testDummyEnumTestEnumToJSON(object: TestDummyEnumTestEnum): string {
  switch (object) {
    case TestDummyEnumTestEnum.TESTDUMMY_ENUM_TEST_NULL:
      return "TESTDUMMY_ENUM_TEST_NULL";
    case TestDummyEnumTestEnum.ENUM1:
      return "ENUM1";
    case TestDummyEnumTestEnum.ENUM2:
      return "ENUM2";
    case TestDummyEnumTestEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Count {
  count: number;
}

export interface MultiQueryResult {
  name: string;
  results: Uint8Array[];
  count: number;
}

export interface MultiQueryResultArray {
  result: MultiQueryResult[];
}

export interface AgeRatingResult {
  ageratings: AgeRating[];
}

export interface AgeRating {
  id: number;
  /** @deprecated */
  category: AgeRatingCategoryEnum;
  contentDescriptions: AgeRatingContentDescription[];
  /** @deprecated */
  rating: AgeRatingRatingEnum;
  ratingCoverUrl: string;
  synopsis: string;
  checksum: string;
  organization?: AgeRatingOrganization | undefined;
  ratingCategory?: AgeRatingCategory | undefined;
  ratingContentDescriptions: AgeRatingContentDescriptionV2[];
}

export interface AgeRatingCategoryResult {
  ageratingcategories: AgeRatingCategory[];
}

export interface AgeRatingCategory {
  id: number;
  rating: string;
  organization?: AgeRatingOrganization | undefined;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface AgeRatingContentDescriptionResult {
  ageratingcontentdescriptions: AgeRatingContentDescription[];
}

export interface AgeRatingContentDescription {
  id: number;
  /** @deprecated */
  category: AgeRatingContentDescriptionCategoryEnum;
  description: string;
  checksum: string;
}

export interface AgeRatingContentDescriptionV2Result {
  ageratingcontentdescriptionsv2: AgeRatingContentDescriptionV2[];
}

export interface AgeRatingContentDescriptionV2 {
  id: number;
  description: string;
  organization?: AgeRatingOrganization | undefined;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface AgeRatingOrganizationResult {
  ageratingorganizations: AgeRatingOrganization[];
}

export interface AgeRatingOrganization {
  id: number;
  name: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface AlternativeNameResult {
  alternativenames: AlternativeName[];
}

export interface AlternativeName {
  id: number;
  comment: string;
  game?: Game | undefined;
  name: string;
  checksum: string;
}

export interface ArtworkResult {
  artworks: Artwork[];
}

export interface Artwork {
  id: number;
  alphaChannel: boolean;
  animated: boolean;
  game?: Game | undefined;
  height: number;
  imageId: string;
  url: string;
  width: number;
  checksum: string;
}

export interface CharacterResult {
  characters: Character[];
}

export interface Character {
  id: number;
  akas: string[];
  countryName: string;
  createdAt?: Timestamp | undefined;
  description: string;
  games: Game[];
  /** @deprecated */
  gender: GenderGenderEnum;
  mugShot?: CharacterMugShot | undefined;
  name: string;
  slug: string;
  /** @deprecated */
  species: CharacterSpeciesEnum;
  updatedAt?: Timestamp | undefined;
  url: string;
  checksum: string;
  characterGender?: CharacterGender | undefined;
  characterSpecies?: CharacterSpecie | undefined;
}

export interface CharacterGenderResult {
  charactergenders: CharacterGender[];
}

export interface CharacterGender {
  id: number;
  name: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface CharacterMugShotResult {
  charactermugshots: CharacterMugShot[];
}

export interface CharacterMugShot {
  id: number;
  alphaChannel: boolean;
  animated: boolean;
  height: number;
  imageId: string;
  url: string;
  width: number;
  checksum: string;
}

export interface CharacterSpecieResult {
  characterspecies: CharacterSpecie[];
}

export interface CharacterSpecie {
  id: number;
  name: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface CollectionResult {
  collections: Collection[];
}

export interface Collection {
  id: number;
  createdAt?: Timestamp | undefined;
  games: Game[];
  name: string;
  slug: string;
  updatedAt?: Timestamp | undefined;
  url: string;
  checksum: string;
  type?: CollectionType | undefined;
  asParentRelations: CollectionRelation[];
  asChildRelations: CollectionRelation[];
}

export interface CollectionMembershipResult {
  collectionmemberships: CollectionMembership[];
}

export interface CollectionMembership {
  id: number;
  game?: Game | undefined;
  collection?: Collection | undefined;
  type?: CollectionMembershipType | undefined;
  updatedAt?: Timestamp | undefined;
  createdAt?: Timestamp | undefined;
  checksum: string;
}

export interface CollectionMembershipTypeResult {
  collectionmembershiptypes: CollectionMembershipType[];
}

export interface CollectionMembershipType {
  id: number;
  name: string;
  description: string;
  allowedCollectionType?: CollectionType | undefined;
  updatedAt?: Timestamp | undefined;
  createdAt?: Timestamp | undefined;
  checksum: string;
}

export interface CollectionRelationResult {
  collectionrelations: CollectionRelation[];
}

export interface CollectionRelation {
  id: number;
  childCollection?: Collection | undefined;
  parentCollection?: Collection | undefined;
  type?: CollectionRelationType | undefined;
  updatedAt?: Timestamp | undefined;
  createdAt?: Timestamp | undefined;
  checksum: string;
}

export interface CollectionRelationTypeResult {
  collectionrelationtypes: CollectionRelationType[];
}

export interface CollectionRelationType {
  id: number;
  name: string;
  description: string;
  allowedChildType?: CollectionType | undefined;
  allowedParentType?: CollectionType | undefined;
  updatedAt?: Timestamp | undefined;
  createdAt?: Timestamp | undefined;
  checksum: string;
}

export interface CollectionTypeResult {
  collectiontypes: CollectionType[];
}

export interface CollectionType {
  id: number;
  name: string;
  description: string;
  updatedAt?: Timestamp | undefined;
  createdAt?: Timestamp | undefined;
  checksum: string;
}

export interface CompanyResult {
  companies: Company[];
}

export interface Company {
  id: number;
  changeDate?:
    | Timestamp
    | undefined;
  /** @deprecated */
  changeDateCategory: DateFormatChangeDateCategoryEnum;
  changedCompanyId?: Company | undefined;
  country: number;
  createdAt?: Timestamp | undefined;
  description: string;
  developed: Game[];
  logo?: CompanyLogo | undefined;
  name: string;
  parent?: Company | undefined;
  published: Game[];
  slug: string;
  startDate?:
    | Timestamp
    | undefined;
  /** @deprecated */
  startDateCategory: DateFormatChangeDateCategoryEnum;
  updatedAt?: Timestamp | undefined;
  url: string;
  websites: CompanyWebsite[];
  checksum: string;
  status?: CompanyStatus | undefined;
  startDateFormat?: DateFormat | undefined;
  changeDateFormat?: DateFormat | undefined;
}

export interface CompanyLogoResult {
  companylogos: CompanyLogo[];
}

export interface CompanyLogo {
  id: number;
  alphaChannel: boolean;
  animated: boolean;
  height: number;
  imageId: string;
  url: string;
  width: number;
  checksum: string;
}

export interface CompanyStatusResult {
  companystatuses: CompanyStatus[];
}

export interface CompanyStatus {
  id: number;
  name: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface CompanyWebsiteResult {
  companywebsites: CompanyWebsite[];
}

export interface CompanyWebsite {
  id: number;
  /** @deprecated */
  category: WebsiteCategoryEnum;
  trusted: boolean;
  url: string;
  checksum: string;
  type?: WebsiteType | undefined;
}

export interface CoverResult {
  covers: Cover[];
}

export interface Cover {
  id: number;
  alphaChannel: boolean;
  animated: boolean;
  game?: Game | undefined;
  height: number;
  imageId: string;
  url: string;
  width: number;
  checksum: string;
  gameLocalization?: GameLocalization | undefined;
}

export interface DateFormatResult {
  dateformats: DateFormat[];
}

export interface DateFormat {
  id: number;
  format: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface EventResult {
  events: Event[];
}

export interface Event {
  id: number;
  name: string;
  description: string;
  slug: string;
  eventLogo?: EventLogo | undefined;
  startTime?: Timestamp | undefined;
  timeZone: string;
  endTime?: Timestamp | undefined;
  liveStreamUrl: string;
  games: Game[];
  videos: GameVideo[];
  eventNetworks: EventNetwork[];
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface EventLogoResult {
  eventlogos: EventLogo[];
}

export interface EventLogo {
  id: number;
  event?: Event | undefined;
  alphaChannel: boolean;
  animated: boolean;
  height: number;
  imageId: string;
  url: string;
  width: number;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface EventNetworkResult {
  eventnetworks: EventNetwork[];
}

export interface EventNetwork {
  id: number;
  event?: Event | undefined;
  url: string;
  networkType?: NetworkType | undefined;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface ExternalGameResult {
  externalgames: ExternalGame[];
}

export interface ExternalGame {
  id: number;
  /** @deprecated */
  category: ExternalGameCategoryEnum;
  createdAt?: Timestamp | undefined;
  game?: Game | undefined;
  name: string;
  uid: string;
  updatedAt?: Timestamp | undefined;
  url: string;
  year: number;
  /** @deprecated */
  media: ExternalGameMediaEnum;
  platform?: Platform | undefined;
  countries: number[];
  checksum: string;
  externalGameSource?: ExternalGameSource | undefined;
  gameReleaseFormat?: GameReleaseFormat | undefined;
}

export interface ExternalGameSourceResult {
  externalgamesources: ExternalGameSource[];
}

export interface ExternalGameSource {
  id: number;
  name: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface FranchiseResult {
  franchises: Franchise[];
}

export interface Franchise {
  id: number;
  createdAt?: Timestamp | undefined;
  games: Game[];
  name: string;
  slug: string;
  updatedAt?: Timestamp | undefined;
  url: string;
  checksum: string;
}

export interface GameResult {
  games: Game[];
}

export interface Game {
  id: number;
  ageRatings: AgeRating[];
  aggregatedRating: number;
  aggregatedRatingCount: number;
  alternativeNames: AlternativeName[];
  artworks: Artwork[];
  bundles: Game[];
  /** @deprecated */
  category: GameCategoryEnum;
  /** @deprecated */
  collection?: Collection | undefined;
  cover?: Cover | undefined;
  createdAt?: Timestamp | undefined;
  dlcs: Game[];
  expansions: Game[];
  externalGames: ExternalGame[];
  firstReleaseDate?:
    | Timestamp
    | undefined;
  /** @deprecated */
  follows: number;
  franchise?: Franchise | undefined;
  franchises: Franchise[];
  gameEngines: GameEngine[];
  gameModes: GameMode[];
  genres: Genre[];
  hypes: number;
  involvedCompanies: InvolvedCompany[];
  keywords: Keyword[];
  multiplayerModes: MultiplayerMode[];
  name: string;
  parentGame?: Game | undefined;
  platforms: Platform[];
  playerPerspectives: PlayerPerspective[];
  rating: number;
  ratingCount: number;
  releaseDates: ReleaseDate[];
  screenshots: Screenshot[];
  similarGames: Game[];
  slug: string;
  standaloneExpansions: Game[];
  /** @deprecated */
  status: GameStatusEnum;
  storyline: string;
  summary: string;
  tags: number[];
  themes: Theme[];
  totalRating: number;
  totalRatingCount: number;
  updatedAt?: Timestamp | undefined;
  url: string;
  versionParent?: Game | undefined;
  versionTitle: string;
  videos: GameVideo[];
  websites: Website[];
  checksum: string;
  remakes: Game[];
  remasters: Game[];
  expandedGames: Game[];
  ports: Game[];
  forks: Game[];
  languageSupports: LanguageSupport[];
  gameLocalizations: GameLocalization[];
  collections: Collection[];
  gameStatus?: GameStatus | undefined;
  gameType?: GameType | undefined;
}

export interface GameEngineResult {
  gameengines: GameEngine[];
}

export interface GameEngine {
  id: number;
  companies: Company[];
  createdAt?: Timestamp | undefined;
  description: string;
  logo?: GameEngineLogo | undefined;
  name: string;
  platforms: Platform[];
  slug: string;
  updatedAt?: Timestamp | undefined;
  url: string;
  checksum: string;
}

export interface GameEngineLogoResult {
  gameenginelogos: GameEngineLogo[];
}

export interface GameEngineLogo {
  id: number;
  alphaChannel: boolean;
  animated: boolean;
  height: number;
  imageId: string;
  url: string;
  width: number;
  checksum: string;
}

export interface GameLocalizationResult {
  gamelocalizations: GameLocalization[];
}

export interface GameLocalization {
  id: number;
  name: string;
  cover?: Cover | undefined;
  game?: Game | undefined;
  region?: Region | undefined;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface GameModeResult {
  gamemodes: GameMode[];
}

export interface GameMode {
  id: number;
  createdAt?: Timestamp | undefined;
  name: string;
  slug: string;
  updatedAt?: Timestamp | undefined;
  url: string;
  checksum: string;
}

export interface GameReleaseFormatResult {
  gamereleaseformats: GameReleaseFormat[];
}

export interface GameReleaseFormat {
  id: number;
  format: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface GameStatusResult {
  gamestatuses: GameStatus[];
}

export interface GameStatus {
  id: number;
  status: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface GameTimeToBeatResult {
  gametimetobeats: GameTimeToBeat[];
}

export interface GameTimeToBeat {
  id: number;
  gameId: number;
  hastily: number;
  normally: number;
  completely: number;
  count: number;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface GameTypeResult {
  gametypes: GameType[];
}

export interface GameType {
  id: number;
  type: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface GameVersionResult {
  gameversions: GameVersion[];
}

export interface GameVersion {
  id: number;
  createdAt?: Timestamp | undefined;
  features: GameVersionFeature[];
  game?: Game | undefined;
  games: Game[];
  updatedAt?: Timestamp | undefined;
  url: string;
  checksum: string;
}

export interface GameVersionFeatureResult {
  gameversionfeatures: GameVersionFeature[];
}

export interface GameVersionFeature {
  id: number;
  category: GameVersionFeatureCategoryEnum;
  description: string;
  position: number;
  title: string;
  values: GameVersionFeatureValue[];
  checksum: string;
}

export interface GameVersionFeatureValueResult {
  gameversionfeaturevalues: GameVersionFeatureValue[];
}

export interface GameVersionFeatureValue {
  id: number;
  game?: Game | undefined;
  gameFeature?: GameVersionFeature | undefined;
  includedFeature: GameVersionFeatureValueIncludedFeatureEnum;
  note: string;
  checksum: string;
}

export interface GameVideoResult {
  gamevideos: GameVideo[];
}

export interface GameVideo {
  id: number;
  game?: Game | undefined;
  name: string;
  videoId: string;
  checksum: string;
}

export interface GenreResult {
  genres: Genre[];
}

export interface Genre {
  id: number;
  createdAt?: Timestamp | undefined;
  name: string;
  slug: string;
  updatedAt?: Timestamp | undefined;
  url: string;
  checksum: string;
}

export interface InvolvedCompanyResult {
  involvedcompanies: InvolvedCompany[];
}

export interface InvolvedCompany {
  id: number;
  company?: Company | undefined;
  createdAt?: Timestamp | undefined;
  developer: boolean;
  game?: Game | undefined;
  porting: boolean;
  publisher: boolean;
  supporting: boolean;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface KeywordResult {
  keywords: Keyword[];
}

export interface Keyword {
  id: number;
  createdAt?: Timestamp | undefined;
  name: string;
  slug: string;
  updatedAt?: Timestamp | undefined;
  url: string;
  checksum: string;
}

export interface LanguageResult {
  languages: Language[];
}

export interface Language {
  id: number;
  name: string;
  nativeName: string;
  locale: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface LanguageSupportResult {
  languagesupports: LanguageSupport[];
}

export interface LanguageSupport {
  id: number;
  game?: Game | undefined;
  language?: Language | undefined;
  languageSupportType?: LanguageSupportType | undefined;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface LanguageSupportTypeResult {
  languagesupporttypes: LanguageSupportType[];
}

export interface LanguageSupportType {
  id: number;
  name: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface MultiplayerModeResult {
  multiplayermodes: MultiplayerMode[];
}

export interface MultiplayerMode {
  id: number;
  campaigncoop: boolean;
  dropin: boolean;
  game?: Game | undefined;
  lancoop: boolean;
  offlinecoop: boolean;
  offlinecoopmax: number;
  offlinemax: number;
  onlinecoop: boolean;
  onlinecoopmax: number;
  onlinemax: number;
  platform?: Platform | undefined;
  splitscreen: boolean;
  splitscreenonline: boolean;
  checksum: string;
}

export interface NetworkTypeResult {
  networktypes: NetworkType[];
}

export interface NetworkType {
  id: number;
  name: string;
  eventNetworks: EventNetwork[];
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface PlatformResult {
  platforms: Platform[];
}

export interface Platform {
  id: number;
  abbreviation: string;
  alternativeName: string;
  /** @deprecated */
  category: PlatformCategoryEnum;
  createdAt?: Timestamp | undefined;
  generation: number;
  name: string;
  platformLogo?: PlatformLogo | undefined;
  platformFamily?: PlatformFamily | undefined;
  slug: string;
  summary: string;
  updatedAt?: Timestamp | undefined;
  url: string;
  versions: PlatformVersion[];
  websites: PlatformWebsite[];
  checksum: string;
  platformType?: PlatformType | undefined;
}

export interface PlatformFamilyResult {
  platformfamilies: PlatformFamily[];
}

export interface PlatformFamily {
  id: number;
  name: string;
  slug: string;
  checksum: string;
}

export interface PlatformLogoResult {
  platformlogos: PlatformLogo[];
}

export interface PlatformLogo {
  id: number;
  alphaChannel: boolean;
  animated: boolean;
  height: number;
  imageId: string;
  url: string;
  width: number;
  checksum: string;
}

export interface PlatformTypeResult {
  platformtypes: PlatformType[];
}

export interface PlatformType {
  id: number;
  name: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface PlatformVersionResult {
  platformversions: PlatformVersion[];
}

export interface PlatformVersion {
  id: number;
  companies: PlatformVersionCompany[];
  connectivity: string;
  cpu: string;
  graphics: string;
  mainManufacturer?: PlatformVersionCompany | undefined;
  media: string;
  memory: string;
  name: string;
  os: string;
  output: string;
  platformLogo?: PlatformLogo | undefined;
  platformVersionReleaseDates: PlatformVersionReleaseDate[];
  resolutions: string;
  slug: string;
  sound: string;
  storage: string;
  summary: string;
  url: string;
  checksum: string;
}

export interface PlatformVersionCompanyResult {
  platformversioncompanies: PlatformVersionCompany[];
}

export interface PlatformVersionCompany {
  id: number;
  comment: string;
  company?: Company | undefined;
  developer: boolean;
  manufacturer: boolean;
  checksum: string;
}

export interface PlatformVersionReleaseDateResult {
  platformversionreleasedates: PlatformVersionReleaseDate[];
}

export interface PlatformVersionReleaseDate {
  id: number;
  /** @deprecated */
  category: DateFormatChangeDateCategoryEnum;
  createdAt?: Timestamp | undefined;
  date?: Timestamp | undefined;
  human: string;
  m: number;
  platformVersion?:
    | PlatformVersion
    | undefined;
  /** @deprecated */
  region: RegionRegionEnum;
  updatedAt?: Timestamp | undefined;
  y: number;
  checksum: string;
  dateFormat?: DateFormat | undefined;
  releaseRegion?: ReleaseDateRegion | undefined;
}

export interface PlatformWebsiteResult {
  platformwebsites: PlatformWebsite[];
}

export interface PlatformWebsite {
  id: number;
  /** @deprecated */
  category: WebsiteCategoryEnum;
  trusted: boolean;
  url: string;
  checksum: string;
  type?: WebsiteType | undefined;
}

export interface PlayerPerspectiveResult {
  playerperspectives: PlayerPerspective[];
}

export interface PlayerPerspective {
  id: number;
  createdAt?: Timestamp | undefined;
  name: string;
  slug: string;
  updatedAt?: Timestamp | undefined;
  url: string;
  checksum: string;
}

export interface PopularityPrimitiveResult {
  popularityprimitives: PopularityPrimitive[];
}

export interface PopularityPrimitive {
  id: number;
  gameId: number;
  popularityType?:
    | PopularityType
    | undefined;
  /** @deprecated */
  popularitySource: PopularitySourcePopularitySourceEnum;
  value: number;
  calculatedAt?: Timestamp | undefined;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
  externalPopularitySource?: ExternalGameSource | undefined;
}

export interface PopularityTypeResult {
  popularitytypes: PopularityType[];
}

export interface PopularityType {
  id: number;
  /** @deprecated */
  popularitySource: PopularitySourcePopularitySourceEnum;
  name: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
  externalPopularitySource?: ExternalGameSource | undefined;
}

export interface RegionResult {
  regions: Region[];
}

export interface Region {
  id: number;
  name: string;
  category: string;
  identifier: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface ReleaseDateResult {
  releasedates: ReleaseDate[];
}

export interface ReleaseDate {
  id: number;
  /** @deprecated */
  category: DateFormatChangeDateCategoryEnum;
  createdAt?: Timestamp | undefined;
  date?: Timestamp | undefined;
  game?: Game | undefined;
  human: string;
  m: number;
  platform?:
    | Platform
    | undefined;
  /** @deprecated */
  region: RegionRegionEnum;
  updatedAt?: Timestamp | undefined;
  y: number;
  checksum: string;
  status?: ReleaseDateStatus | undefined;
  dateFormat?: DateFormat | undefined;
  releaseRegion?: ReleaseDateRegion | undefined;
}

export interface ReleaseDateRegionResult {
  releasedateregions: ReleaseDateRegion[];
}

export interface ReleaseDateRegion {
  id: number;
  region: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface ReleaseDateStatusResult {
  releasedatestatuses: ReleaseDateStatus[];
}

export interface ReleaseDateStatus {
  id: number;
  name: string;
  description: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

export interface ScreenshotResult {
  screenshots: Screenshot[];
}

export interface Screenshot {
  id: number;
  alphaChannel: boolean;
  animated: boolean;
  game?: Game | undefined;
  height: number;
  imageId: string;
  url: string;
  width: number;
  checksum: string;
}

export interface SearchResult {
  searches: Search[];
}

export interface Search {
  id: number;
  alternativeName: string;
  character?: Character | undefined;
  collection?: Collection | undefined;
  company?: Company | undefined;
  description: string;
  game?: Game | undefined;
  name: string;
  platform?: Platform | undefined;
  publishedAt?: Timestamp | undefined;
  testDummy?: TestDummy | undefined;
  theme?: Theme | undefined;
  checksum: string;
}

export interface TestDummyResult {
  testdummies: TestDummy[];
}

export interface TestDummy {
  id: number;
  boolValue: boolean;
  createdAt?: Timestamp | undefined;
  enumTest: TestDummyEnumTestEnum;
  floatValue: number;
  game?: Game | undefined;
  integerArray: number[];
  integerValue: number;
  name: string;
  newIntegerValue: number;
  private: boolean;
  slug: string;
  stringArray: string[];
  testDummies: TestDummy[];
  testDummy?: TestDummy | undefined;
  updatedAt?: Timestamp | undefined;
  url: string;
  checksum: string;
}

export interface ThemeResult {
  themes: Theme[];
}

export interface Theme {
  id: number;
  createdAt?: Timestamp | undefined;
  name: string;
  slug: string;
  updatedAt?: Timestamp | undefined;
  url: string;
  checksum: string;
}

export interface WebsiteResult {
  websites: Website[];
}

export interface Website {
  id: number;
  /** @deprecated */
  category: WebsiteCategoryEnum;
  game?: Game | undefined;
  trusted: boolean;
  url: string;
  checksum: string;
  type?: WebsiteType | undefined;
}

export interface WebsiteTypeResult {
  websitetypes: WebsiteType[];
}

export interface WebsiteType {
  id: number;
  type: string;
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  checksum: string;
}

function createBaseCount(): Count {
  return { count: 0 };
}

export const Count: MessageFns<Count> = {
  encode(message: Count, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.count !== 0) {
      writer.uint32(8).int64(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Count {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.count = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Count {
    return { count: isSet(object.count) ? globalThis.Number(object.count) : 0 };
  },

  toJSON(message: Count): unknown {
    const obj: any = {};
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create(base?: DeepPartial<Count>): Count {
    return Count.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Count>): Count {
    const message = createBaseCount();
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseMultiQueryResult(): MultiQueryResult {
  return { name: "", results: [], count: 0 };
}

export const MultiQueryResult: MessageFns<MultiQueryResult> = {
  encode(message: MultiQueryResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.results) {
      writer.uint32(18).bytes(v!);
    }
    if (message.count !== 0) {
      writer.uint32(24).int64(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiQueryResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiQueryResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.results.push(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiQueryResult {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      results: globalThis.Array.isArray(object?.results) ? object.results.map((e: any) => bytesFromBase64(e)) : [],
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: MultiQueryResult): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => base64FromBytes(e));
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create(base?: DeepPartial<MultiQueryResult>): MultiQueryResult {
    return MultiQueryResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MultiQueryResult>): MultiQueryResult {
    const message = createBaseMultiQueryResult();
    message.name = object.name ?? "";
    message.results = object.results?.map((e) => e) || [];
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseMultiQueryResultArray(): MultiQueryResultArray {
  return { result: [] };
}

export const MultiQueryResultArray: MessageFns<MultiQueryResultArray> = {
  encode(message: MultiQueryResultArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.result) {
      MultiQueryResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiQueryResultArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiQueryResultArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result.push(MultiQueryResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiQueryResultArray {
    return {
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => MultiQueryResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiQueryResultArray): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => MultiQueryResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MultiQueryResultArray>): MultiQueryResultArray {
    return MultiQueryResultArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MultiQueryResultArray>): MultiQueryResultArray {
    const message = createBaseMultiQueryResultArray();
    message.result = object.result?.map((e) => MultiQueryResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAgeRatingResult(): AgeRatingResult {
  return { ageratings: [] };
}

export const AgeRatingResult: MessageFns<AgeRatingResult> = {
  encode(message: AgeRatingResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ageratings) {
      AgeRating.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgeRatingResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgeRatingResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ageratings.push(AgeRating.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgeRatingResult {
    return {
      ageratings: globalThis.Array.isArray(object?.ageratings)
        ? object.ageratings.map((e: any) => AgeRating.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AgeRatingResult): unknown {
    const obj: any = {};
    if (message.ageratings?.length) {
      obj.ageratings = message.ageratings.map((e) => AgeRating.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AgeRatingResult>): AgeRatingResult {
    return AgeRatingResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgeRatingResult>): AgeRatingResult {
    const message = createBaseAgeRatingResult();
    message.ageratings = object.ageratings?.map((e) => AgeRating.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAgeRating(): AgeRating {
  return {
    id: 0,
    category: 0,
    contentDescriptions: [],
    rating: 0,
    ratingCoverUrl: "",
    synopsis: "",
    checksum: "",
    organization: undefined,
    ratingCategory: undefined,
    ratingContentDescriptions: [],
  };
}

export const AgeRating: MessageFns<AgeRating> = {
  encode(message: AgeRating, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.category !== 0) {
      writer.uint32(16).int32(message.category);
    }
    for (const v of message.contentDescriptions) {
      AgeRatingContentDescription.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.rating !== 0) {
      writer.uint32(32).int32(message.rating);
    }
    if (message.ratingCoverUrl !== "") {
      writer.uint32(42).string(message.ratingCoverUrl);
    }
    if (message.synopsis !== "") {
      writer.uint32(50).string(message.synopsis);
    }
    if (message.checksum !== "") {
      writer.uint32(58).string(message.checksum);
    }
    if (message.organization !== undefined) {
      AgeRatingOrganization.encode(message.organization, writer.uint32(66).fork()).join();
    }
    if (message.ratingCategory !== undefined) {
      AgeRatingCategory.encode(message.ratingCategory, writer.uint32(74).fork()).join();
    }
    for (const v of message.ratingContentDescriptions) {
      AgeRatingContentDescriptionV2.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgeRating {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgeRating();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contentDescriptions.push(AgeRatingContentDescription.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rating = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ratingCoverUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.synopsis = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.organization = AgeRatingOrganization.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ratingCategory = AgeRatingCategory.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.ratingContentDescriptions.push(AgeRatingContentDescriptionV2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgeRating {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      category: isSet(object.category) ? ageRatingCategoryEnumFromJSON(object.category) : 0,
      contentDescriptions: globalThis.Array.isArray(object?.contentDescriptions)
        ? object.contentDescriptions.map((e: any) => AgeRatingContentDescription.fromJSON(e))
        : [],
      rating: isSet(object.rating) ? ageRatingRatingEnumFromJSON(object.rating) : 0,
      ratingCoverUrl: isSet(object.ratingCoverUrl) ? globalThis.String(object.ratingCoverUrl) : "",
      synopsis: isSet(object.synopsis) ? globalThis.String(object.synopsis) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      organization: isSet(object.organization) ? AgeRatingOrganization.fromJSON(object.organization) : undefined,
      ratingCategory: isSet(object.ratingCategory) ? AgeRatingCategory.fromJSON(object.ratingCategory) : undefined,
      ratingContentDescriptions: globalThis.Array.isArray(object?.ratingContentDescriptions)
        ? object.ratingContentDescriptions.map((e: any) => AgeRatingContentDescriptionV2.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AgeRating): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.category !== 0) {
      obj.category = ageRatingCategoryEnumToJSON(message.category);
    }
    if (message.contentDescriptions?.length) {
      obj.contentDescriptions = message.contentDescriptions.map((e) => AgeRatingContentDescription.toJSON(e));
    }
    if (message.rating !== 0) {
      obj.rating = ageRatingRatingEnumToJSON(message.rating);
    }
    if (message.ratingCoverUrl !== "") {
      obj.ratingCoverUrl = message.ratingCoverUrl;
    }
    if (message.synopsis !== "") {
      obj.synopsis = message.synopsis;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.organization !== undefined) {
      obj.organization = AgeRatingOrganization.toJSON(message.organization);
    }
    if (message.ratingCategory !== undefined) {
      obj.ratingCategory = AgeRatingCategory.toJSON(message.ratingCategory);
    }
    if (message.ratingContentDescriptions?.length) {
      obj.ratingContentDescriptions = message.ratingContentDescriptions.map((e) =>
        AgeRatingContentDescriptionV2.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<AgeRating>): AgeRating {
    return AgeRating.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgeRating>): AgeRating {
    const message = createBaseAgeRating();
    message.id = object.id ?? 0;
    message.category = object.category ?? 0;
    message.contentDescriptions = object.contentDescriptions?.map((e) => AgeRatingContentDescription.fromPartial(e)) ||
      [];
    message.rating = object.rating ?? 0;
    message.ratingCoverUrl = object.ratingCoverUrl ?? "";
    message.synopsis = object.synopsis ?? "";
    message.checksum = object.checksum ?? "";
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? AgeRatingOrganization.fromPartial(object.organization)
      : undefined;
    message.ratingCategory = (object.ratingCategory !== undefined && object.ratingCategory !== null)
      ? AgeRatingCategory.fromPartial(object.ratingCategory)
      : undefined;
    message.ratingContentDescriptions =
      object.ratingContentDescriptions?.map((e) => AgeRatingContentDescriptionV2.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAgeRatingCategoryResult(): AgeRatingCategoryResult {
  return { ageratingcategories: [] };
}

export const AgeRatingCategoryResult: MessageFns<AgeRatingCategoryResult> = {
  encode(message: AgeRatingCategoryResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ageratingcategories) {
      AgeRatingCategory.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgeRatingCategoryResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgeRatingCategoryResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ageratingcategories.push(AgeRatingCategory.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgeRatingCategoryResult {
    return {
      ageratingcategories: globalThis.Array.isArray(object?.ageratingcategories)
        ? object.ageratingcategories.map((e: any) => AgeRatingCategory.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AgeRatingCategoryResult): unknown {
    const obj: any = {};
    if (message.ageratingcategories?.length) {
      obj.ageratingcategories = message.ageratingcategories.map((e) => AgeRatingCategory.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AgeRatingCategoryResult>): AgeRatingCategoryResult {
    return AgeRatingCategoryResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgeRatingCategoryResult>): AgeRatingCategoryResult {
    const message = createBaseAgeRatingCategoryResult();
    message.ageratingcategories = object.ageratingcategories?.map((e) => AgeRatingCategory.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAgeRatingCategory(): AgeRatingCategory {
  return { id: 0, rating: "", organization: undefined, createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const AgeRatingCategory: MessageFns<AgeRatingCategory> = {
  encode(message: AgeRatingCategory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.rating !== "") {
      writer.uint32(18).string(message.rating);
    }
    if (message.organization !== undefined) {
      AgeRatingOrganization.encode(message.organization, writer.uint32(26).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(34).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(42).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(50).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgeRatingCategory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgeRatingCategory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rating = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.organization = AgeRatingOrganization.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgeRatingCategory {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      rating: isSet(object.rating) ? globalThis.String(object.rating) : "",
      organization: isSet(object.organization) ? AgeRatingOrganization.fromJSON(object.organization) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: AgeRatingCategory): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.rating !== "") {
      obj.rating = message.rating;
    }
    if (message.organization !== undefined) {
      obj.organization = AgeRatingOrganization.toJSON(message.organization);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<AgeRatingCategory>): AgeRatingCategory {
    return AgeRatingCategory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgeRatingCategory>): AgeRatingCategory {
    const message = createBaseAgeRatingCategory();
    message.id = object.id ?? 0;
    message.rating = object.rating ?? "";
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? AgeRatingOrganization.fromPartial(object.organization)
      : undefined;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseAgeRatingContentDescriptionResult(): AgeRatingContentDescriptionResult {
  return { ageratingcontentdescriptions: [] };
}

export const AgeRatingContentDescriptionResult: MessageFns<AgeRatingContentDescriptionResult> = {
  encode(message: AgeRatingContentDescriptionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ageratingcontentdescriptions) {
      AgeRatingContentDescription.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgeRatingContentDescriptionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgeRatingContentDescriptionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ageratingcontentdescriptions.push(AgeRatingContentDescription.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgeRatingContentDescriptionResult {
    return {
      ageratingcontentdescriptions: globalThis.Array.isArray(object?.ageratingcontentdescriptions)
        ? object.ageratingcontentdescriptions.map((e: any) => AgeRatingContentDescription.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AgeRatingContentDescriptionResult): unknown {
    const obj: any = {};
    if (message.ageratingcontentdescriptions?.length) {
      obj.ageratingcontentdescriptions = message.ageratingcontentdescriptions.map((e) =>
        AgeRatingContentDescription.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<AgeRatingContentDescriptionResult>): AgeRatingContentDescriptionResult {
    return AgeRatingContentDescriptionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgeRatingContentDescriptionResult>): AgeRatingContentDescriptionResult {
    const message = createBaseAgeRatingContentDescriptionResult();
    message.ageratingcontentdescriptions =
      object.ageratingcontentdescriptions?.map((e) => AgeRatingContentDescription.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAgeRatingContentDescription(): AgeRatingContentDescription {
  return { id: 0, category: 0, description: "", checksum: "" };
}

export const AgeRatingContentDescription: MessageFns<AgeRatingContentDescription> = {
  encode(message: AgeRatingContentDescription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.category !== 0) {
      writer.uint32(16).int32(message.category);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.checksum !== "") {
      writer.uint32(34).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgeRatingContentDescription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgeRatingContentDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgeRatingContentDescription {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      category: isSet(object.category) ? ageRatingContentDescriptionCategoryEnumFromJSON(object.category) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: AgeRatingContentDescription): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.category !== 0) {
      obj.category = ageRatingContentDescriptionCategoryEnumToJSON(message.category);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<AgeRatingContentDescription>): AgeRatingContentDescription {
    return AgeRatingContentDescription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgeRatingContentDescription>): AgeRatingContentDescription {
    const message = createBaseAgeRatingContentDescription();
    message.id = object.id ?? 0;
    message.category = object.category ?? 0;
    message.description = object.description ?? "";
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseAgeRatingContentDescriptionV2Result(): AgeRatingContentDescriptionV2Result {
  return { ageratingcontentdescriptionsv2: [] };
}

export const AgeRatingContentDescriptionV2Result: MessageFns<AgeRatingContentDescriptionV2Result> = {
  encode(message: AgeRatingContentDescriptionV2Result, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ageratingcontentdescriptionsv2) {
      AgeRatingContentDescriptionV2.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgeRatingContentDescriptionV2Result {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgeRatingContentDescriptionV2Result();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ageratingcontentdescriptionsv2.push(AgeRatingContentDescriptionV2.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgeRatingContentDescriptionV2Result {
    return {
      ageratingcontentdescriptionsv2: globalThis.Array.isArray(object?.ageratingcontentdescriptionsv2)
        ? object.ageratingcontentdescriptionsv2.map((e: any) => AgeRatingContentDescriptionV2.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AgeRatingContentDescriptionV2Result): unknown {
    const obj: any = {};
    if (message.ageratingcontentdescriptionsv2?.length) {
      obj.ageratingcontentdescriptionsv2 = message.ageratingcontentdescriptionsv2.map((e) =>
        AgeRatingContentDescriptionV2.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<AgeRatingContentDescriptionV2Result>): AgeRatingContentDescriptionV2Result {
    return AgeRatingContentDescriptionV2Result.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgeRatingContentDescriptionV2Result>): AgeRatingContentDescriptionV2Result {
    const message = createBaseAgeRatingContentDescriptionV2Result();
    message.ageratingcontentdescriptionsv2 =
      object.ageratingcontentdescriptionsv2?.map((e) => AgeRatingContentDescriptionV2.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAgeRatingContentDescriptionV2(): AgeRatingContentDescriptionV2 {
  return { id: 0, description: "", organization: undefined, createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const AgeRatingContentDescriptionV2: MessageFns<AgeRatingContentDescriptionV2> = {
  encode(message: AgeRatingContentDescriptionV2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.organization !== undefined) {
      AgeRatingOrganization.encode(message.organization, writer.uint32(26).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(34).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(42).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(50).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgeRatingContentDescriptionV2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgeRatingContentDescriptionV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.organization = AgeRatingOrganization.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgeRatingContentDescriptionV2 {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      organization: isSet(object.organization) ? AgeRatingOrganization.fromJSON(object.organization) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: AgeRatingContentDescriptionV2): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.organization !== undefined) {
      obj.organization = AgeRatingOrganization.toJSON(message.organization);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<AgeRatingContentDescriptionV2>): AgeRatingContentDescriptionV2 {
    return AgeRatingContentDescriptionV2.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgeRatingContentDescriptionV2>): AgeRatingContentDescriptionV2 {
    const message = createBaseAgeRatingContentDescriptionV2();
    message.id = object.id ?? 0;
    message.description = object.description ?? "";
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? AgeRatingOrganization.fromPartial(object.organization)
      : undefined;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseAgeRatingOrganizationResult(): AgeRatingOrganizationResult {
  return { ageratingorganizations: [] };
}

export const AgeRatingOrganizationResult: MessageFns<AgeRatingOrganizationResult> = {
  encode(message: AgeRatingOrganizationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ageratingorganizations) {
      AgeRatingOrganization.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgeRatingOrganizationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgeRatingOrganizationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ageratingorganizations.push(AgeRatingOrganization.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgeRatingOrganizationResult {
    return {
      ageratingorganizations: globalThis.Array.isArray(object?.ageratingorganizations)
        ? object.ageratingorganizations.map((e: any) => AgeRatingOrganization.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AgeRatingOrganizationResult): unknown {
    const obj: any = {};
    if (message.ageratingorganizations?.length) {
      obj.ageratingorganizations = message.ageratingorganizations.map((e) => AgeRatingOrganization.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AgeRatingOrganizationResult>): AgeRatingOrganizationResult {
    return AgeRatingOrganizationResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgeRatingOrganizationResult>): AgeRatingOrganizationResult {
    const message = createBaseAgeRatingOrganizationResult();
    message.ageratingorganizations = object.ageratingorganizations?.map((e) => AgeRatingOrganization.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseAgeRatingOrganization(): AgeRatingOrganization {
  return { id: 0, name: "", createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const AgeRatingOrganization: MessageFns<AgeRatingOrganization> = {
  encode(message: AgeRatingOrganization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(34).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(42).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgeRatingOrganization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgeRatingOrganization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgeRatingOrganization {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: AgeRatingOrganization): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<AgeRatingOrganization>): AgeRatingOrganization {
    return AgeRatingOrganization.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgeRatingOrganization>): AgeRatingOrganization {
    const message = createBaseAgeRatingOrganization();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseAlternativeNameResult(): AlternativeNameResult {
  return { alternativenames: [] };
}

export const AlternativeNameResult: MessageFns<AlternativeNameResult> = {
  encode(message: AlternativeNameResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.alternativenames) {
      AlternativeName.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlternativeNameResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlternativeNameResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.alternativenames.push(AlternativeName.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlternativeNameResult {
    return {
      alternativenames: globalThis.Array.isArray(object?.alternativenames)
        ? object.alternativenames.map((e: any) => AlternativeName.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AlternativeNameResult): unknown {
    const obj: any = {};
    if (message.alternativenames?.length) {
      obj.alternativenames = message.alternativenames.map((e) => AlternativeName.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AlternativeNameResult>): AlternativeNameResult {
    return AlternativeNameResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlternativeNameResult>): AlternativeNameResult {
    const message = createBaseAlternativeNameResult();
    message.alternativenames = object.alternativenames?.map((e) => AlternativeName.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAlternativeName(): AlternativeName {
  return { id: 0, comment: "", game: undefined, name: "", checksum: "" };
}

export const AlternativeName: MessageFns<AlternativeName> = {
  encode(message: AlternativeName, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.comment !== "") {
      writer.uint32(18).string(message.comment);
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(26).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.checksum !== "") {
      writer.uint32(42).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlternativeName {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlternativeName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlternativeName {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: AlternativeName): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<AlternativeName>): AlternativeName {
    return AlternativeName.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlternativeName>): AlternativeName {
    const message = createBaseAlternativeName();
    message.id = object.id ?? 0;
    message.comment = object.comment ?? "";
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    message.name = object.name ?? "";
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseArtworkResult(): ArtworkResult {
  return { artworks: [] };
}

export const ArtworkResult: MessageFns<ArtworkResult> = {
  encode(message: ArtworkResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.artworks) {
      Artwork.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArtworkResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtworkResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.artworks.push(Artwork.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArtworkResult {
    return {
      artworks: globalThis.Array.isArray(object?.artworks) ? object.artworks.map((e: any) => Artwork.fromJSON(e)) : [],
    };
  },

  toJSON(message: ArtworkResult): unknown {
    const obj: any = {};
    if (message.artworks?.length) {
      obj.artworks = message.artworks.map((e) => Artwork.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ArtworkResult>): ArtworkResult {
    return ArtworkResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ArtworkResult>): ArtworkResult {
    const message = createBaseArtworkResult();
    message.artworks = object.artworks?.map((e) => Artwork.fromPartial(e)) || [];
    return message;
  },
};

function createBaseArtwork(): Artwork {
  return {
    id: 0,
    alphaChannel: false,
    animated: false,
    game: undefined,
    height: 0,
    imageId: "",
    url: "",
    width: 0,
    checksum: "",
  };
}

export const Artwork: MessageFns<Artwork> = {
  encode(message: Artwork, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.alphaChannel !== false) {
      writer.uint32(16).bool(message.alphaChannel);
    }
    if (message.animated !== false) {
      writer.uint32(24).bool(message.animated);
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(34).fork()).join();
    }
    if (message.height !== 0) {
      writer.uint32(40).int32(message.height);
    }
    if (message.imageId !== "") {
      writer.uint32(50).string(message.imageId);
    }
    if (message.url !== "") {
      writer.uint32(58).string(message.url);
    }
    if (message.width !== 0) {
      writer.uint32(64).int32(message.width);
    }
    if (message.checksum !== "") {
      writer.uint32(74).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Artwork {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtwork();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.alphaChannel = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.animated = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.imageId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Artwork {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      alphaChannel: isSet(object.alphaChannel) ? globalThis.Boolean(object.alphaChannel) : false,
      animated: isSet(object.animated) ? globalThis.Boolean(object.animated) : false,
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      imageId: isSet(object.imageId) ? globalThis.String(object.imageId) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: Artwork): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.alphaChannel !== false) {
      obj.alphaChannel = message.alphaChannel;
    }
    if (message.animated !== false) {
      obj.animated = message.animated;
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<Artwork>): Artwork {
    return Artwork.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Artwork>): Artwork {
    const message = createBaseArtwork();
    message.id = object.id ?? 0;
    message.alphaChannel = object.alphaChannel ?? false;
    message.animated = object.animated ?? false;
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    message.height = object.height ?? 0;
    message.imageId = object.imageId ?? "";
    message.url = object.url ?? "";
    message.width = object.width ?? 0;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseCharacterResult(): CharacterResult {
  return { characters: [] };
}

export const CharacterResult: MessageFns<CharacterResult> = {
  encode(message: CharacterResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.characters) {
      Character.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characters.push(Character.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterResult {
    return {
      characters: globalThis.Array.isArray(object?.characters)
        ? object.characters.map((e: any) => Character.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CharacterResult): unknown {
    const obj: any = {};
    if (message.characters?.length) {
      obj.characters = message.characters.map((e) => Character.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CharacterResult>): CharacterResult {
    return CharacterResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CharacterResult>): CharacterResult {
    const message = createBaseCharacterResult();
    message.characters = object.characters?.map((e) => Character.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCharacter(): Character {
  return {
    id: 0,
    akas: [],
    countryName: "",
    createdAt: undefined,
    description: "",
    games: [],
    gender: 0,
    mugShot: undefined,
    name: "",
    slug: "",
    species: 0,
    updatedAt: undefined,
    url: "",
    checksum: "",
    characterGender: undefined,
    characterSpecies: undefined,
  };
}

export const Character: MessageFns<Character> = {
  encode(message: Character, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    for (const v of message.akas) {
      writer.uint32(18).string(v!);
    }
    if (message.countryName !== "") {
      writer.uint32(26).string(message.countryName);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(34).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    for (const v of message.games) {
      Game.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.gender !== 0) {
      writer.uint32(56).int32(message.gender);
    }
    if (message.mugShot !== undefined) {
      CharacterMugShot.encode(message.mugShot, writer.uint32(66).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(74).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(82).string(message.slug);
    }
    if (message.species !== 0) {
      writer.uint32(88).int32(message.species);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(98).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(106).string(message.url);
    }
    if (message.checksum !== "") {
      writer.uint32(114).string(message.checksum);
    }
    if (message.characterGender !== undefined) {
      CharacterGender.encode(message.characterGender, writer.uint32(122).fork()).join();
    }
    if (message.characterSpecies !== undefined) {
      CharacterSpecie.encode(message.characterSpecies, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Character {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.akas.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.countryName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.games.push(Game.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.gender = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.mugShot = CharacterMugShot.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.species = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.characterGender = CharacterGender.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.characterSpecies = CharacterSpecie.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Character {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      akas: globalThis.Array.isArray(object?.akas) ? object.akas.map((e: any) => globalThis.String(e)) : [],
      countryName: isSet(object.countryName) ? globalThis.String(object.countryName) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      games: globalThis.Array.isArray(object?.games) ? object.games.map((e: any) => Game.fromJSON(e)) : [],
      gender: isSet(object.gender) ? genderGenderEnumFromJSON(object.gender) : 0,
      mugShot: isSet(object.mugShot) ? CharacterMugShot.fromJSON(object.mugShot) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      species: isSet(object.species) ? characterSpeciesEnumFromJSON(object.species) : 0,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      characterGender: isSet(object.characterGender) ? CharacterGender.fromJSON(object.characterGender) : undefined,
      characterSpecies: isSet(object.characterSpecies) ? CharacterSpecie.fromJSON(object.characterSpecies) : undefined,
    };
  },

  toJSON(message: Character): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.akas?.length) {
      obj.akas = message.akas;
    }
    if (message.countryName !== "") {
      obj.countryName = message.countryName;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.games?.length) {
      obj.games = message.games.map((e) => Game.toJSON(e));
    }
    if (message.gender !== 0) {
      obj.gender = genderGenderEnumToJSON(message.gender);
    }
    if (message.mugShot !== undefined) {
      obj.mugShot = CharacterMugShot.toJSON(message.mugShot);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.species !== 0) {
      obj.species = characterSpeciesEnumToJSON(message.species);
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.characterGender !== undefined) {
      obj.characterGender = CharacterGender.toJSON(message.characterGender);
    }
    if (message.characterSpecies !== undefined) {
      obj.characterSpecies = CharacterSpecie.toJSON(message.characterSpecies);
    }
    return obj;
  },

  create(base?: DeepPartial<Character>): Character {
    return Character.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Character>): Character {
    const message = createBaseCharacter();
    message.id = object.id ?? 0;
    message.akas = object.akas?.map((e) => e) || [];
    message.countryName = object.countryName ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.description = object.description ?? "";
    message.games = object.games?.map((e) => Game.fromPartial(e)) || [];
    message.gender = object.gender ?? 0;
    message.mugShot = (object.mugShot !== undefined && object.mugShot !== null)
      ? CharacterMugShot.fromPartial(object.mugShot)
      : undefined;
    message.name = object.name ?? "";
    message.slug = object.slug ?? "";
    message.species = object.species ?? 0;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.url = object.url ?? "";
    message.checksum = object.checksum ?? "";
    message.characterGender = (object.characterGender !== undefined && object.characterGender !== null)
      ? CharacterGender.fromPartial(object.characterGender)
      : undefined;
    message.characterSpecies = (object.characterSpecies !== undefined && object.characterSpecies !== null)
      ? CharacterSpecie.fromPartial(object.characterSpecies)
      : undefined;
    return message;
  },
};

function createBaseCharacterGenderResult(): CharacterGenderResult {
  return { charactergenders: [] };
}

export const CharacterGenderResult: MessageFns<CharacterGenderResult> = {
  encode(message: CharacterGenderResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.charactergenders) {
      CharacterGender.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterGenderResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterGenderResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.charactergenders.push(CharacterGender.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterGenderResult {
    return {
      charactergenders: globalThis.Array.isArray(object?.charactergenders)
        ? object.charactergenders.map((e: any) => CharacterGender.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CharacterGenderResult): unknown {
    const obj: any = {};
    if (message.charactergenders?.length) {
      obj.charactergenders = message.charactergenders.map((e) => CharacterGender.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CharacterGenderResult>): CharacterGenderResult {
    return CharacterGenderResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CharacterGenderResult>): CharacterGenderResult {
    const message = createBaseCharacterGenderResult();
    message.charactergenders = object.charactergenders?.map((e) => CharacterGender.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCharacterGender(): CharacterGender {
  return { id: 0, name: "", createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const CharacterGender: MessageFns<CharacterGender> = {
  encode(message: CharacterGender, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(34).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(42).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterGender {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterGender();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterGender {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: CharacterGender): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<CharacterGender>): CharacterGender {
    return CharacterGender.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CharacterGender>): CharacterGender {
    const message = createBaseCharacterGender();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseCharacterMugShotResult(): CharacterMugShotResult {
  return { charactermugshots: [] };
}

export const CharacterMugShotResult: MessageFns<CharacterMugShotResult> = {
  encode(message: CharacterMugShotResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.charactermugshots) {
      CharacterMugShot.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterMugShotResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterMugShotResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.charactermugshots.push(CharacterMugShot.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterMugShotResult {
    return {
      charactermugshots: globalThis.Array.isArray(object?.charactermugshots)
        ? object.charactermugshots.map((e: any) => CharacterMugShot.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CharacterMugShotResult): unknown {
    const obj: any = {};
    if (message.charactermugshots?.length) {
      obj.charactermugshots = message.charactermugshots.map((e) => CharacterMugShot.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CharacterMugShotResult>): CharacterMugShotResult {
    return CharacterMugShotResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CharacterMugShotResult>): CharacterMugShotResult {
    const message = createBaseCharacterMugShotResult();
    message.charactermugshots = object.charactermugshots?.map((e) => CharacterMugShot.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCharacterMugShot(): CharacterMugShot {
  return { id: 0, alphaChannel: false, animated: false, height: 0, imageId: "", url: "", width: 0, checksum: "" };
}

export const CharacterMugShot: MessageFns<CharacterMugShot> = {
  encode(message: CharacterMugShot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.alphaChannel !== false) {
      writer.uint32(16).bool(message.alphaChannel);
    }
    if (message.animated !== false) {
      writer.uint32(24).bool(message.animated);
    }
    if (message.height !== 0) {
      writer.uint32(32).int32(message.height);
    }
    if (message.imageId !== "") {
      writer.uint32(42).string(message.imageId);
    }
    if (message.url !== "") {
      writer.uint32(50).string(message.url);
    }
    if (message.width !== 0) {
      writer.uint32(56).int32(message.width);
    }
    if (message.checksum !== "") {
      writer.uint32(66).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterMugShot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterMugShot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.alphaChannel = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.animated = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.imageId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterMugShot {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      alphaChannel: isSet(object.alphaChannel) ? globalThis.Boolean(object.alphaChannel) : false,
      animated: isSet(object.animated) ? globalThis.Boolean(object.animated) : false,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      imageId: isSet(object.imageId) ? globalThis.String(object.imageId) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: CharacterMugShot): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.alphaChannel !== false) {
      obj.alphaChannel = message.alphaChannel;
    }
    if (message.animated !== false) {
      obj.animated = message.animated;
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<CharacterMugShot>): CharacterMugShot {
    return CharacterMugShot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CharacterMugShot>): CharacterMugShot {
    const message = createBaseCharacterMugShot();
    message.id = object.id ?? 0;
    message.alphaChannel = object.alphaChannel ?? false;
    message.animated = object.animated ?? false;
    message.height = object.height ?? 0;
    message.imageId = object.imageId ?? "";
    message.url = object.url ?? "";
    message.width = object.width ?? 0;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseCharacterSpecieResult(): CharacterSpecieResult {
  return { characterspecies: [] };
}

export const CharacterSpecieResult: MessageFns<CharacterSpecieResult> = {
  encode(message: CharacterSpecieResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.characterspecies) {
      CharacterSpecie.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterSpecieResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterSpecieResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characterspecies.push(CharacterSpecie.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterSpecieResult {
    return {
      characterspecies: globalThis.Array.isArray(object?.characterspecies)
        ? object.characterspecies.map((e: any) => CharacterSpecie.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CharacterSpecieResult): unknown {
    const obj: any = {};
    if (message.characterspecies?.length) {
      obj.characterspecies = message.characterspecies.map((e) => CharacterSpecie.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CharacterSpecieResult>): CharacterSpecieResult {
    return CharacterSpecieResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CharacterSpecieResult>): CharacterSpecieResult {
    const message = createBaseCharacterSpecieResult();
    message.characterspecies = object.characterspecies?.map((e) => CharacterSpecie.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCharacterSpecie(): CharacterSpecie {
  return { id: 0, name: "", createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const CharacterSpecie: MessageFns<CharacterSpecie> = {
  encode(message: CharacterSpecie, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(34).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(42).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterSpecie {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterSpecie();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterSpecie {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: CharacterSpecie): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<CharacterSpecie>): CharacterSpecie {
    return CharacterSpecie.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CharacterSpecie>): CharacterSpecie {
    const message = createBaseCharacterSpecie();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseCollectionResult(): CollectionResult {
  return { collections: [] };
}

export const CollectionResult: MessageFns<CollectionResult> = {
  encode(message: CollectionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.collections) {
      Collection.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CollectionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollectionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collections.push(Collection.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CollectionResult {
    return {
      collections: globalThis.Array.isArray(object?.collections)
        ? object.collections.map((e: any) => Collection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CollectionResult): unknown {
    const obj: any = {};
    if (message.collections?.length) {
      obj.collections = message.collections.map((e) => Collection.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CollectionResult>): CollectionResult {
    return CollectionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CollectionResult>): CollectionResult {
    const message = createBaseCollectionResult();
    message.collections = object.collections?.map((e) => Collection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCollection(): Collection {
  return {
    id: 0,
    createdAt: undefined,
    games: [],
    name: "",
    slug: "",
    updatedAt: undefined,
    url: "",
    checksum: "",
    type: undefined,
    asParentRelations: [],
    asChildRelations: [],
  };
}

export const Collection: MessageFns<Collection> = {
  encode(message: Collection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(18).fork()).join();
    }
    for (const v of message.games) {
      Game.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(42).string(message.slug);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(50).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(58).string(message.url);
    }
    if (message.checksum !== "") {
      writer.uint32(66).string(message.checksum);
    }
    if (message.type !== undefined) {
      CollectionType.encode(message.type, writer.uint32(74).fork()).join();
    }
    for (const v of message.asParentRelations) {
      CollectionRelation.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.asChildRelations) {
      CollectionRelation.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Collection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.games.push(Game.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.type = CollectionType.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.asParentRelations.push(CollectionRelation.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.asChildRelations.push(CollectionRelation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Collection {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      games: globalThis.Array.isArray(object?.games) ? object.games.map((e: any) => Game.fromJSON(e)) : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      type: isSet(object.type) ? CollectionType.fromJSON(object.type) : undefined,
      asParentRelations: globalThis.Array.isArray(object?.asParentRelations)
        ? object.asParentRelations.map((e: any) => CollectionRelation.fromJSON(e))
        : [],
      asChildRelations: globalThis.Array.isArray(object?.asChildRelations)
        ? object.asChildRelations.map((e: any) => CollectionRelation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Collection): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.games?.length) {
      obj.games = message.games.map((e) => Game.toJSON(e));
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.type !== undefined) {
      obj.type = CollectionType.toJSON(message.type);
    }
    if (message.asParentRelations?.length) {
      obj.asParentRelations = message.asParentRelations.map((e) => CollectionRelation.toJSON(e));
    }
    if (message.asChildRelations?.length) {
      obj.asChildRelations = message.asChildRelations.map((e) => CollectionRelation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Collection>): Collection {
    return Collection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Collection>): Collection {
    const message = createBaseCollection();
    message.id = object.id ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.games = object.games?.map((e) => Game.fromPartial(e)) || [];
    message.name = object.name ?? "";
    message.slug = object.slug ?? "";
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.url = object.url ?? "";
    message.checksum = object.checksum ?? "";
    message.type = (object.type !== undefined && object.type !== null)
      ? CollectionType.fromPartial(object.type)
      : undefined;
    message.asParentRelations = object.asParentRelations?.map((e) => CollectionRelation.fromPartial(e)) || [];
    message.asChildRelations = object.asChildRelations?.map((e) => CollectionRelation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCollectionMembershipResult(): CollectionMembershipResult {
  return { collectionmemberships: [] };
}

export const CollectionMembershipResult: MessageFns<CollectionMembershipResult> = {
  encode(message: CollectionMembershipResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.collectionmemberships) {
      CollectionMembership.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CollectionMembershipResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollectionMembershipResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collectionmemberships.push(CollectionMembership.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CollectionMembershipResult {
    return {
      collectionmemberships: globalThis.Array.isArray(object?.collectionmemberships)
        ? object.collectionmemberships.map((e: any) => CollectionMembership.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CollectionMembershipResult): unknown {
    const obj: any = {};
    if (message.collectionmemberships?.length) {
      obj.collectionmemberships = message.collectionmemberships.map((e) => CollectionMembership.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CollectionMembershipResult>): CollectionMembershipResult {
    return CollectionMembershipResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CollectionMembershipResult>): CollectionMembershipResult {
    const message = createBaseCollectionMembershipResult();
    message.collectionmemberships = object.collectionmemberships?.map((e) => CollectionMembership.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCollectionMembership(): CollectionMembership {
  return {
    id: 0,
    game: undefined,
    collection: undefined,
    type: undefined,
    updatedAt: undefined,
    createdAt: undefined,
    checksum: "",
  };
}

export const CollectionMembership: MessageFns<CollectionMembership> = {
  encode(message: CollectionMembership, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(18).fork()).join();
    }
    if (message.collection !== undefined) {
      Collection.encode(message.collection, writer.uint32(26).fork()).join();
    }
    if (message.type !== undefined) {
      CollectionMembershipType.encode(message.type, writer.uint32(34).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(42).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(50).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(58).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CollectionMembership {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollectionMembership();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.collection = Collection.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = CollectionMembershipType.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CollectionMembership {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
      collection: isSet(object.collection) ? Collection.fromJSON(object.collection) : undefined,
      type: isSet(object.type) ? CollectionMembershipType.fromJSON(object.type) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: CollectionMembership): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    if (message.collection !== undefined) {
      obj.collection = Collection.toJSON(message.collection);
    }
    if (message.type !== undefined) {
      obj.type = CollectionMembershipType.toJSON(message.type);
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<CollectionMembership>): CollectionMembership {
    return CollectionMembership.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CollectionMembership>): CollectionMembership {
    const message = createBaseCollectionMembership();
    message.id = object.id ?? 0;
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    message.collection = (object.collection !== undefined && object.collection !== null)
      ? Collection.fromPartial(object.collection)
      : undefined;
    message.type = (object.type !== undefined && object.type !== null)
      ? CollectionMembershipType.fromPartial(object.type)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseCollectionMembershipTypeResult(): CollectionMembershipTypeResult {
  return { collectionmembershiptypes: [] };
}

export const CollectionMembershipTypeResult: MessageFns<CollectionMembershipTypeResult> = {
  encode(message: CollectionMembershipTypeResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.collectionmembershiptypes) {
      CollectionMembershipType.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CollectionMembershipTypeResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollectionMembershipTypeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collectionmembershiptypes.push(CollectionMembershipType.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CollectionMembershipTypeResult {
    return {
      collectionmembershiptypes: globalThis.Array.isArray(object?.collectionmembershiptypes)
        ? object.collectionmembershiptypes.map((e: any) => CollectionMembershipType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CollectionMembershipTypeResult): unknown {
    const obj: any = {};
    if (message.collectionmembershiptypes?.length) {
      obj.collectionmembershiptypes = message.collectionmembershiptypes.map((e) => CollectionMembershipType.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CollectionMembershipTypeResult>): CollectionMembershipTypeResult {
    return CollectionMembershipTypeResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CollectionMembershipTypeResult>): CollectionMembershipTypeResult {
    const message = createBaseCollectionMembershipTypeResult();
    message.collectionmembershiptypes =
      object.collectionmembershiptypes?.map((e) => CollectionMembershipType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCollectionMembershipType(): CollectionMembershipType {
  return {
    id: 0,
    name: "",
    description: "",
    allowedCollectionType: undefined,
    updatedAt: undefined,
    createdAt: undefined,
    checksum: "",
  };
}

export const CollectionMembershipType: MessageFns<CollectionMembershipType> = {
  encode(message: CollectionMembershipType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.allowedCollectionType !== undefined) {
      CollectionType.encode(message.allowedCollectionType, writer.uint32(34).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(42).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(50).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(58).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CollectionMembershipType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollectionMembershipType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.allowedCollectionType = CollectionType.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CollectionMembershipType {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      allowedCollectionType: isSet(object.allowedCollectionType)
        ? CollectionType.fromJSON(object.allowedCollectionType)
        : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: CollectionMembershipType): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.allowedCollectionType !== undefined) {
      obj.allowedCollectionType = CollectionType.toJSON(message.allowedCollectionType);
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<CollectionMembershipType>): CollectionMembershipType {
    return CollectionMembershipType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CollectionMembershipType>): CollectionMembershipType {
    const message = createBaseCollectionMembershipType();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.allowedCollectionType =
      (object.allowedCollectionType !== undefined && object.allowedCollectionType !== null)
        ? CollectionType.fromPartial(object.allowedCollectionType)
        : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseCollectionRelationResult(): CollectionRelationResult {
  return { collectionrelations: [] };
}

export const CollectionRelationResult: MessageFns<CollectionRelationResult> = {
  encode(message: CollectionRelationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.collectionrelations) {
      CollectionRelation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CollectionRelationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollectionRelationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collectionrelations.push(CollectionRelation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CollectionRelationResult {
    return {
      collectionrelations: globalThis.Array.isArray(object?.collectionrelations)
        ? object.collectionrelations.map((e: any) => CollectionRelation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CollectionRelationResult): unknown {
    const obj: any = {};
    if (message.collectionrelations?.length) {
      obj.collectionrelations = message.collectionrelations.map((e) => CollectionRelation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CollectionRelationResult>): CollectionRelationResult {
    return CollectionRelationResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CollectionRelationResult>): CollectionRelationResult {
    const message = createBaseCollectionRelationResult();
    message.collectionrelations = object.collectionrelations?.map((e) => CollectionRelation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCollectionRelation(): CollectionRelation {
  return {
    id: 0,
    childCollection: undefined,
    parentCollection: undefined,
    type: undefined,
    updatedAt: undefined,
    createdAt: undefined,
    checksum: "",
  };
}

export const CollectionRelation: MessageFns<CollectionRelation> = {
  encode(message: CollectionRelation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.childCollection !== undefined) {
      Collection.encode(message.childCollection, writer.uint32(18).fork()).join();
    }
    if (message.parentCollection !== undefined) {
      Collection.encode(message.parentCollection, writer.uint32(26).fork()).join();
    }
    if (message.type !== undefined) {
      CollectionRelationType.encode(message.type, writer.uint32(34).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(42).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(50).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(58).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CollectionRelation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollectionRelation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.childCollection = Collection.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parentCollection = Collection.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = CollectionRelationType.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CollectionRelation {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      childCollection: isSet(object.childCollection) ? Collection.fromJSON(object.childCollection) : undefined,
      parentCollection: isSet(object.parentCollection) ? Collection.fromJSON(object.parentCollection) : undefined,
      type: isSet(object.type) ? CollectionRelationType.fromJSON(object.type) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: CollectionRelation): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.childCollection !== undefined) {
      obj.childCollection = Collection.toJSON(message.childCollection);
    }
    if (message.parentCollection !== undefined) {
      obj.parentCollection = Collection.toJSON(message.parentCollection);
    }
    if (message.type !== undefined) {
      obj.type = CollectionRelationType.toJSON(message.type);
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<CollectionRelation>): CollectionRelation {
    return CollectionRelation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CollectionRelation>): CollectionRelation {
    const message = createBaseCollectionRelation();
    message.id = object.id ?? 0;
    message.childCollection = (object.childCollection !== undefined && object.childCollection !== null)
      ? Collection.fromPartial(object.childCollection)
      : undefined;
    message.parentCollection = (object.parentCollection !== undefined && object.parentCollection !== null)
      ? Collection.fromPartial(object.parentCollection)
      : undefined;
    message.type = (object.type !== undefined && object.type !== null)
      ? CollectionRelationType.fromPartial(object.type)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseCollectionRelationTypeResult(): CollectionRelationTypeResult {
  return { collectionrelationtypes: [] };
}

export const CollectionRelationTypeResult: MessageFns<CollectionRelationTypeResult> = {
  encode(message: CollectionRelationTypeResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.collectionrelationtypes) {
      CollectionRelationType.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CollectionRelationTypeResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollectionRelationTypeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collectionrelationtypes.push(CollectionRelationType.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CollectionRelationTypeResult {
    return {
      collectionrelationtypes: globalThis.Array.isArray(object?.collectionrelationtypes)
        ? object.collectionrelationtypes.map((e: any) => CollectionRelationType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CollectionRelationTypeResult): unknown {
    const obj: any = {};
    if (message.collectionrelationtypes?.length) {
      obj.collectionrelationtypes = message.collectionrelationtypes.map((e) => CollectionRelationType.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CollectionRelationTypeResult>): CollectionRelationTypeResult {
    return CollectionRelationTypeResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CollectionRelationTypeResult>): CollectionRelationTypeResult {
    const message = createBaseCollectionRelationTypeResult();
    message.collectionrelationtypes =
      object.collectionrelationtypes?.map((e) => CollectionRelationType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCollectionRelationType(): CollectionRelationType {
  return {
    id: 0,
    name: "",
    description: "",
    allowedChildType: undefined,
    allowedParentType: undefined,
    updatedAt: undefined,
    createdAt: undefined,
    checksum: "",
  };
}

export const CollectionRelationType: MessageFns<CollectionRelationType> = {
  encode(message: CollectionRelationType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.allowedChildType !== undefined) {
      CollectionType.encode(message.allowedChildType, writer.uint32(34).fork()).join();
    }
    if (message.allowedParentType !== undefined) {
      CollectionType.encode(message.allowedParentType, writer.uint32(42).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(50).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(58).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(66).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CollectionRelationType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollectionRelationType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.allowedChildType = CollectionType.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.allowedParentType = CollectionType.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CollectionRelationType {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      allowedChildType: isSet(object.allowedChildType) ? CollectionType.fromJSON(object.allowedChildType) : undefined,
      allowedParentType: isSet(object.allowedParentType)
        ? CollectionType.fromJSON(object.allowedParentType)
        : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: CollectionRelationType): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.allowedChildType !== undefined) {
      obj.allowedChildType = CollectionType.toJSON(message.allowedChildType);
    }
    if (message.allowedParentType !== undefined) {
      obj.allowedParentType = CollectionType.toJSON(message.allowedParentType);
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<CollectionRelationType>): CollectionRelationType {
    return CollectionRelationType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CollectionRelationType>): CollectionRelationType {
    const message = createBaseCollectionRelationType();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.allowedChildType = (object.allowedChildType !== undefined && object.allowedChildType !== null)
      ? CollectionType.fromPartial(object.allowedChildType)
      : undefined;
    message.allowedParentType = (object.allowedParentType !== undefined && object.allowedParentType !== null)
      ? CollectionType.fromPartial(object.allowedParentType)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseCollectionTypeResult(): CollectionTypeResult {
  return { collectiontypes: [] };
}

export const CollectionTypeResult: MessageFns<CollectionTypeResult> = {
  encode(message: CollectionTypeResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.collectiontypes) {
      CollectionType.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CollectionTypeResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollectionTypeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collectiontypes.push(CollectionType.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CollectionTypeResult {
    return {
      collectiontypes: globalThis.Array.isArray(object?.collectiontypes)
        ? object.collectiontypes.map((e: any) => CollectionType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CollectionTypeResult): unknown {
    const obj: any = {};
    if (message.collectiontypes?.length) {
      obj.collectiontypes = message.collectiontypes.map((e) => CollectionType.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CollectionTypeResult>): CollectionTypeResult {
    return CollectionTypeResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CollectionTypeResult>): CollectionTypeResult {
    const message = createBaseCollectionTypeResult();
    message.collectiontypes = object.collectiontypes?.map((e) => CollectionType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCollectionType(): CollectionType {
  return { id: 0, name: "", description: "", updatedAt: undefined, createdAt: undefined, checksum: "" };
}

export const CollectionType: MessageFns<CollectionType> = {
  encode(message: CollectionType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(34).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(42).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(50).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CollectionType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollectionType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CollectionType {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: CollectionType): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<CollectionType>): CollectionType {
    return CollectionType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CollectionType>): CollectionType {
    const message = createBaseCollectionType();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseCompanyResult(): CompanyResult {
  return { companies: [] };
}

export const CompanyResult: MessageFns<CompanyResult> = {
  encode(message: CompanyResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.companies) {
      Company.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompanyResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompanyResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.companies.push(Company.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompanyResult {
    return {
      companies: globalThis.Array.isArray(object?.companies)
        ? object.companies.map((e: any) => Company.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CompanyResult): unknown {
    const obj: any = {};
    if (message.companies?.length) {
      obj.companies = message.companies.map((e) => Company.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CompanyResult>): CompanyResult {
    return CompanyResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompanyResult>): CompanyResult {
    const message = createBaseCompanyResult();
    message.companies = object.companies?.map((e) => Company.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCompany(): Company {
  return {
    id: 0,
    changeDate: undefined,
    changeDateCategory: 0,
    changedCompanyId: undefined,
    country: 0,
    createdAt: undefined,
    description: "",
    developed: [],
    logo: undefined,
    name: "",
    parent: undefined,
    published: [],
    slug: "",
    startDate: undefined,
    startDateCategory: 0,
    updatedAt: undefined,
    url: "",
    websites: [],
    checksum: "",
    status: undefined,
    startDateFormat: undefined,
    changeDateFormat: undefined,
  };
}

export const Company: MessageFns<Company> = {
  encode(message: Company, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.changeDate !== undefined) {
      Timestamp.encode(message.changeDate, writer.uint32(18).fork()).join();
    }
    if (message.changeDateCategory !== 0) {
      writer.uint32(24).int32(message.changeDateCategory);
    }
    if (message.changedCompanyId !== undefined) {
      Company.encode(message.changedCompanyId, writer.uint32(34).fork()).join();
    }
    if (message.country !== 0) {
      writer.uint32(40).int32(message.country);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(50).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(58).string(message.description);
    }
    for (const v of message.developed) {
      Game.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.logo !== undefined) {
      CompanyLogo.encode(message.logo, writer.uint32(74).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(82).string(message.name);
    }
    if (message.parent !== undefined) {
      Company.encode(message.parent, writer.uint32(90).fork()).join();
    }
    for (const v of message.published) {
      Game.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.slug !== "") {
      writer.uint32(106).string(message.slug);
    }
    if (message.startDate !== undefined) {
      Timestamp.encode(message.startDate, writer.uint32(114).fork()).join();
    }
    if (message.startDateCategory !== 0) {
      writer.uint32(120).int32(message.startDateCategory);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(130).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(138).string(message.url);
    }
    for (const v of message.websites) {
      CompanyWebsite.encode(v!, writer.uint32(146).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(154).string(message.checksum);
    }
    if (message.status !== undefined) {
      CompanyStatus.encode(message.status, writer.uint32(162).fork()).join();
    }
    if (message.startDateFormat !== undefined) {
      DateFormat.encode(message.startDateFormat, writer.uint32(170).fork()).join();
    }
    if (message.changeDateFormat !== undefined) {
      DateFormat.encode(message.changeDateFormat, writer.uint32(178).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Company {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompany();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.changeDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.changeDateCategory = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.changedCompanyId = Company.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.country = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.developed.push(Game.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.logo = CompanyLogo.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.parent = Company.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.published.push(Game.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.startDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.startDateCategory = reader.int32() as any;
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.websites.push(CompanyWebsite.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.status = CompanyStatus.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.startDateFormat = DateFormat.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.changeDateFormat = DateFormat.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Company {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      changeDate: isSet(object.changeDate) ? fromJsonTimestamp(object.changeDate) : undefined,
      changeDateCategory: isSet(object.changeDateCategory)
        ? dateFormatChangeDateCategoryEnumFromJSON(object.changeDateCategory)
        : 0,
      changedCompanyId: isSet(object.changedCompanyId) ? Company.fromJSON(object.changedCompanyId) : undefined,
      country: isSet(object.country) ? globalThis.Number(object.country) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      developed: globalThis.Array.isArray(object?.developed) ? object.developed.map((e: any) => Game.fromJSON(e)) : [],
      logo: isSet(object.logo) ? CompanyLogo.fromJSON(object.logo) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parent: isSet(object.parent) ? Company.fromJSON(object.parent) : undefined,
      published: globalThis.Array.isArray(object?.published) ? object.published.map((e: any) => Game.fromJSON(e)) : [],
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      startDate: isSet(object.startDate) ? fromJsonTimestamp(object.startDate) : undefined,
      startDateCategory: isSet(object.startDateCategory)
        ? dateFormatChangeDateCategoryEnumFromJSON(object.startDateCategory)
        : 0,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      websites: globalThis.Array.isArray(object?.websites)
        ? object.websites.map((e: any) => CompanyWebsite.fromJSON(e))
        : [],
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      status: isSet(object.status) ? CompanyStatus.fromJSON(object.status) : undefined,
      startDateFormat: isSet(object.startDateFormat) ? DateFormat.fromJSON(object.startDateFormat) : undefined,
      changeDateFormat: isSet(object.changeDateFormat) ? DateFormat.fromJSON(object.changeDateFormat) : undefined,
    };
  },

  toJSON(message: Company): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.changeDate !== undefined) {
      obj.changeDate = fromTimestamp(message.changeDate).toISOString();
    }
    if (message.changeDateCategory !== 0) {
      obj.changeDateCategory = dateFormatChangeDateCategoryEnumToJSON(message.changeDateCategory);
    }
    if (message.changedCompanyId !== undefined) {
      obj.changedCompanyId = Company.toJSON(message.changedCompanyId);
    }
    if (message.country !== 0) {
      obj.country = Math.round(message.country);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.developed?.length) {
      obj.developed = message.developed.map((e) => Game.toJSON(e));
    }
    if (message.logo !== undefined) {
      obj.logo = CompanyLogo.toJSON(message.logo);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parent !== undefined) {
      obj.parent = Company.toJSON(message.parent);
    }
    if (message.published?.length) {
      obj.published = message.published.map((e) => Game.toJSON(e));
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.startDate !== undefined) {
      obj.startDate = fromTimestamp(message.startDate).toISOString();
    }
    if (message.startDateCategory !== 0) {
      obj.startDateCategory = dateFormatChangeDateCategoryEnumToJSON(message.startDateCategory);
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.websites?.length) {
      obj.websites = message.websites.map((e) => CompanyWebsite.toJSON(e));
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.status !== undefined) {
      obj.status = CompanyStatus.toJSON(message.status);
    }
    if (message.startDateFormat !== undefined) {
      obj.startDateFormat = DateFormat.toJSON(message.startDateFormat);
    }
    if (message.changeDateFormat !== undefined) {
      obj.changeDateFormat = DateFormat.toJSON(message.changeDateFormat);
    }
    return obj;
  },

  create(base?: DeepPartial<Company>): Company {
    return Company.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Company>): Company {
    const message = createBaseCompany();
    message.id = object.id ?? 0;
    message.changeDate = (object.changeDate !== undefined && object.changeDate !== null)
      ? Timestamp.fromPartial(object.changeDate)
      : undefined;
    message.changeDateCategory = object.changeDateCategory ?? 0;
    message.changedCompanyId = (object.changedCompanyId !== undefined && object.changedCompanyId !== null)
      ? Company.fromPartial(object.changedCompanyId)
      : undefined;
    message.country = object.country ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.description = object.description ?? "";
    message.developed = object.developed?.map((e) => Game.fromPartial(e)) || [];
    message.logo = (object.logo !== undefined && object.logo !== null)
      ? CompanyLogo.fromPartial(object.logo)
      : undefined;
    message.name = object.name ?? "";
    message.parent = (object.parent !== undefined && object.parent !== null)
      ? Company.fromPartial(object.parent)
      : undefined;
    message.published = object.published?.map((e) => Game.fromPartial(e)) || [];
    message.slug = object.slug ?? "";
    message.startDate = (object.startDate !== undefined && object.startDate !== null)
      ? Timestamp.fromPartial(object.startDate)
      : undefined;
    message.startDateCategory = object.startDateCategory ?? 0;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.url = object.url ?? "";
    message.websites = object.websites?.map((e) => CompanyWebsite.fromPartial(e)) || [];
    message.checksum = object.checksum ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? CompanyStatus.fromPartial(object.status)
      : undefined;
    message.startDateFormat = (object.startDateFormat !== undefined && object.startDateFormat !== null)
      ? DateFormat.fromPartial(object.startDateFormat)
      : undefined;
    message.changeDateFormat = (object.changeDateFormat !== undefined && object.changeDateFormat !== null)
      ? DateFormat.fromPartial(object.changeDateFormat)
      : undefined;
    return message;
  },
};

function createBaseCompanyLogoResult(): CompanyLogoResult {
  return { companylogos: [] };
}

export const CompanyLogoResult: MessageFns<CompanyLogoResult> = {
  encode(message: CompanyLogoResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.companylogos) {
      CompanyLogo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompanyLogoResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompanyLogoResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.companylogos.push(CompanyLogo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompanyLogoResult {
    return {
      companylogos: globalThis.Array.isArray(object?.companylogos)
        ? object.companylogos.map((e: any) => CompanyLogo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CompanyLogoResult): unknown {
    const obj: any = {};
    if (message.companylogos?.length) {
      obj.companylogos = message.companylogos.map((e) => CompanyLogo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CompanyLogoResult>): CompanyLogoResult {
    return CompanyLogoResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompanyLogoResult>): CompanyLogoResult {
    const message = createBaseCompanyLogoResult();
    message.companylogos = object.companylogos?.map((e) => CompanyLogo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCompanyLogo(): CompanyLogo {
  return { id: 0, alphaChannel: false, animated: false, height: 0, imageId: "", url: "", width: 0, checksum: "" };
}

export const CompanyLogo: MessageFns<CompanyLogo> = {
  encode(message: CompanyLogo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.alphaChannel !== false) {
      writer.uint32(16).bool(message.alphaChannel);
    }
    if (message.animated !== false) {
      writer.uint32(24).bool(message.animated);
    }
    if (message.height !== 0) {
      writer.uint32(32).int32(message.height);
    }
    if (message.imageId !== "") {
      writer.uint32(42).string(message.imageId);
    }
    if (message.url !== "") {
      writer.uint32(50).string(message.url);
    }
    if (message.width !== 0) {
      writer.uint32(56).int32(message.width);
    }
    if (message.checksum !== "") {
      writer.uint32(66).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompanyLogo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompanyLogo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.alphaChannel = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.animated = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.imageId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompanyLogo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      alphaChannel: isSet(object.alphaChannel) ? globalThis.Boolean(object.alphaChannel) : false,
      animated: isSet(object.animated) ? globalThis.Boolean(object.animated) : false,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      imageId: isSet(object.imageId) ? globalThis.String(object.imageId) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: CompanyLogo): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.alphaChannel !== false) {
      obj.alphaChannel = message.alphaChannel;
    }
    if (message.animated !== false) {
      obj.animated = message.animated;
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<CompanyLogo>): CompanyLogo {
    return CompanyLogo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompanyLogo>): CompanyLogo {
    const message = createBaseCompanyLogo();
    message.id = object.id ?? 0;
    message.alphaChannel = object.alphaChannel ?? false;
    message.animated = object.animated ?? false;
    message.height = object.height ?? 0;
    message.imageId = object.imageId ?? "";
    message.url = object.url ?? "";
    message.width = object.width ?? 0;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseCompanyStatusResult(): CompanyStatusResult {
  return { companystatuses: [] };
}

export const CompanyStatusResult: MessageFns<CompanyStatusResult> = {
  encode(message: CompanyStatusResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.companystatuses) {
      CompanyStatus.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompanyStatusResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompanyStatusResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.companystatuses.push(CompanyStatus.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompanyStatusResult {
    return {
      companystatuses: globalThis.Array.isArray(object?.companystatuses)
        ? object.companystatuses.map((e: any) => CompanyStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CompanyStatusResult): unknown {
    const obj: any = {};
    if (message.companystatuses?.length) {
      obj.companystatuses = message.companystatuses.map((e) => CompanyStatus.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CompanyStatusResult>): CompanyStatusResult {
    return CompanyStatusResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompanyStatusResult>): CompanyStatusResult {
    const message = createBaseCompanyStatusResult();
    message.companystatuses = object.companystatuses?.map((e) => CompanyStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCompanyStatus(): CompanyStatus {
  return { id: 0, name: "", createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const CompanyStatus: MessageFns<CompanyStatus> = {
  encode(message: CompanyStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(34).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(42).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompanyStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompanyStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompanyStatus {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: CompanyStatus): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<CompanyStatus>): CompanyStatus {
    return CompanyStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompanyStatus>): CompanyStatus {
    const message = createBaseCompanyStatus();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseCompanyWebsiteResult(): CompanyWebsiteResult {
  return { companywebsites: [] };
}

export const CompanyWebsiteResult: MessageFns<CompanyWebsiteResult> = {
  encode(message: CompanyWebsiteResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.companywebsites) {
      CompanyWebsite.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompanyWebsiteResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompanyWebsiteResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.companywebsites.push(CompanyWebsite.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompanyWebsiteResult {
    return {
      companywebsites: globalThis.Array.isArray(object?.companywebsites)
        ? object.companywebsites.map((e: any) => CompanyWebsite.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CompanyWebsiteResult): unknown {
    const obj: any = {};
    if (message.companywebsites?.length) {
      obj.companywebsites = message.companywebsites.map((e) => CompanyWebsite.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CompanyWebsiteResult>): CompanyWebsiteResult {
    return CompanyWebsiteResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompanyWebsiteResult>): CompanyWebsiteResult {
    const message = createBaseCompanyWebsiteResult();
    message.companywebsites = object.companywebsites?.map((e) => CompanyWebsite.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCompanyWebsite(): CompanyWebsite {
  return { id: 0, category: 0, trusted: false, url: "", checksum: "", type: undefined };
}

export const CompanyWebsite: MessageFns<CompanyWebsite> = {
  encode(message: CompanyWebsite, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.category !== 0) {
      writer.uint32(16).int32(message.category);
    }
    if (message.trusted !== false) {
      writer.uint32(24).bool(message.trusted);
    }
    if (message.url !== "") {
      writer.uint32(34).string(message.url);
    }
    if (message.checksum !== "") {
      writer.uint32(42).string(message.checksum);
    }
    if (message.type !== undefined) {
      WebsiteType.encode(message.type, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompanyWebsite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompanyWebsite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.trusted = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.type = WebsiteType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompanyWebsite {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      category: isSet(object.category) ? websiteCategoryEnumFromJSON(object.category) : 0,
      trusted: isSet(object.trusted) ? globalThis.Boolean(object.trusted) : false,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      type: isSet(object.type) ? WebsiteType.fromJSON(object.type) : undefined,
    };
  },

  toJSON(message: CompanyWebsite): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.category !== 0) {
      obj.category = websiteCategoryEnumToJSON(message.category);
    }
    if (message.trusted !== false) {
      obj.trusted = message.trusted;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.type !== undefined) {
      obj.type = WebsiteType.toJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<CompanyWebsite>): CompanyWebsite {
    return CompanyWebsite.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompanyWebsite>): CompanyWebsite {
    const message = createBaseCompanyWebsite();
    message.id = object.id ?? 0;
    message.category = object.category ?? 0;
    message.trusted = object.trusted ?? false;
    message.url = object.url ?? "";
    message.checksum = object.checksum ?? "";
    message.type = (object.type !== undefined && object.type !== null)
      ? WebsiteType.fromPartial(object.type)
      : undefined;
    return message;
  },
};

function createBaseCoverResult(): CoverResult {
  return { covers: [] };
}

export const CoverResult: MessageFns<CoverResult> = {
  encode(message: CoverResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.covers) {
      Cover.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoverResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoverResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.covers.push(Cover.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoverResult {
    return { covers: globalThis.Array.isArray(object?.covers) ? object.covers.map((e: any) => Cover.fromJSON(e)) : [] };
  },

  toJSON(message: CoverResult): unknown {
    const obj: any = {};
    if (message.covers?.length) {
      obj.covers = message.covers.map((e) => Cover.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CoverResult>): CoverResult {
    return CoverResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CoverResult>): CoverResult {
    const message = createBaseCoverResult();
    message.covers = object.covers?.map((e) => Cover.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCover(): Cover {
  return {
    id: 0,
    alphaChannel: false,
    animated: false,
    game: undefined,
    height: 0,
    imageId: "",
    url: "",
    width: 0,
    checksum: "",
    gameLocalization: undefined,
  };
}

export const Cover: MessageFns<Cover> = {
  encode(message: Cover, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.alphaChannel !== false) {
      writer.uint32(16).bool(message.alphaChannel);
    }
    if (message.animated !== false) {
      writer.uint32(24).bool(message.animated);
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(34).fork()).join();
    }
    if (message.height !== 0) {
      writer.uint32(40).int32(message.height);
    }
    if (message.imageId !== "") {
      writer.uint32(50).string(message.imageId);
    }
    if (message.url !== "") {
      writer.uint32(58).string(message.url);
    }
    if (message.width !== 0) {
      writer.uint32(64).int32(message.width);
    }
    if (message.checksum !== "") {
      writer.uint32(74).string(message.checksum);
    }
    if (message.gameLocalization !== undefined) {
      GameLocalization.encode(message.gameLocalization, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cover {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCover();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.alphaChannel = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.animated = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.imageId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.gameLocalization = GameLocalization.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cover {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      alphaChannel: isSet(object.alphaChannel) ? globalThis.Boolean(object.alphaChannel) : false,
      animated: isSet(object.animated) ? globalThis.Boolean(object.animated) : false,
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      imageId: isSet(object.imageId) ? globalThis.String(object.imageId) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      gameLocalization: isSet(object.gameLocalization) ? GameLocalization.fromJSON(object.gameLocalization) : undefined,
    };
  },

  toJSON(message: Cover): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.alphaChannel !== false) {
      obj.alphaChannel = message.alphaChannel;
    }
    if (message.animated !== false) {
      obj.animated = message.animated;
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.gameLocalization !== undefined) {
      obj.gameLocalization = GameLocalization.toJSON(message.gameLocalization);
    }
    return obj;
  },

  create(base?: DeepPartial<Cover>): Cover {
    return Cover.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cover>): Cover {
    const message = createBaseCover();
    message.id = object.id ?? 0;
    message.alphaChannel = object.alphaChannel ?? false;
    message.animated = object.animated ?? false;
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    message.height = object.height ?? 0;
    message.imageId = object.imageId ?? "";
    message.url = object.url ?? "";
    message.width = object.width ?? 0;
    message.checksum = object.checksum ?? "";
    message.gameLocalization = (object.gameLocalization !== undefined && object.gameLocalization !== null)
      ? GameLocalization.fromPartial(object.gameLocalization)
      : undefined;
    return message;
  },
};

function createBaseDateFormatResult(): DateFormatResult {
  return { dateformats: [] };
}

export const DateFormatResult: MessageFns<DateFormatResult> = {
  encode(message: DateFormatResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dateformats) {
      DateFormat.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DateFormatResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDateFormatResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dateformats.push(DateFormat.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DateFormatResult {
    return {
      dateformats: globalThis.Array.isArray(object?.dateformats)
        ? object.dateformats.map((e: any) => DateFormat.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DateFormatResult): unknown {
    const obj: any = {};
    if (message.dateformats?.length) {
      obj.dateformats = message.dateformats.map((e) => DateFormat.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DateFormatResult>): DateFormatResult {
    return DateFormatResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DateFormatResult>): DateFormatResult {
    const message = createBaseDateFormatResult();
    message.dateformats = object.dateformats?.map((e) => DateFormat.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDateFormat(): DateFormat {
  return { id: 0, format: "", createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const DateFormat: MessageFns<DateFormat> = {
  encode(message: DateFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.format !== "") {
      writer.uint32(18).string(message.format);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(34).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(42).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DateFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDateFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.format = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DateFormat {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: DateFormat): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<DateFormat>): DateFormat {
    return DateFormat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DateFormat>): DateFormat {
    const message = createBaseDateFormat();
    message.id = object.id ?? 0;
    message.format = object.format ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseEventResult(): EventResult {
  return { events: [] };
}

export const EventResult: MessageFns<EventResult> = {
  encode(message: EventResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      Event.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(Event.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventResult {
    return { events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => Event.fromJSON(e)) : [] };
  },

  toJSON(message: EventResult): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => Event.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EventResult>): EventResult {
    return EventResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventResult>): EventResult {
    const message = createBaseEventResult();
    message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEvent(): Event {
  return {
    id: 0,
    name: "",
    description: "",
    slug: "",
    eventLogo: undefined,
    startTime: undefined,
    timeZone: "",
    endTime: undefined,
    liveStreamUrl: "",
    games: [],
    videos: [],
    eventNetworks: [],
    createdAt: undefined,
    updatedAt: undefined,
    checksum: "",
  };
}

export const Event: MessageFns<Event> = {
  encode(message: Event, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.slug !== "") {
      writer.uint32(34).string(message.slug);
    }
    if (message.eventLogo !== undefined) {
      EventLogo.encode(message.eventLogo, writer.uint32(42).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(message.startTime, writer.uint32(50).fork()).join();
    }
    if (message.timeZone !== "") {
      writer.uint32(58).string(message.timeZone);
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(message.endTime, writer.uint32(66).fork()).join();
    }
    if (message.liveStreamUrl !== "") {
      writer.uint32(74).string(message.liveStreamUrl);
    }
    for (const v of message.games) {
      Game.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.videos) {
      GameVideo.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.eventNetworks) {
      EventNetwork.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(106).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(114).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(122).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.eventLogo = EventLogo.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.startTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.timeZone = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.endTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.liveStreamUrl = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.games.push(Game.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.videos.push(GameVideo.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.eventNetworks.push(EventNetwork.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      eventLogo: isSet(object.eventLogo) ? EventLogo.fromJSON(object.eventLogo) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      timeZone: isSet(object.timeZone) ? globalThis.String(object.timeZone) : "",
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      liveStreamUrl: isSet(object.liveStreamUrl) ? globalThis.String(object.liveStreamUrl) : "",
      games: globalThis.Array.isArray(object?.games) ? object.games.map((e: any) => Game.fromJSON(e)) : [],
      videos: globalThis.Array.isArray(object?.videos) ? object.videos.map((e: any) => GameVideo.fromJSON(e)) : [],
      eventNetworks: globalThis.Array.isArray(object?.eventNetworks)
        ? object.eventNetworks.map((e: any) => EventNetwork.fromJSON(e))
        : [],
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: Event): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.eventLogo !== undefined) {
      obj.eventLogo = EventLogo.toJSON(message.eventLogo);
    }
    if (message.startTime !== undefined) {
      obj.startTime = fromTimestamp(message.startTime).toISOString();
    }
    if (message.timeZone !== "") {
      obj.timeZone = message.timeZone;
    }
    if (message.endTime !== undefined) {
      obj.endTime = fromTimestamp(message.endTime).toISOString();
    }
    if (message.liveStreamUrl !== "") {
      obj.liveStreamUrl = message.liveStreamUrl;
    }
    if (message.games?.length) {
      obj.games = message.games.map((e) => Game.toJSON(e));
    }
    if (message.videos?.length) {
      obj.videos = message.videos.map((e) => GameVideo.toJSON(e));
    }
    if (message.eventNetworks?.length) {
      obj.eventNetworks = message.eventNetworks.map((e) => EventNetwork.toJSON(e));
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<Event>): Event {
    return Event.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Event>): Event {
    const message = createBaseEvent();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.slug = object.slug ?? "";
    message.eventLogo = (object.eventLogo !== undefined && object.eventLogo !== null)
      ? EventLogo.fromPartial(object.eventLogo)
      : undefined;
    message.startTime = (object.startTime !== undefined && object.startTime !== null)
      ? Timestamp.fromPartial(object.startTime)
      : undefined;
    message.timeZone = object.timeZone ?? "";
    message.endTime = (object.endTime !== undefined && object.endTime !== null)
      ? Timestamp.fromPartial(object.endTime)
      : undefined;
    message.liveStreamUrl = object.liveStreamUrl ?? "";
    message.games = object.games?.map((e) => Game.fromPartial(e)) || [];
    message.videos = object.videos?.map((e) => GameVideo.fromPartial(e)) || [];
    message.eventNetworks = object.eventNetworks?.map((e) => EventNetwork.fromPartial(e)) || [];
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseEventLogoResult(): EventLogoResult {
  return { eventlogos: [] };
}

export const EventLogoResult: MessageFns<EventLogoResult> = {
  encode(message: EventLogoResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.eventlogos) {
      EventLogo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventLogoResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventLogoResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventlogos.push(EventLogo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventLogoResult {
    return {
      eventlogos: globalThis.Array.isArray(object?.eventlogos)
        ? object.eventlogos.map((e: any) => EventLogo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EventLogoResult): unknown {
    const obj: any = {};
    if (message.eventlogos?.length) {
      obj.eventlogos = message.eventlogos.map((e) => EventLogo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EventLogoResult>): EventLogoResult {
    return EventLogoResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventLogoResult>): EventLogoResult {
    const message = createBaseEventLogoResult();
    message.eventlogos = object.eventlogos?.map((e) => EventLogo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventLogo(): EventLogo {
  return {
    id: 0,
    event: undefined,
    alphaChannel: false,
    animated: false,
    height: 0,
    imageId: "",
    url: "",
    width: 0,
    createdAt: undefined,
    updatedAt: undefined,
    checksum: "",
  };
}

export const EventLogo: MessageFns<EventLogo> = {
  encode(message: EventLogo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.event !== undefined) {
      Event.encode(message.event, writer.uint32(18).fork()).join();
    }
    if (message.alphaChannel !== false) {
      writer.uint32(24).bool(message.alphaChannel);
    }
    if (message.animated !== false) {
      writer.uint32(32).bool(message.animated);
    }
    if (message.height !== 0) {
      writer.uint32(40).int32(message.height);
    }
    if (message.imageId !== "") {
      writer.uint32(50).string(message.imageId);
    }
    if (message.url !== "") {
      writer.uint32(58).string(message.url);
    }
    if (message.width !== 0) {
      writer.uint32(64).int32(message.width);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(74).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(82).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(90).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventLogo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventLogo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.event = Event.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.alphaChannel = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.animated = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.imageId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventLogo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      event: isSet(object.event) ? Event.fromJSON(object.event) : undefined,
      alphaChannel: isSet(object.alphaChannel) ? globalThis.Boolean(object.alphaChannel) : false,
      animated: isSet(object.animated) ? globalThis.Boolean(object.animated) : false,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      imageId: isSet(object.imageId) ? globalThis.String(object.imageId) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: EventLogo): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.event !== undefined) {
      obj.event = Event.toJSON(message.event);
    }
    if (message.alphaChannel !== false) {
      obj.alphaChannel = message.alphaChannel;
    }
    if (message.animated !== false) {
      obj.animated = message.animated;
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<EventLogo>): EventLogo {
    return EventLogo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventLogo>): EventLogo {
    const message = createBaseEventLogo();
    message.id = object.id ?? 0;
    message.event = (object.event !== undefined && object.event !== null) ? Event.fromPartial(object.event) : undefined;
    message.alphaChannel = object.alphaChannel ?? false;
    message.animated = object.animated ?? false;
    message.height = object.height ?? 0;
    message.imageId = object.imageId ?? "";
    message.url = object.url ?? "";
    message.width = object.width ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseEventNetworkResult(): EventNetworkResult {
  return { eventnetworks: [] };
}

export const EventNetworkResult: MessageFns<EventNetworkResult> = {
  encode(message: EventNetworkResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.eventnetworks) {
      EventNetwork.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventNetworkResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventNetworkResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventnetworks.push(EventNetwork.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventNetworkResult {
    return {
      eventnetworks: globalThis.Array.isArray(object?.eventnetworks)
        ? object.eventnetworks.map((e: any) => EventNetwork.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EventNetworkResult): unknown {
    const obj: any = {};
    if (message.eventnetworks?.length) {
      obj.eventnetworks = message.eventnetworks.map((e) => EventNetwork.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EventNetworkResult>): EventNetworkResult {
    return EventNetworkResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventNetworkResult>): EventNetworkResult {
    const message = createBaseEventNetworkResult();
    message.eventnetworks = object.eventnetworks?.map((e) => EventNetwork.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventNetwork(): EventNetwork {
  return {
    id: 0,
    event: undefined,
    url: "",
    networkType: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    checksum: "",
  };
}

export const EventNetwork: MessageFns<EventNetwork> = {
  encode(message: EventNetwork, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.event !== undefined) {
      Event.encode(message.event, writer.uint32(18).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    if (message.networkType !== undefined) {
      NetworkType.encode(message.networkType, writer.uint32(34).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(42).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(50).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(58).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventNetwork {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventNetwork();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.event = Event.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.networkType = NetworkType.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventNetwork {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      event: isSet(object.event) ? Event.fromJSON(object.event) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      networkType: isSet(object.networkType) ? NetworkType.fromJSON(object.networkType) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: EventNetwork): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.event !== undefined) {
      obj.event = Event.toJSON(message.event);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.networkType !== undefined) {
      obj.networkType = NetworkType.toJSON(message.networkType);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<EventNetwork>): EventNetwork {
    return EventNetwork.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventNetwork>): EventNetwork {
    const message = createBaseEventNetwork();
    message.id = object.id ?? 0;
    message.event = (object.event !== undefined && object.event !== null) ? Event.fromPartial(object.event) : undefined;
    message.url = object.url ?? "";
    message.networkType = (object.networkType !== undefined && object.networkType !== null)
      ? NetworkType.fromPartial(object.networkType)
      : undefined;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseExternalGameResult(): ExternalGameResult {
  return { externalgames: [] };
}

export const ExternalGameResult: MessageFns<ExternalGameResult> = {
  encode(message: ExternalGameResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.externalgames) {
      ExternalGame.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalGameResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalGameResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.externalgames.push(ExternalGame.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalGameResult {
    return {
      externalgames: globalThis.Array.isArray(object?.externalgames)
        ? object.externalgames.map((e: any) => ExternalGame.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExternalGameResult): unknown {
    const obj: any = {};
    if (message.externalgames?.length) {
      obj.externalgames = message.externalgames.map((e) => ExternalGame.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ExternalGameResult>): ExternalGameResult {
    return ExternalGameResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalGameResult>): ExternalGameResult {
    const message = createBaseExternalGameResult();
    message.externalgames = object.externalgames?.map((e) => ExternalGame.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExternalGame(): ExternalGame {
  return {
    id: 0,
    category: 0,
    createdAt: undefined,
    game: undefined,
    name: "",
    uid: "",
    updatedAt: undefined,
    url: "",
    year: 0,
    media: 0,
    platform: undefined,
    countries: [],
    checksum: "",
    externalGameSource: undefined,
    gameReleaseFormat: undefined,
  };
}

export const ExternalGame: MessageFns<ExternalGame> = {
  encode(message: ExternalGame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.category !== 0) {
      writer.uint32(16).int32(message.category);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(34).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(50).string(message.uid);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(58).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(66).string(message.url);
    }
    if (message.year !== 0) {
      writer.uint32(72).int32(message.year);
    }
    if (message.media !== 0) {
      writer.uint32(80).int32(message.media);
    }
    if (message.platform !== undefined) {
      Platform.encode(message.platform, writer.uint32(90).fork()).join();
    }
    writer.uint32(98).fork();
    for (const v of message.countries) {
      writer.int32(v);
    }
    writer.join();
    if (message.checksum !== "") {
      writer.uint32(106).string(message.checksum);
    }
    if (message.externalGameSource !== undefined) {
      ExternalGameSource.encode(message.externalGameSource, writer.uint32(114).fork()).join();
    }
    if (message.gameReleaseFormat !== undefined) {
      GameReleaseFormat.encode(message.gameReleaseFormat, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalGame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalGame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.year = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.media = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.platform = Platform.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag === 96) {
            message.countries.push(reader.int32());

            continue;
          }

          if (tag === 98) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.countries.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.externalGameSource = ExternalGameSource.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.gameReleaseFormat = GameReleaseFormat.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalGame {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      category: isSet(object.category) ? externalGameCategoryEnumFromJSON(object.category) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      year: isSet(object.year) ? globalThis.Number(object.year) : 0,
      media: isSet(object.media) ? externalGameMediaEnumFromJSON(object.media) : 0,
      platform: isSet(object.platform) ? Platform.fromJSON(object.platform) : undefined,
      countries: globalThis.Array.isArray(object?.countries)
        ? object.countries.map((e: any) => globalThis.Number(e))
        : [],
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      externalGameSource: isSet(object.externalGameSource)
        ? ExternalGameSource.fromJSON(object.externalGameSource)
        : undefined,
      gameReleaseFormat: isSet(object.gameReleaseFormat)
        ? GameReleaseFormat.fromJSON(object.gameReleaseFormat)
        : undefined,
    };
  },

  toJSON(message: ExternalGame): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.category !== 0) {
      obj.category = externalGameCategoryEnumToJSON(message.category);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.year !== 0) {
      obj.year = Math.round(message.year);
    }
    if (message.media !== 0) {
      obj.media = externalGameMediaEnumToJSON(message.media);
    }
    if (message.platform !== undefined) {
      obj.platform = Platform.toJSON(message.platform);
    }
    if (message.countries?.length) {
      obj.countries = message.countries.map((e) => Math.round(e));
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.externalGameSource !== undefined) {
      obj.externalGameSource = ExternalGameSource.toJSON(message.externalGameSource);
    }
    if (message.gameReleaseFormat !== undefined) {
      obj.gameReleaseFormat = GameReleaseFormat.toJSON(message.gameReleaseFormat);
    }
    return obj;
  },

  create(base?: DeepPartial<ExternalGame>): ExternalGame {
    return ExternalGame.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalGame>): ExternalGame {
    const message = createBaseExternalGame();
    message.id = object.id ?? 0;
    message.category = object.category ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.url = object.url ?? "";
    message.year = object.year ?? 0;
    message.media = object.media ?? 0;
    message.platform = (object.platform !== undefined && object.platform !== null)
      ? Platform.fromPartial(object.platform)
      : undefined;
    message.countries = object.countries?.map((e) => e) || [];
    message.checksum = object.checksum ?? "";
    message.externalGameSource = (object.externalGameSource !== undefined && object.externalGameSource !== null)
      ? ExternalGameSource.fromPartial(object.externalGameSource)
      : undefined;
    message.gameReleaseFormat = (object.gameReleaseFormat !== undefined && object.gameReleaseFormat !== null)
      ? GameReleaseFormat.fromPartial(object.gameReleaseFormat)
      : undefined;
    return message;
  },
};

function createBaseExternalGameSourceResult(): ExternalGameSourceResult {
  return { externalgamesources: [] };
}

export const ExternalGameSourceResult: MessageFns<ExternalGameSourceResult> = {
  encode(message: ExternalGameSourceResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.externalgamesources) {
      ExternalGameSource.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalGameSourceResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalGameSourceResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.externalgamesources.push(ExternalGameSource.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalGameSourceResult {
    return {
      externalgamesources: globalThis.Array.isArray(object?.externalgamesources)
        ? object.externalgamesources.map((e: any) => ExternalGameSource.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExternalGameSourceResult): unknown {
    const obj: any = {};
    if (message.externalgamesources?.length) {
      obj.externalgamesources = message.externalgamesources.map((e) => ExternalGameSource.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ExternalGameSourceResult>): ExternalGameSourceResult {
    return ExternalGameSourceResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalGameSourceResult>): ExternalGameSourceResult {
    const message = createBaseExternalGameSourceResult();
    message.externalgamesources = object.externalgamesources?.map((e) => ExternalGameSource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExternalGameSource(): ExternalGameSource {
  return { id: 0, name: "", createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const ExternalGameSource: MessageFns<ExternalGameSource> = {
  encode(message: ExternalGameSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(34).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(42).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(50).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalGameSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalGameSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalGameSource {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: ExternalGameSource): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<ExternalGameSource>): ExternalGameSource {
    return ExternalGameSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalGameSource>): ExternalGameSource {
    const message = createBaseExternalGameSource();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseFranchiseResult(): FranchiseResult {
  return { franchises: [] };
}

export const FranchiseResult: MessageFns<FranchiseResult> = {
  encode(message: FranchiseResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.franchises) {
      Franchise.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FranchiseResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFranchiseResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.franchises.push(Franchise.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FranchiseResult {
    return {
      franchises: globalThis.Array.isArray(object?.franchises)
        ? object.franchises.map((e: any) => Franchise.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FranchiseResult): unknown {
    const obj: any = {};
    if (message.franchises?.length) {
      obj.franchises = message.franchises.map((e) => Franchise.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FranchiseResult>): FranchiseResult {
    return FranchiseResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FranchiseResult>): FranchiseResult {
    const message = createBaseFranchiseResult();
    message.franchises = object.franchises?.map((e) => Franchise.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFranchise(): Franchise {
  return { id: 0, createdAt: undefined, games: [], name: "", slug: "", updatedAt: undefined, url: "", checksum: "" };
}

export const Franchise: MessageFns<Franchise> = {
  encode(message: Franchise, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(18).fork()).join();
    }
    for (const v of message.games) {
      Game.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(42).string(message.slug);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(50).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(58).string(message.url);
    }
    if (message.checksum !== "") {
      writer.uint32(66).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Franchise {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFranchise();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.games.push(Game.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Franchise {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      games: globalThis.Array.isArray(object?.games) ? object.games.map((e: any) => Game.fromJSON(e)) : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: Franchise): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.games?.length) {
      obj.games = message.games.map((e) => Game.toJSON(e));
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<Franchise>): Franchise {
    return Franchise.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Franchise>): Franchise {
    const message = createBaseFranchise();
    message.id = object.id ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.games = object.games?.map((e) => Game.fromPartial(e)) || [];
    message.name = object.name ?? "";
    message.slug = object.slug ?? "";
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.url = object.url ?? "";
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseGameResult(): GameResult {
  return { games: [] };
}

export const GameResult: MessageFns<GameResult> = {
  encode(message: GameResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.games) {
      Game.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.games.push(Game.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameResult {
    return { games: globalThis.Array.isArray(object?.games) ? object.games.map((e: any) => Game.fromJSON(e)) : [] };
  },

  toJSON(message: GameResult): unknown {
    const obj: any = {};
    if (message.games?.length) {
      obj.games = message.games.map((e) => Game.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GameResult>): GameResult {
    return GameResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameResult>): GameResult {
    const message = createBaseGameResult();
    message.games = object.games?.map((e) => Game.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGame(): Game {
  return {
    id: 0,
    ageRatings: [],
    aggregatedRating: 0,
    aggregatedRatingCount: 0,
    alternativeNames: [],
    artworks: [],
    bundles: [],
    category: 0,
    collection: undefined,
    cover: undefined,
    createdAt: undefined,
    dlcs: [],
    expansions: [],
    externalGames: [],
    firstReleaseDate: undefined,
    follows: 0,
    franchise: undefined,
    franchises: [],
    gameEngines: [],
    gameModes: [],
    genres: [],
    hypes: 0,
    involvedCompanies: [],
    keywords: [],
    multiplayerModes: [],
    name: "",
    parentGame: undefined,
    platforms: [],
    playerPerspectives: [],
    rating: 0,
    ratingCount: 0,
    releaseDates: [],
    screenshots: [],
    similarGames: [],
    slug: "",
    standaloneExpansions: [],
    status: 0,
    storyline: "",
    summary: "",
    tags: [],
    themes: [],
    totalRating: 0,
    totalRatingCount: 0,
    updatedAt: undefined,
    url: "",
    versionParent: undefined,
    versionTitle: "",
    videos: [],
    websites: [],
    checksum: "",
    remakes: [],
    remasters: [],
    expandedGames: [],
    ports: [],
    forks: [],
    languageSupports: [],
    gameLocalizations: [],
    collections: [],
    gameStatus: undefined,
    gameType: undefined,
  };
}

export const Game: MessageFns<Game> = {
  encode(message: Game, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    for (const v of message.ageRatings) {
      AgeRating.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.aggregatedRating !== 0) {
      writer.uint32(25).double(message.aggregatedRating);
    }
    if (message.aggregatedRatingCount !== 0) {
      writer.uint32(32).int32(message.aggregatedRatingCount);
    }
    for (const v of message.alternativeNames) {
      AlternativeName.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.artworks) {
      Artwork.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.bundles) {
      Game.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.category !== 0) {
      writer.uint32(64).int32(message.category);
    }
    if (message.collection !== undefined) {
      Collection.encode(message.collection, writer.uint32(74).fork()).join();
    }
    if (message.cover !== undefined) {
      Cover.encode(message.cover, writer.uint32(82).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(90).fork()).join();
    }
    for (const v of message.dlcs) {
      Game.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.expansions) {
      Game.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.externalGames) {
      ExternalGame.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.firstReleaseDate !== undefined) {
      Timestamp.encode(message.firstReleaseDate, writer.uint32(122).fork()).join();
    }
    if (message.follows !== 0) {
      writer.uint32(128).int32(message.follows);
    }
    if (message.franchise !== undefined) {
      Franchise.encode(message.franchise, writer.uint32(138).fork()).join();
    }
    for (const v of message.franchises) {
      Franchise.encode(v!, writer.uint32(146).fork()).join();
    }
    for (const v of message.gameEngines) {
      GameEngine.encode(v!, writer.uint32(154).fork()).join();
    }
    for (const v of message.gameModes) {
      GameMode.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.genres) {
      Genre.encode(v!, writer.uint32(170).fork()).join();
    }
    if (message.hypes !== 0) {
      writer.uint32(176).int32(message.hypes);
    }
    for (const v of message.involvedCompanies) {
      InvolvedCompany.encode(v!, writer.uint32(186).fork()).join();
    }
    for (const v of message.keywords) {
      Keyword.encode(v!, writer.uint32(194).fork()).join();
    }
    for (const v of message.multiplayerModes) {
      MultiplayerMode.encode(v!, writer.uint32(202).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(210).string(message.name);
    }
    if (message.parentGame !== undefined) {
      Game.encode(message.parentGame, writer.uint32(218).fork()).join();
    }
    for (const v of message.platforms) {
      Platform.encode(v!, writer.uint32(226).fork()).join();
    }
    for (const v of message.playerPerspectives) {
      PlayerPerspective.encode(v!, writer.uint32(234).fork()).join();
    }
    if (message.rating !== 0) {
      writer.uint32(241).double(message.rating);
    }
    if (message.ratingCount !== 0) {
      writer.uint32(248).int32(message.ratingCount);
    }
    for (const v of message.releaseDates) {
      ReleaseDate.encode(v!, writer.uint32(258).fork()).join();
    }
    for (const v of message.screenshots) {
      Screenshot.encode(v!, writer.uint32(266).fork()).join();
    }
    for (const v of message.similarGames) {
      Game.encode(v!, writer.uint32(274).fork()).join();
    }
    if (message.slug !== "") {
      writer.uint32(282).string(message.slug);
    }
    for (const v of message.standaloneExpansions) {
      Game.encode(v!, writer.uint32(290).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(296).int32(message.status);
    }
    if (message.storyline !== "") {
      writer.uint32(306).string(message.storyline);
    }
    if (message.summary !== "") {
      writer.uint32(314).string(message.summary);
    }
    writer.uint32(322).fork();
    for (const v of message.tags) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.themes) {
      Theme.encode(v!, writer.uint32(330).fork()).join();
    }
    if (message.totalRating !== 0) {
      writer.uint32(337).double(message.totalRating);
    }
    if (message.totalRatingCount !== 0) {
      writer.uint32(344).int32(message.totalRatingCount);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(354).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(362).string(message.url);
    }
    if (message.versionParent !== undefined) {
      Game.encode(message.versionParent, writer.uint32(370).fork()).join();
    }
    if (message.versionTitle !== "") {
      writer.uint32(378).string(message.versionTitle);
    }
    for (const v of message.videos) {
      GameVideo.encode(v!, writer.uint32(386).fork()).join();
    }
    for (const v of message.websites) {
      Website.encode(v!, writer.uint32(394).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(402).string(message.checksum);
    }
    for (const v of message.remakes) {
      Game.encode(v!, writer.uint32(410).fork()).join();
    }
    for (const v of message.remasters) {
      Game.encode(v!, writer.uint32(418).fork()).join();
    }
    for (const v of message.expandedGames) {
      Game.encode(v!, writer.uint32(426).fork()).join();
    }
    for (const v of message.ports) {
      Game.encode(v!, writer.uint32(434).fork()).join();
    }
    for (const v of message.forks) {
      Game.encode(v!, writer.uint32(442).fork()).join();
    }
    for (const v of message.languageSupports) {
      LanguageSupport.encode(v!, writer.uint32(450).fork()).join();
    }
    for (const v of message.gameLocalizations) {
      GameLocalization.encode(v!, writer.uint32(458).fork()).join();
    }
    for (const v of message.collections) {
      Collection.encode(v!, writer.uint32(466).fork()).join();
    }
    if (message.gameStatus !== undefined) {
      GameStatus.encode(message.gameStatus, writer.uint32(474).fork()).join();
    }
    if (message.gameType !== undefined) {
      GameType.encode(message.gameType, writer.uint32(482).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Game {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ageRatings.push(AgeRating.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.aggregatedRating = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.aggregatedRatingCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.alternativeNames.push(AlternativeName.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.artworks.push(Artwork.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.bundles.push(Game.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.collection = Collection.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.cover = Cover.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.dlcs.push(Game.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.expansions.push(Game.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.externalGames.push(ExternalGame.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.firstReleaseDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.follows = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.franchise = Franchise.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.franchises.push(Franchise.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.gameEngines.push(GameEngine.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.gameModes.push(GameMode.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.genres.push(Genre.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.hypes = reader.int32();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.involvedCompanies.push(InvolvedCompany.decode(reader, reader.uint32()));
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.keywords.push(Keyword.decode(reader, reader.uint32()));
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.multiplayerModes.push(MultiplayerMode.decode(reader, reader.uint32()));
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.parentGame = Game.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.platforms.push(Platform.decode(reader, reader.uint32()));
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.playerPerspectives.push(PlayerPerspective.decode(reader, reader.uint32()));
          continue;
        }
        case 30: {
          if (tag !== 241) {
            break;
          }

          message.rating = reader.double();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.ratingCount = reader.int32();
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.releaseDates.push(ReleaseDate.decode(reader, reader.uint32()));
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.screenshots.push(Screenshot.decode(reader, reader.uint32()));
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.similarGames.push(Game.decode(reader, reader.uint32()));
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.standaloneExpansions.push(Game.decode(reader, reader.uint32()));
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.storyline = reader.string();
          continue;
        }
        case 39: {
          if (tag !== 314) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
        case 40: {
          if (tag === 320) {
            message.tags.push(reader.int32());

            continue;
          }

          if (tag === 322) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.tags.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.themes.push(Theme.decode(reader, reader.uint32()));
          continue;
        }
        case 42: {
          if (tag !== 337) {
            break;
          }

          message.totalRating = reader.double();
          continue;
        }
        case 43: {
          if (tag !== 344) {
            break;
          }

          message.totalRatingCount = reader.int32();
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 45: {
          if (tag !== 362) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 46: {
          if (tag !== 370) {
            break;
          }

          message.versionParent = Game.decode(reader, reader.uint32());
          continue;
        }
        case 47: {
          if (tag !== 378) {
            break;
          }

          message.versionTitle = reader.string();
          continue;
        }
        case 48: {
          if (tag !== 386) {
            break;
          }

          message.videos.push(GameVideo.decode(reader, reader.uint32()));
          continue;
        }
        case 49: {
          if (tag !== 394) {
            break;
          }

          message.websites.push(Website.decode(reader, reader.uint32()));
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.remakes.push(Game.decode(reader, reader.uint32()));
          continue;
        }
        case 52: {
          if (tag !== 418) {
            break;
          }

          message.remasters.push(Game.decode(reader, reader.uint32()));
          continue;
        }
        case 53: {
          if (tag !== 426) {
            break;
          }

          message.expandedGames.push(Game.decode(reader, reader.uint32()));
          continue;
        }
        case 54: {
          if (tag !== 434) {
            break;
          }

          message.ports.push(Game.decode(reader, reader.uint32()));
          continue;
        }
        case 55: {
          if (tag !== 442) {
            break;
          }

          message.forks.push(Game.decode(reader, reader.uint32()));
          continue;
        }
        case 56: {
          if (tag !== 450) {
            break;
          }

          message.languageSupports.push(LanguageSupport.decode(reader, reader.uint32()));
          continue;
        }
        case 57: {
          if (tag !== 458) {
            break;
          }

          message.gameLocalizations.push(GameLocalization.decode(reader, reader.uint32()));
          continue;
        }
        case 58: {
          if (tag !== 466) {
            break;
          }

          message.collections.push(Collection.decode(reader, reader.uint32()));
          continue;
        }
        case 59: {
          if (tag !== 474) {
            break;
          }

          message.gameStatus = GameStatus.decode(reader, reader.uint32());
          continue;
        }
        case 60: {
          if (tag !== 482) {
            break;
          }

          message.gameType = GameType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Game {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      ageRatings: globalThis.Array.isArray(object?.ageRatings)
        ? object.ageRatings.map((e: any) => AgeRating.fromJSON(e))
        : [],
      aggregatedRating: isSet(object.aggregatedRating) ? globalThis.Number(object.aggregatedRating) : 0,
      aggregatedRatingCount: isSet(object.aggregatedRatingCount) ? globalThis.Number(object.aggregatedRatingCount) : 0,
      alternativeNames: globalThis.Array.isArray(object?.alternativeNames)
        ? object.alternativeNames.map((e: any) => AlternativeName.fromJSON(e))
        : [],
      artworks: globalThis.Array.isArray(object?.artworks) ? object.artworks.map((e: any) => Artwork.fromJSON(e)) : [],
      bundles: globalThis.Array.isArray(object?.bundles) ? object.bundles.map((e: any) => Game.fromJSON(e)) : [],
      category: isSet(object.category) ? gameCategoryEnumFromJSON(object.category) : 0,
      collection: isSet(object.collection) ? Collection.fromJSON(object.collection) : undefined,
      cover: isSet(object.cover) ? Cover.fromJSON(object.cover) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      dlcs: globalThis.Array.isArray(object?.dlcs) ? object.dlcs.map((e: any) => Game.fromJSON(e)) : [],
      expansions: globalThis.Array.isArray(object?.expansions)
        ? object.expansions.map((e: any) => Game.fromJSON(e))
        : [],
      externalGames: globalThis.Array.isArray(object?.externalGames)
        ? object.externalGames.map((e: any) => ExternalGame.fromJSON(e))
        : [],
      firstReleaseDate: isSet(object.firstReleaseDate) ? fromJsonTimestamp(object.firstReleaseDate) : undefined,
      follows: isSet(object.follows) ? globalThis.Number(object.follows) : 0,
      franchise: isSet(object.franchise) ? Franchise.fromJSON(object.franchise) : undefined,
      franchises: globalThis.Array.isArray(object?.franchises)
        ? object.franchises.map((e: any) => Franchise.fromJSON(e))
        : [],
      gameEngines: globalThis.Array.isArray(object?.gameEngines)
        ? object.gameEngines.map((e: any) => GameEngine.fromJSON(e))
        : [],
      gameModes: globalThis.Array.isArray(object?.gameModes)
        ? object.gameModes.map((e: any) => GameMode.fromJSON(e))
        : [],
      genres: globalThis.Array.isArray(object?.genres) ? object.genres.map((e: any) => Genre.fromJSON(e)) : [],
      hypes: isSet(object.hypes) ? globalThis.Number(object.hypes) : 0,
      involvedCompanies: globalThis.Array.isArray(object?.involvedCompanies)
        ? object.involvedCompanies.map((e: any) => InvolvedCompany.fromJSON(e))
        : [],
      keywords: globalThis.Array.isArray(object?.keywords)
        ? object.keywords.map((e: any) => Keyword.fromJSON(e))
        : [],
      multiplayerModes: globalThis.Array.isArray(object?.multiplayerModes)
        ? object.multiplayerModes.map((e: any) => MultiplayerMode.fromJSON(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parentGame: isSet(object.parentGame) ? Game.fromJSON(object.parentGame) : undefined,
      platforms: globalThis.Array.isArray(object?.platforms)
        ? object.platforms.map((e: any) => Platform.fromJSON(e))
        : [],
      playerPerspectives: globalThis.Array.isArray(object?.playerPerspectives)
        ? object.playerPerspectives.map((e: any) => PlayerPerspective.fromJSON(e))
        : [],
      rating: isSet(object.rating) ? globalThis.Number(object.rating) : 0,
      ratingCount: isSet(object.ratingCount) ? globalThis.Number(object.ratingCount) : 0,
      releaseDates: globalThis.Array.isArray(object?.releaseDates)
        ? object.releaseDates.map((e: any) => ReleaseDate.fromJSON(e))
        : [],
      screenshots: globalThis.Array.isArray(object?.screenshots)
        ? object.screenshots.map((e: any) => Screenshot.fromJSON(e))
        : [],
      similarGames: globalThis.Array.isArray(object?.similarGames)
        ? object.similarGames.map((e: any) => Game.fromJSON(e))
        : [],
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      standaloneExpansions: globalThis.Array.isArray(object?.standaloneExpansions)
        ? object.standaloneExpansions.map((e: any) => Game.fromJSON(e))
        : [],
      status: isSet(object.status) ? gameStatusEnumFromJSON(object.status) : 0,
      storyline: isSet(object.storyline) ? globalThis.String(object.storyline) : "",
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      tags: globalThis.Array.isArray(object?.tags)
        ? object.tags.map((e: any) => globalThis.Number(e))
        : [],
      themes: globalThis.Array.isArray(object?.themes) ? object.themes.map((e: any) => Theme.fromJSON(e)) : [],
      totalRating: isSet(object.totalRating) ? globalThis.Number(object.totalRating) : 0,
      totalRatingCount: isSet(object.totalRatingCount) ? globalThis.Number(object.totalRatingCount) : 0,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      versionParent: isSet(object.versionParent) ? Game.fromJSON(object.versionParent) : undefined,
      versionTitle: isSet(object.versionTitle) ? globalThis.String(object.versionTitle) : "",
      videos: globalThis.Array.isArray(object?.videos) ? object.videos.map((e: any) => GameVideo.fromJSON(e)) : [],
      websites: globalThis.Array.isArray(object?.websites) ? object.websites.map((e: any) => Website.fromJSON(e)) : [],
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      remakes: globalThis.Array.isArray(object?.remakes) ? object.remakes.map((e: any) => Game.fromJSON(e)) : [],
      remasters: globalThis.Array.isArray(object?.remasters) ? object.remasters.map((e: any) => Game.fromJSON(e)) : [],
      expandedGames: globalThis.Array.isArray(object?.expandedGames)
        ? object.expandedGames.map((e: any) => Game.fromJSON(e))
        : [],
      ports: globalThis.Array.isArray(object?.ports)
        ? object.ports.map((e: any) => Game.fromJSON(e))
        : [],
      forks: globalThis.Array.isArray(object?.forks) ? object.forks.map((e: any) => Game.fromJSON(e)) : [],
      languageSupports: globalThis.Array.isArray(object?.languageSupports)
        ? object.languageSupports.map((e: any) => LanguageSupport.fromJSON(e))
        : [],
      gameLocalizations: globalThis.Array.isArray(object?.gameLocalizations)
        ? object.gameLocalizations.map((e: any) => GameLocalization.fromJSON(e))
        : [],
      collections: globalThis.Array.isArray(object?.collections)
        ? object.collections.map((e: any) => Collection.fromJSON(e))
        : [],
      gameStatus: isSet(object.gameStatus) ? GameStatus.fromJSON(object.gameStatus) : undefined,
      gameType: isSet(object.gameType) ? GameType.fromJSON(object.gameType) : undefined,
    };
  },

  toJSON(message: Game): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.ageRatings?.length) {
      obj.ageRatings = message.ageRatings.map((e) => AgeRating.toJSON(e));
    }
    if (message.aggregatedRating !== 0) {
      obj.aggregatedRating = message.aggregatedRating;
    }
    if (message.aggregatedRatingCount !== 0) {
      obj.aggregatedRatingCount = Math.round(message.aggregatedRatingCount);
    }
    if (message.alternativeNames?.length) {
      obj.alternativeNames = message.alternativeNames.map((e) => AlternativeName.toJSON(e));
    }
    if (message.artworks?.length) {
      obj.artworks = message.artworks.map((e) => Artwork.toJSON(e));
    }
    if (message.bundles?.length) {
      obj.bundles = message.bundles.map((e) => Game.toJSON(e));
    }
    if (message.category !== 0) {
      obj.category = gameCategoryEnumToJSON(message.category);
    }
    if (message.collection !== undefined) {
      obj.collection = Collection.toJSON(message.collection);
    }
    if (message.cover !== undefined) {
      obj.cover = Cover.toJSON(message.cover);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.dlcs?.length) {
      obj.dlcs = message.dlcs.map((e) => Game.toJSON(e));
    }
    if (message.expansions?.length) {
      obj.expansions = message.expansions.map((e) => Game.toJSON(e));
    }
    if (message.externalGames?.length) {
      obj.externalGames = message.externalGames.map((e) => ExternalGame.toJSON(e));
    }
    if (message.firstReleaseDate !== undefined) {
      obj.firstReleaseDate = fromTimestamp(message.firstReleaseDate).toISOString();
    }
    if (message.follows !== 0) {
      obj.follows = Math.round(message.follows);
    }
    if (message.franchise !== undefined) {
      obj.franchise = Franchise.toJSON(message.franchise);
    }
    if (message.franchises?.length) {
      obj.franchises = message.franchises.map((e) => Franchise.toJSON(e));
    }
    if (message.gameEngines?.length) {
      obj.gameEngines = message.gameEngines.map((e) => GameEngine.toJSON(e));
    }
    if (message.gameModes?.length) {
      obj.gameModes = message.gameModes.map((e) => GameMode.toJSON(e));
    }
    if (message.genres?.length) {
      obj.genres = message.genres.map((e) => Genre.toJSON(e));
    }
    if (message.hypes !== 0) {
      obj.hypes = Math.round(message.hypes);
    }
    if (message.involvedCompanies?.length) {
      obj.involvedCompanies = message.involvedCompanies.map((e) => InvolvedCompany.toJSON(e));
    }
    if (message.keywords?.length) {
      obj.keywords = message.keywords.map((e) => Keyword.toJSON(e));
    }
    if (message.multiplayerModes?.length) {
      obj.multiplayerModes = message.multiplayerModes.map((e) => MultiplayerMode.toJSON(e));
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parentGame !== undefined) {
      obj.parentGame = Game.toJSON(message.parentGame);
    }
    if (message.platforms?.length) {
      obj.platforms = message.platforms.map((e) => Platform.toJSON(e));
    }
    if (message.playerPerspectives?.length) {
      obj.playerPerspectives = message.playerPerspectives.map((e) => PlayerPerspective.toJSON(e));
    }
    if (message.rating !== 0) {
      obj.rating = message.rating;
    }
    if (message.ratingCount !== 0) {
      obj.ratingCount = Math.round(message.ratingCount);
    }
    if (message.releaseDates?.length) {
      obj.releaseDates = message.releaseDates.map((e) => ReleaseDate.toJSON(e));
    }
    if (message.screenshots?.length) {
      obj.screenshots = message.screenshots.map((e) => Screenshot.toJSON(e));
    }
    if (message.similarGames?.length) {
      obj.similarGames = message.similarGames.map((e) => Game.toJSON(e));
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.standaloneExpansions?.length) {
      obj.standaloneExpansions = message.standaloneExpansions.map((e) => Game.toJSON(e));
    }
    if (message.status !== 0) {
      obj.status = gameStatusEnumToJSON(message.status);
    }
    if (message.storyline !== "") {
      obj.storyline = message.storyline;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => Math.round(e));
    }
    if (message.themes?.length) {
      obj.themes = message.themes.map((e) => Theme.toJSON(e));
    }
    if (message.totalRating !== 0) {
      obj.totalRating = message.totalRating;
    }
    if (message.totalRatingCount !== 0) {
      obj.totalRatingCount = Math.round(message.totalRatingCount);
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.versionParent !== undefined) {
      obj.versionParent = Game.toJSON(message.versionParent);
    }
    if (message.versionTitle !== "") {
      obj.versionTitle = message.versionTitle;
    }
    if (message.videos?.length) {
      obj.videos = message.videos.map((e) => GameVideo.toJSON(e));
    }
    if (message.websites?.length) {
      obj.websites = message.websites.map((e) => Website.toJSON(e));
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.remakes?.length) {
      obj.remakes = message.remakes.map((e) => Game.toJSON(e));
    }
    if (message.remasters?.length) {
      obj.remasters = message.remasters.map((e) => Game.toJSON(e));
    }
    if (message.expandedGames?.length) {
      obj.expandedGames = message.expandedGames.map((e) => Game.toJSON(e));
    }
    if (message.ports?.length) {
      obj.ports = message.ports.map((e) => Game.toJSON(e));
    }
    if (message.forks?.length) {
      obj.forks = message.forks.map((e) => Game.toJSON(e));
    }
    if (message.languageSupports?.length) {
      obj.languageSupports = message.languageSupports.map((e) => LanguageSupport.toJSON(e));
    }
    if (message.gameLocalizations?.length) {
      obj.gameLocalizations = message.gameLocalizations.map((e) => GameLocalization.toJSON(e));
    }
    if (message.collections?.length) {
      obj.collections = message.collections.map((e) => Collection.toJSON(e));
    }
    if (message.gameStatus !== undefined) {
      obj.gameStatus = GameStatus.toJSON(message.gameStatus);
    }
    if (message.gameType !== undefined) {
      obj.gameType = GameType.toJSON(message.gameType);
    }
    return obj;
  },

  create(base?: DeepPartial<Game>): Game {
    return Game.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Game>): Game {
    const message = createBaseGame();
    message.id = object.id ?? 0;
    message.ageRatings = object.ageRatings?.map((e) => AgeRating.fromPartial(e)) || [];
    message.aggregatedRating = object.aggregatedRating ?? 0;
    message.aggregatedRatingCount = object.aggregatedRatingCount ?? 0;
    message.alternativeNames = object.alternativeNames?.map((e) => AlternativeName.fromPartial(e)) || [];
    message.artworks = object.artworks?.map((e) => Artwork.fromPartial(e)) || [];
    message.bundles = object.bundles?.map((e) => Game.fromPartial(e)) || [];
    message.category = object.category ?? 0;
    message.collection = (object.collection !== undefined && object.collection !== null)
      ? Collection.fromPartial(object.collection)
      : undefined;
    message.cover = (object.cover !== undefined && object.cover !== null) ? Cover.fromPartial(object.cover) : undefined;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.dlcs = object.dlcs?.map((e) => Game.fromPartial(e)) || [];
    message.expansions = object.expansions?.map((e) => Game.fromPartial(e)) || [];
    message.externalGames = object.externalGames?.map((e) => ExternalGame.fromPartial(e)) || [];
    message.firstReleaseDate = (object.firstReleaseDate !== undefined && object.firstReleaseDate !== null)
      ? Timestamp.fromPartial(object.firstReleaseDate)
      : undefined;
    message.follows = object.follows ?? 0;
    message.franchise = (object.franchise !== undefined && object.franchise !== null)
      ? Franchise.fromPartial(object.franchise)
      : undefined;
    message.franchises = object.franchises?.map((e) => Franchise.fromPartial(e)) || [];
    message.gameEngines = object.gameEngines?.map((e) => GameEngine.fromPartial(e)) || [];
    message.gameModes = object.gameModes?.map((e) => GameMode.fromPartial(e)) || [];
    message.genres = object.genres?.map((e) => Genre.fromPartial(e)) || [];
    message.hypes = object.hypes ?? 0;
    message.involvedCompanies = object.involvedCompanies?.map((e) => InvolvedCompany.fromPartial(e)) || [];
    message.keywords = object.keywords?.map((e) => Keyword.fromPartial(e)) || [];
    message.multiplayerModes = object.multiplayerModes?.map((e) => MultiplayerMode.fromPartial(e)) || [];
    message.name = object.name ?? "";
    message.parentGame = (object.parentGame !== undefined && object.parentGame !== null)
      ? Game.fromPartial(object.parentGame)
      : undefined;
    message.platforms = object.platforms?.map((e) => Platform.fromPartial(e)) || [];
    message.playerPerspectives = object.playerPerspectives?.map((e) => PlayerPerspective.fromPartial(e)) || [];
    message.rating = object.rating ?? 0;
    message.ratingCount = object.ratingCount ?? 0;
    message.releaseDates = object.releaseDates?.map((e) => ReleaseDate.fromPartial(e)) || [];
    message.screenshots = object.screenshots?.map((e) => Screenshot.fromPartial(e)) || [];
    message.similarGames = object.similarGames?.map((e) => Game.fromPartial(e)) || [];
    message.slug = object.slug ?? "";
    message.standaloneExpansions = object.standaloneExpansions?.map((e) => Game.fromPartial(e)) || [];
    message.status = object.status ?? 0;
    message.storyline = object.storyline ?? "";
    message.summary = object.summary ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    message.themes = object.themes?.map((e) => Theme.fromPartial(e)) || [];
    message.totalRating = object.totalRating ?? 0;
    message.totalRatingCount = object.totalRatingCount ?? 0;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.url = object.url ?? "";
    message.versionParent = (object.versionParent !== undefined && object.versionParent !== null)
      ? Game.fromPartial(object.versionParent)
      : undefined;
    message.versionTitle = object.versionTitle ?? "";
    message.videos = object.videos?.map((e) => GameVideo.fromPartial(e)) || [];
    message.websites = object.websites?.map((e) => Website.fromPartial(e)) || [];
    message.checksum = object.checksum ?? "";
    message.remakes = object.remakes?.map((e) => Game.fromPartial(e)) || [];
    message.remasters = object.remasters?.map((e) => Game.fromPartial(e)) || [];
    message.expandedGames = object.expandedGames?.map((e) => Game.fromPartial(e)) || [];
    message.ports = object.ports?.map((e) => Game.fromPartial(e)) || [];
    message.forks = object.forks?.map((e) => Game.fromPartial(e)) || [];
    message.languageSupports = object.languageSupports?.map((e) => LanguageSupport.fromPartial(e)) || [];
    message.gameLocalizations = object.gameLocalizations?.map((e) => GameLocalization.fromPartial(e)) || [];
    message.collections = object.collections?.map((e) => Collection.fromPartial(e)) || [];
    message.gameStatus = (object.gameStatus !== undefined && object.gameStatus !== null)
      ? GameStatus.fromPartial(object.gameStatus)
      : undefined;
    message.gameType = (object.gameType !== undefined && object.gameType !== null)
      ? GameType.fromPartial(object.gameType)
      : undefined;
    return message;
  },
};

function createBaseGameEngineResult(): GameEngineResult {
  return { gameengines: [] };
}

export const GameEngineResult: MessageFns<GameEngineResult> = {
  encode(message: GameEngineResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gameengines) {
      GameEngine.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameEngineResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameEngineResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gameengines.push(GameEngine.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameEngineResult {
    return {
      gameengines: globalThis.Array.isArray(object?.gameengines)
        ? object.gameengines.map((e: any) => GameEngine.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GameEngineResult): unknown {
    const obj: any = {};
    if (message.gameengines?.length) {
      obj.gameengines = message.gameengines.map((e) => GameEngine.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GameEngineResult>): GameEngineResult {
    return GameEngineResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameEngineResult>): GameEngineResult {
    const message = createBaseGameEngineResult();
    message.gameengines = object.gameengines?.map((e) => GameEngine.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGameEngine(): GameEngine {
  return {
    id: 0,
    companies: [],
    createdAt: undefined,
    description: "",
    logo: undefined,
    name: "",
    platforms: [],
    slug: "",
    updatedAt: undefined,
    url: "",
    checksum: "",
  };
}

export const GameEngine: MessageFns<GameEngine> = {
  encode(message: GameEngine, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    for (const v of message.companies) {
      Company.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.logo !== undefined) {
      GameEngineLogo.encode(message.logo, writer.uint32(42).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    for (const v of message.platforms) {
      Platform.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.slug !== "") {
      writer.uint32(66).string(message.slug);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(74).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(82).string(message.url);
    }
    if (message.checksum !== "") {
      writer.uint32(90).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameEngine {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameEngine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.companies.push(Company.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.logo = GameEngineLogo.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.platforms.push(Platform.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameEngine {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      companies: globalThis.Array.isArray(object?.companies)
        ? object.companies.map((e: any) => Company.fromJSON(e))
        : [],
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      logo: isSet(object.logo) ? GameEngineLogo.fromJSON(object.logo) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      platforms: globalThis.Array.isArray(object?.platforms)
        ? object.platforms.map((e: any) => Platform.fromJSON(e))
        : [],
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: GameEngine): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.companies?.length) {
      obj.companies = message.companies.map((e) => Company.toJSON(e));
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.logo !== undefined) {
      obj.logo = GameEngineLogo.toJSON(message.logo);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.platforms?.length) {
      obj.platforms = message.platforms.map((e) => Platform.toJSON(e));
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<GameEngine>): GameEngine {
    return GameEngine.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameEngine>): GameEngine {
    const message = createBaseGameEngine();
    message.id = object.id ?? 0;
    message.companies = object.companies?.map((e) => Company.fromPartial(e)) || [];
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.description = object.description ?? "";
    message.logo = (object.logo !== undefined && object.logo !== null)
      ? GameEngineLogo.fromPartial(object.logo)
      : undefined;
    message.name = object.name ?? "";
    message.platforms = object.platforms?.map((e) => Platform.fromPartial(e)) || [];
    message.slug = object.slug ?? "";
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.url = object.url ?? "";
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseGameEngineLogoResult(): GameEngineLogoResult {
  return { gameenginelogos: [] };
}

export const GameEngineLogoResult: MessageFns<GameEngineLogoResult> = {
  encode(message: GameEngineLogoResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gameenginelogos) {
      GameEngineLogo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameEngineLogoResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameEngineLogoResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gameenginelogos.push(GameEngineLogo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameEngineLogoResult {
    return {
      gameenginelogos: globalThis.Array.isArray(object?.gameenginelogos)
        ? object.gameenginelogos.map((e: any) => GameEngineLogo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GameEngineLogoResult): unknown {
    const obj: any = {};
    if (message.gameenginelogos?.length) {
      obj.gameenginelogos = message.gameenginelogos.map((e) => GameEngineLogo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GameEngineLogoResult>): GameEngineLogoResult {
    return GameEngineLogoResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameEngineLogoResult>): GameEngineLogoResult {
    const message = createBaseGameEngineLogoResult();
    message.gameenginelogos = object.gameenginelogos?.map((e) => GameEngineLogo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGameEngineLogo(): GameEngineLogo {
  return { id: 0, alphaChannel: false, animated: false, height: 0, imageId: "", url: "", width: 0, checksum: "" };
}

export const GameEngineLogo: MessageFns<GameEngineLogo> = {
  encode(message: GameEngineLogo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.alphaChannel !== false) {
      writer.uint32(16).bool(message.alphaChannel);
    }
    if (message.animated !== false) {
      writer.uint32(24).bool(message.animated);
    }
    if (message.height !== 0) {
      writer.uint32(32).int32(message.height);
    }
    if (message.imageId !== "") {
      writer.uint32(42).string(message.imageId);
    }
    if (message.url !== "") {
      writer.uint32(50).string(message.url);
    }
    if (message.width !== 0) {
      writer.uint32(56).int32(message.width);
    }
    if (message.checksum !== "") {
      writer.uint32(66).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameEngineLogo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameEngineLogo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.alphaChannel = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.animated = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.imageId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameEngineLogo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      alphaChannel: isSet(object.alphaChannel) ? globalThis.Boolean(object.alphaChannel) : false,
      animated: isSet(object.animated) ? globalThis.Boolean(object.animated) : false,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      imageId: isSet(object.imageId) ? globalThis.String(object.imageId) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: GameEngineLogo): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.alphaChannel !== false) {
      obj.alphaChannel = message.alphaChannel;
    }
    if (message.animated !== false) {
      obj.animated = message.animated;
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<GameEngineLogo>): GameEngineLogo {
    return GameEngineLogo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameEngineLogo>): GameEngineLogo {
    const message = createBaseGameEngineLogo();
    message.id = object.id ?? 0;
    message.alphaChannel = object.alphaChannel ?? false;
    message.animated = object.animated ?? false;
    message.height = object.height ?? 0;
    message.imageId = object.imageId ?? "";
    message.url = object.url ?? "";
    message.width = object.width ?? 0;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseGameLocalizationResult(): GameLocalizationResult {
  return { gamelocalizations: [] };
}

export const GameLocalizationResult: MessageFns<GameLocalizationResult> = {
  encode(message: GameLocalizationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gamelocalizations) {
      GameLocalization.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameLocalizationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameLocalizationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gamelocalizations.push(GameLocalization.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameLocalizationResult {
    return {
      gamelocalizations: globalThis.Array.isArray(object?.gamelocalizations)
        ? object.gamelocalizations.map((e: any) => GameLocalization.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GameLocalizationResult): unknown {
    const obj: any = {};
    if (message.gamelocalizations?.length) {
      obj.gamelocalizations = message.gamelocalizations.map((e) => GameLocalization.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GameLocalizationResult>): GameLocalizationResult {
    return GameLocalizationResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameLocalizationResult>): GameLocalizationResult {
    const message = createBaseGameLocalizationResult();
    message.gamelocalizations = object.gamelocalizations?.map((e) => GameLocalization.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGameLocalization(): GameLocalization {
  return {
    id: 0,
    name: "",
    cover: undefined,
    game: undefined,
    region: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    checksum: "",
  };
}

export const GameLocalization: MessageFns<GameLocalization> = {
  encode(message: GameLocalization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.cover !== undefined) {
      Cover.encode(message.cover, writer.uint32(26).fork()).join();
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(34).fork()).join();
    }
    if (message.region !== undefined) {
      Region.encode(message.region, writer.uint32(42).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(50).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(58).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(66).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameLocalization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameLocalization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cover = Cover.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.region = Region.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameLocalization {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      cover: isSet(object.cover) ? Cover.fromJSON(object.cover) : undefined,
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
      region: isSet(object.region) ? Region.fromJSON(object.region) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: GameLocalization): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.cover !== undefined) {
      obj.cover = Cover.toJSON(message.cover);
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    if (message.region !== undefined) {
      obj.region = Region.toJSON(message.region);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<GameLocalization>): GameLocalization {
    return GameLocalization.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameLocalization>): GameLocalization {
    const message = createBaseGameLocalization();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.cover = (object.cover !== undefined && object.cover !== null) ? Cover.fromPartial(object.cover) : undefined;
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    message.region = (object.region !== undefined && object.region !== null)
      ? Region.fromPartial(object.region)
      : undefined;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseGameModeResult(): GameModeResult {
  return { gamemodes: [] };
}

export const GameModeResult: MessageFns<GameModeResult> = {
  encode(message: GameModeResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gamemodes) {
      GameMode.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameModeResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameModeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gamemodes.push(GameMode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameModeResult {
    return {
      gamemodes: globalThis.Array.isArray(object?.gamemodes)
        ? object.gamemodes.map((e: any) => GameMode.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GameModeResult): unknown {
    const obj: any = {};
    if (message.gamemodes?.length) {
      obj.gamemodes = message.gamemodes.map((e) => GameMode.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GameModeResult>): GameModeResult {
    return GameModeResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameModeResult>): GameModeResult {
    const message = createBaseGameModeResult();
    message.gamemodes = object.gamemodes?.map((e) => GameMode.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGameMode(): GameMode {
  return { id: 0, createdAt: undefined, name: "", slug: "", updatedAt: undefined, url: "", checksum: "" };
}

export const GameMode: MessageFns<GameMode> = {
  encode(message: GameMode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(18).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(34).string(message.slug);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(42).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(50).string(message.url);
    }
    if (message.checksum !== "") {
      writer.uint32(58).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameMode {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: GameMode): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<GameMode>): GameMode {
    return GameMode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameMode>): GameMode {
    const message = createBaseGameMode();
    message.id = object.id ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.name = object.name ?? "";
    message.slug = object.slug ?? "";
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.url = object.url ?? "";
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseGameReleaseFormatResult(): GameReleaseFormatResult {
  return { gamereleaseformats: [] };
}

export const GameReleaseFormatResult: MessageFns<GameReleaseFormatResult> = {
  encode(message: GameReleaseFormatResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gamereleaseformats) {
      GameReleaseFormat.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameReleaseFormatResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameReleaseFormatResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gamereleaseformats.push(GameReleaseFormat.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameReleaseFormatResult {
    return {
      gamereleaseformats: globalThis.Array.isArray(object?.gamereleaseformats)
        ? object.gamereleaseformats.map((e: any) => GameReleaseFormat.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GameReleaseFormatResult): unknown {
    const obj: any = {};
    if (message.gamereleaseformats?.length) {
      obj.gamereleaseformats = message.gamereleaseformats.map((e) => GameReleaseFormat.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GameReleaseFormatResult>): GameReleaseFormatResult {
    return GameReleaseFormatResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameReleaseFormatResult>): GameReleaseFormatResult {
    const message = createBaseGameReleaseFormatResult();
    message.gamereleaseformats = object.gamereleaseformats?.map((e) => GameReleaseFormat.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGameReleaseFormat(): GameReleaseFormat {
  return { id: 0, format: "", createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const GameReleaseFormat: MessageFns<GameReleaseFormat> = {
  encode(message: GameReleaseFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.format !== "") {
      writer.uint32(18).string(message.format);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(34).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(42).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameReleaseFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameReleaseFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.format = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameReleaseFormat {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: GameReleaseFormat): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<GameReleaseFormat>): GameReleaseFormat {
    return GameReleaseFormat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameReleaseFormat>): GameReleaseFormat {
    const message = createBaseGameReleaseFormat();
    message.id = object.id ?? 0;
    message.format = object.format ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseGameStatusResult(): GameStatusResult {
  return { gamestatuses: [] };
}

export const GameStatusResult: MessageFns<GameStatusResult> = {
  encode(message: GameStatusResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gamestatuses) {
      GameStatus.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameStatusResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameStatusResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gamestatuses.push(GameStatus.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameStatusResult {
    return {
      gamestatuses: globalThis.Array.isArray(object?.gamestatuses)
        ? object.gamestatuses.map((e: any) => GameStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GameStatusResult): unknown {
    const obj: any = {};
    if (message.gamestatuses?.length) {
      obj.gamestatuses = message.gamestatuses.map((e) => GameStatus.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GameStatusResult>): GameStatusResult {
    return GameStatusResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameStatusResult>): GameStatusResult {
    const message = createBaseGameStatusResult();
    message.gamestatuses = object.gamestatuses?.map((e) => GameStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGameStatus(): GameStatus {
  return { id: 0, status: "", createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const GameStatus: MessageFns<GameStatus> = {
  encode(message: GameStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(34).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(42).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameStatus {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: GameStatus): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<GameStatus>): GameStatus {
    return GameStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameStatus>): GameStatus {
    const message = createBaseGameStatus();
    message.id = object.id ?? 0;
    message.status = object.status ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseGameTimeToBeatResult(): GameTimeToBeatResult {
  return { gametimetobeats: [] };
}

export const GameTimeToBeatResult: MessageFns<GameTimeToBeatResult> = {
  encode(message: GameTimeToBeatResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gametimetobeats) {
      GameTimeToBeat.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameTimeToBeatResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameTimeToBeatResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gametimetobeats.push(GameTimeToBeat.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameTimeToBeatResult {
    return {
      gametimetobeats: globalThis.Array.isArray(object?.gametimetobeats)
        ? object.gametimetobeats.map((e: any) => GameTimeToBeat.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GameTimeToBeatResult): unknown {
    const obj: any = {};
    if (message.gametimetobeats?.length) {
      obj.gametimetobeats = message.gametimetobeats.map((e) => GameTimeToBeat.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GameTimeToBeatResult>): GameTimeToBeatResult {
    return GameTimeToBeatResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameTimeToBeatResult>): GameTimeToBeatResult {
    const message = createBaseGameTimeToBeatResult();
    message.gametimetobeats = object.gametimetobeats?.map((e) => GameTimeToBeat.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGameTimeToBeat(): GameTimeToBeat {
  return {
    id: 0,
    gameId: 0,
    hastily: 0,
    normally: 0,
    completely: 0,
    count: 0,
    createdAt: undefined,
    updatedAt: undefined,
    checksum: "",
  };
}

export const GameTimeToBeat: MessageFns<GameTimeToBeat> = {
  encode(message: GameTimeToBeat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.gameId !== 0) {
      writer.uint32(16).int32(message.gameId);
    }
    if (message.hastily !== 0) {
      writer.uint32(24).int32(message.hastily);
    }
    if (message.normally !== 0) {
      writer.uint32(32).int32(message.normally);
    }
    if (message.completely !== 0) {
      writer.uint32(40).int32(message.completely);
    }
    if (message.count !== 0) {
      writer.uint32(48).int32(message.count);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(58).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(66).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(74).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameTimeToBeat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameTimeToBeat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gameId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hastily = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.normally = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.completely = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameTimeToBeat {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      gameId: isSet(object.gameId) ? globalThis.Number(object.gameId) : 0,
      hastily: isSet(object.hastily) ? globalThis.Number(object.hastily) : 0,
      normally: isSet(object.normally) ? globalThis.Number(object.normally) : 0,
      completely: isSet(object.completely) ? globalThis.Number(object.completely) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: GameTimeToBeat): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.gameId !== 0) {
      obj.gameId = Math.round(message.gameId);
    }
    if (message.hastily !== 0) {
      obj.hastily = Math.round(message.hastily);
    }
    if (message.normally !== 0) {
      obj.normally = Math.round(message.normally);
    }
    if (message.completely !== 0) {
      obj.completely = Math.round(message.completely);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<GameTimeToBeat>): GameTimeToBeat {
    return GameTimeToBeat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameTimeToBeat>): GameTimeToBeat {
    const message = createBaseGameTimeToBeat();
    message.id = object.id ?? 0;
    message.gameId = object.gameId ?? 0;
    message.hastily = object.hastily ?? 0;
    message.normally = object.normally ?? 0;
    message.completely = object.completely ?? 0;
    message.count = object.count ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseGameTypeResult(): GameTypeResult {
  return { gametypes: [] };
}

export const GameTypeResult: MessageFns<GameTypeResult> = {
  encode(message: GameTypeResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gametypes) {
      GameType.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameTypeResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameTypeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gametypes.push(GameType.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameTypeResult {
    return {
      gametypes: globalThis.Array.isArray(object?.gametypes)
        ? object.gametypes.map((e: any) => GameType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GameTypeResult): unknown {
    const obj: any = {};
    if (message.gametypes?.length) {
      obj.gametypes = message.gametypes.map((e) => GameType.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GameTypeResult>): GameTypeResult {
    return GameTypeResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameTypeResult>): GameTypeResult {
    const message = createBaseGameTypeResult();
    message.gametypes = object.gametypes?.map((e) => GameType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGameType(): GameType {
  return { id: 0, type: "", createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const GameType: MessageFns<GameType> = {
  encode(message: GameType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(34).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(42).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameType {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: GameType): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<GameType>): GameType {
    return GameType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameType>): GameType {
    const message = createBaseGameType();
    message.id = object.id ?? 0;
    message.type = object.type ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseGameVersionResult(): GameVersionResult {
  return { gameversions: [] };
}

export const GameVersionResult: MessageFns<GameVersionResult> = {
  encode(message: GameVersionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gameversions) {
      GameVersion.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameVersionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameVersionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gameversions.push(GameVersion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameVersionResult {
    return {
      gameversions: globalThis.Array.isArray(object?.gameversions)
        ? object.gameversions.map((e: any) => GameVersion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GameVersionResult): unknown {
    const obj: any = {};
    if (message.gameversions?.length) {
      obj.gameversions = message.gameversions.map((e) => GameVersion.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GameVersionResult>): GameVersionResult {
    return GameVersionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameVersionResult>): GameVersionResult {
    const message = createBaseGameVersionResult();
    message.gameversions = object.gameversions?.map((e) => GameVersion.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGameVersion(): GameVersion {
  return {
    id: 0,
    createdAt: undefined,
    features: [],
    game: undefined,
    games: [],
    updatedAt: undefined,
    url: "",
    checksum: "",
  };
}

export const GameVersion: MessageFns<GameVersion> = {
  encode(message: GameVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(18).fork()).join();
    }
    for (const v of message.features) {
      GameVersionFeature.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(34).fork()).join();
    }
    for (const v of message.games) {
      Game.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(50).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(58).string(message.url);
    }
    if (message.checksum !== "") {
      writer.uint32(66).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.features.push(GameVersionFeature.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.games.push(Game.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameVersion {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      features: globalThis.Array.isArray(object?.features)
        ? object.features.map((e: any) => GameVersionFeature.fromJSON(e))
        : [],
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
      games: globalThis.Array.isArray(object?.games) ? object.games.map((e: any) => Game.fromJSON(e)) : [],
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: GameVersion): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.features?.length) {
      obj.features = message.features.map((e) => GameVersionFeature.toJSON(e));
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    if (message.games?.length) {
      obj.games = message.games.map((e) => Game.toJSON(e));
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<GameVersion>): GameVersion {
    return GameVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameVersion>): GameVersion {
    const message = createBaseGameVersion();
    message.id = object.id ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.features = object.features?.map((e) => GameVersionFeature.fromPartial(e)) || [];
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    message.games = object.games?.map((e) => Game.fromPartial(e)) || [];
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.url = object.url ?? "";
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseGameVersionFeatureResult(): GameVersionFeatureResult {
  return { gameversionfeatures: [] };
}

export const GameVersionFeatureResult: MessageFns<GameVersionFeatureResult> = {
  encode(message: GameVersionFeatureResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gameversionfeatures) {
      GameVersionFeature.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameVersionFeatureResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameVersionFeatureResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gameversionfeatures.push(GameVersionFeature.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameVersionFeatureResult {
    return {
      gameversionfeatures: globalThis.Array.isArray(object?.gameversionfeatures)
        ? object.gameversionfeatures.map((e: any) => GameVersionFeature.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GameVersionFeatureResult): unknown {
    const obj: any = {};
    if (message.gameversionfeatures?.length) {
      obj.gameversionfeatures = message.gameversionfeatures.map((e) => GameVersionFeature.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GameVersionFeatureResult>): GameVersionFeatureResult {
    return GameVersionFeatureResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameVersionFeatureResult>): GameVersionFeatureResult {
    const message = createBaseGameVersionFeatureResult();
    message.gameversionfeatures = object.gameversionfeatures?.map((e) => GameVersionFeature.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGameVersionFeature(): GameVersionFeature {
  return { id: 0, category: 0, description: "", position: 0, title: "", values: [], checksum: "" };
}

export const GameVersionFeature: MessageFns<GameVersionFeature> = {
  encode(message: GameVersionFeature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.category !== 0) {
      writer.uint32(16).int32(message.category);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.position !== 0) {
      writer.uint32(32).int32(message.position);
    }
    if (message.title !== "") {
      writer.uint32(42).string(message.title);
    }
    for (const v of message.values) {
      GameVersionFeatureValue.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(58).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameVersionFeature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameVersionFeature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.position = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.values.push(GameVersionFeatureValue.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameVersionFeature {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      category: isSet(object.category) ? gameVersionFeatureCategoryEnumFromJSON(object.category) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      position: isSet(object.position) ? globalThis.Number(object.position) : 0,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      values: globalThis.Array.isArray(object?.values)
        ? object.values.map((e: any) => GameVersionFeatureValue.fromJSON(e))
        : [],
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: GameVersionFeature): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.category !== 0) {
      obj.category = gameVersionFeatureCategoryEnumToJSON(message.category);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.position !== 0) {
      obj.position = Math.round(message.position);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.values?.length) {
      obj.values = message.values.map((e) => GameVersionFeatureValue.toJSON(e));
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<GameVersionFeature>): GameVersionFeature {
    return GameVersionFeature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameVersionFeature>): GameVersionFeature {
    const message = createBaseGameVersionFeature();
    message.id = object.id ?? 0;
    message.category = object.category ?? 0;
    message.description = object.description ?? "";
    message.position = object.position ?? 0;
    message.title = object.title ?? "";
    message.values = object.values?.map((e) => GameVersionFeatureValue.fromPartial(e)) || [];
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseGameVersionFeatureValueResult(): GameVersionFeatureValueResult {
  return { gameversionfeaturevalues: [] };
}

export const GameVersionFeatureValueResult: MessageFns<GameVersionFeatureValueResult> = {
  encode(message: GameVersionFeatureValueResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gameversionfeaturevalues) {
      GameVersionFeatureValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameVersionFeatureValueResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameVersionFeatureValueResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gameversionfeaturevalues.push(GameVersionFeatureValue.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameVersionFeatureValueResult {
    return {
      gameversionfeaturevalues: globalThis.Array.isArray(object?.gameversionfeaturevalues)
        ? object.gameversionfeaturevalues.map((e: any) => GameVersionFeatureValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GameVersionFeatureValueResult): unknown {
    const obj: any = {};
    if (message.gameversionfeaturevalues?.length) {
      obj.gameversionfeaturevalues = message.gameversionfeaturevalues.map((e) => GameVersionFeatureValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GameVersionFeatureValueResult>): GameVersionFeatureValueResult {
    return GameVersionFeatureValueResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameVersionFeatureValueResult>): GameVersionFeatureValueResult {
    const message = createBaseGameVersionFeatureValueResult();
    message.gameversionfeaturevalues =
      object.gameversionfeaturevalues?.map((e) => GameVersionFeatureValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGameVersionFeatureValue(): GameVersionFeatureValue {
  return { id: 0, game: undefined, gameFeature: undefined, includedFeature: 0, note: "", checksum: "" };
}

export const GameVersionFeatureValue: MessageFns<GameVersionFeatureValue> = {
  encode(message: GameVersionFeatureValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(18).fork()).join();
    }
    if (message.gameFeature !== undefined) {
      GameVersionFeature.encode(message.gameFeature, writer.uint32(26).fork()).join();
    }
    if (message.includedFeature !== 0) {
      writer.uint32(32).int32(message.includedFeature);
    }
    if (message.note !== "") {
      writer.uint32(42).string(message.note);
    }
    if (message.checksum !== "") {
      writer.uint32(50).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameVersionFeatureValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameVersionFeatureValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gameFeature = GameVersionFeature.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.includedFeature = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.note = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameVersionFeatureValue {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
      gameFeature: isSet(object.gameFeature) ? GameVersionFeature.fromJSON(object.gameFeature) : undefined,
      includedFeature: isSet(object.includedFeature)
        ? gameVersionFeatureValueIncludedFeatureEnumFromJSON(object.includedFeature)
        : 0,
      note: isSet(object.note) ? globalThis.String(object.note) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: GameVersionFeatureValue): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    if (message.gameFeature !== undefined) {
      obj.gameFeature = GameVersionFeature.toJSON(message.gameFeature);
    }
    if (message.includedFeature !== 0) {
      obj.includedFeature = gameVersionFeatureValueIncludedFeatureEnumToJSON(message.includedFeature);
    }
    if (message.note !== "") {
      obj.note = message.note;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<GameVersionFeatureValue>): GameVersionFeatureValue {
    return GameVersionFeatureValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameVersionFeatureValue>): GameVersionFeatureValue {
    const message = createBaseGameVersionFeatureValue();
    message.id = object.id ?? 0;
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    message.gameFeature = (object.gameFeature !== undefined && object.gameFeature !== null)
      ? GameVersionFeature.fromPartial(object.gameFeature)
      : undefined;
    message.includedFeature = object.includedFeature ?? 0;
    message.note = object.note ?? "";
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseGameVideoResult(): GameVideoResult {
  return { gamevideos: [] };
}

export const GameVideoResult: MessageFns<GameVideoResult> = {
  encode(message: GameVideoResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gamevideos) {
      GameVideo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameVideoResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameVideoResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gamevideos.push(GameVideo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameVideoResult {
    return {
      gamevideos: globalThis.Array.isArray(object?.gamevideos)
        ? object.gamevideos.map((e: any) => GameVideo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GameVideoResult): unknown {
    const obj: any = {};
    if (message.gamevideos?.length) {
      obj.gamevideos = message.gamevideos.map((e) => GameVideo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GameVideoResult>): GameVideoResult {
    return GameVideoResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameVideoResult>): GameVideoResult {
    const message = createBaseGameVideoResult();
    message.gamevideos = object.gamevideos?.map((e) => GameVideo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGameVideo(): GameVideo {
  return { id: 0, game: undefined, name: "", videoId: "", checksum: "" };
}

export const GameVideo: MessageFns<GameVideo> = {
  encode(message: GameVideo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(18).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.videoId !== "") {
      writer.uint32(34).string(message.videoId);
    }
    if (message.checksum !== "") {
      writer.uint32(42).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameVideo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameVideo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.videoId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameVideo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      videoId: isSet(object.videoId) ? globalThis.String(object.videoId) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: GameVideo): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.videoId !== "") {
      obj.videoId = message.videoId;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<GameVideo>): GameVideo {
    return GameVideo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GameVideo>): GameVideo {
    const message = createBaseGameVideo();
    message.id = object.id ?? 0;
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    message.name = object.name ?? "";
    message.videoId = object.videoId ?? "";
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseGenreResult(): GenreResult {
  return { genres: [] };
}

export const GenreResult: MessageFns<GenreResult> = {
  encode(message: GenreResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.genres) {
      Genre.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenreResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenreResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.genres.push(Genre.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenreResult {
    return { genres: globalThis.Array.isArray(object?.genres) ? object.genres.map((e: any) => Genre.fromJSON(e)) : [] };
  },

  toJSON(message: GenreResult): unknown {
    const obj: any = {};
    if (message.genres?.length) {
      obj.genres = message.genres.map((e) => Genre.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GenreResult>): GenreResult {
    return GenreResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenreResult>): GenreResult {
    const message = createBaseGenreResult();
    message.genres = object.genres?.map((e) => Genre.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenre(): Genre {
  return { id: 0, createdAt: undefined, name: "", slug: "", updatedAt: undefined, url: "", checksum: "" };
}

export const Genre: MessageFns<Genre> = {
  encode(message: Genre, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(18).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(34).string(message.slug);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(42).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(50).string(message.url);
    }
    if (message.checksum !== "") {
      writer.uint32(58).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Genre {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenre();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Genre {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: Genre): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<Genre>): Genre {
    return Genre.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Genre>): Genre {
    const message = createBaseGenre();
    message.id = object.id ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.name = object.name ?? "";
    message.slug = object.slug ?? "";
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.url = object.url ?? "";
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseInvolvedCompanyResult(): InvolvedCompanyResult {
  return { involvedcompanies: [] };
}

export const InvolvedCompanyResult: MessageFns<InvolvedCompanyResult> = {
  encode(message: InvolvedCompanyResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.involvedcompanies) {
      InvolvedCompany.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvolvedCompanyResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvolvedCompanyResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.involvedcompanies.push(InvolvedCompany.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvolvedCompanyResult {
    return {
      involvedcompanies: globalThis.Array.isArray(object?.involvedcompanies)
        ? object.involvedcompanies.map((e: any) => InvolvedCompany.fromJSON(e))
        : [],
    };
  },

  toJSON(message: InvolvedCompanyResult): unknown {
    const obj: any = {};
    if (message.involvedcompanies?.length) {
      obj.involvedcompanies = message.involvedcompanies.map((e) => InvolvedCompany.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<InvolvedCompanyResult>): InvolvedCompanyResult {
    return InvolvedCompanyResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvolvedCompanyResult>): InvolvedCompanyResult {
    const message = createBaseInvolvedCompanyResult();
    message.involvedcompanies = object.involvedcompanies?.map((e) => InvolvedCompany.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInvolvedCompany(): InvolvedCompany {
  return {
    id: 0,
    company: undefined,
    createdAt: undefined,
    developer: false,
    game: undefined,
    porting: false,
    publisher: false,
    supporting: false,
    updatedAt: undefined,
    checksum: "",
  };
}

export const InvolvedCompany: MessageFns<InvolvedCompany> = {
  encode(message: InvolvedCompany, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.company !== undefined) {
      Company.encode(message.company, writer.uint32(18).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.developer !== false) {
      writer.uint32(32).bool(message.developer);
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(42).fork()).join();
    }
    if (message.porting !== false) {
      writer.uint32(48).bool(message.porting);
    }
    if (message.publisher !== false) {
      writer.uint32(56).bool(message.publisher);
    }
    if (message.supporting !== false) {
      writer.uint32(64).bool(message.supporting);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(74).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(82).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvolvedCompany {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvolvedCompany();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.company = Company.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.developer = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.porting = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.publisher = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.supporting = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvolvedCompany {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      company: isSet(object.company) ? Company.fromJSON(object.company) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      developer: isSet(object.developer) ? globalThis.Boolean(object.developer) : false,
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
      porting: isSet(object.porting) ? globalThis.Boolean(object.porting) : false,
      publisher: isSet(object.publisher) ? globalThis.Boolean(object.publisher) : false,
      supporting: isSet(object.supporting) ? globalThis.Boolean(object.supporting) : false,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: InvolvedCompany): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.company !== undefined) {
      obj.company = Company.toJSON(message.company);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.developer !== false) {
      obj.developer = message.developer;
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    if (message.porting !== false) {
      obj.porting = message.porting;
    }
    if (message.publisher !== false) {
      obj.publisher = message.publisher;
    }
    if (message.supporting !== false) {
      obj.supporting = message.supporting;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<InvolvedCompany>): InvolvedCompany {
    return InvolvedCompany.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvolvedCompany>): InvolvedCompany {
    const message = createBaseInvolvedCompany();
    message.id = object.id ?? 0;
    message.company = (object.company !== undefined && object.company !== null)
      ? Company.fromPartial(object.company)
      : undefined;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.developer = object.developer ?? false;
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    message.porting = object.porting ?? false;
    message.publisher = object.publisher ?? false;
    message.supporting = object.supporting ?? false;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseKeywordResult(): KeywordResult {
  return { keywords: [] };
}

export const KeywordResult: MessageFns<KeywordResult> = {
  encode(message: KeywordResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keywords) {
      Keyword.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeywordResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeywordResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keywords.push(Keyword.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeywordResult {
    return {
      keywords: globalThis.Array.isArray(object?.keywords) ? object.keywords.map((e: any) => Keyword.fromJSON(e)) : [],
    };
  },

  toJSON(message: KeywordResult): unknown {
    const obj: any = {};
    if (message.keywords?.length) {
      obj.keywords = message.keywords.map((e) => Keyword.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<KeywordResult>): KeywordResult {
    return KeywordResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeywordResult>): KeywordResult {
    const message = createBaseKeywordResult();
    message.keywords = object.keywords?.map((e) => Keyword.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKeyword(): Keyword {
  return { id: 0, createdAt: undefined, name: "", slug: "", updatedAt: undefined, url: "", checksum: "" };
}

export const Keyword: MessageFns<Keyword> = {
  encode(message: Keyword, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(18).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(34).string(message.slug);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(42).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(50).string(message.url);
    }
    if (message.checksum !== "") {
      writer.uint32(58).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Keyword {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyword();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Keyword {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: Keyword): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<Keyword>): Keyword {
    return Keyword.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Keyword>): Keyword {
    const message = createBaseKeyword();
    message.id = object.id ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.name = object.name ?? "";
    message.slug = object.slug ?? "";
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.url = object.url ?? "";
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseLanguageResult(): LanguageResult {
  return { languages: [] };
}

export const LanguageResult: MessageFns<LanguageResult> = {
  encode(message: LanguageResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.languages) {
      Language.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LanguageResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLanguageResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.languages.push(Language.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LanguageResult {
    return {
      languages: globalThis.Array.isArray(object?.languages)
        ? object.languages.map((e: any) => Language.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LanguageResult): unknown {
    const obj: any = {};
    if (message.languages?.length) {
      obj.languages = message.languages.map((e) => Language.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LanguageResult>): LanguageResult {
    return LanguageResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LanguageResult>): LanguageResult {
    const message = createBaseLanguageResult();
    message.languages = object.languages?.map((e) => Language.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLanguage(): Language {
  return { id: 0, name: "", nativeName: "", locale: "", createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const Language: MessageFns<Language> = {
  encode(message: Language, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.nativeName !== "") {
      writer.uint32(26).string(message.nativeName);
    }
    if (message.locale !== "") {
      writer.uint32(34).string(message.locale);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(42).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(50).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(58).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Language {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLanguage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nativeName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.locale = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Language {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nativeName: isSet(object.nativeName) ? globalThis.String(object.nativeName) : "",
      locale: isSet(object.locale) ? globalThis.String(object.locale) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: Language): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nativeName !== "") {
      obj.nativeName = message.nativeName;
    }
    if (message.locale !== "") {
      obj.locale = message.locale;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<Language>): Language {
    return Language.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Language>): Language {
    const message = createBaseLanguage();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.nativeName = object.nativeName ?? "";
    message.locale = object.locale ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseLanguageSupportResult(): LanguageSupportResult {
  return { languagesupports: [] };
}

export const LanguageSupportResult: MessageFns<LanguageSupportResult> = {
  encode(message: LanguageSupportResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.languagesupports) {
      LanguageSupport.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LanguageSupportResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLanguageSupportResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.languagesupports.push(LanguageSupport.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LanguageSupportResult {
    return {
      languagesupports: globalThis.Array.isArray(object?.languagesupports)
        ? object.languagesupports.map((e: any) => LanguageSupport.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LanguageSupportResult): unknown {
    const obj: any = {};
    if (message.languagesupports?.length) {
      obj.languagesupports = message.languagesupports.map((e) => LanguageSupport.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LanguageSupportResult>): LanguageSupportResult {
    return LanguageSupportResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LanguageSupportResult>): LanguageSupportResult {
    const message = createBaseLanguageSupportResult();
    message.languagesupports = object.languagesupports?.map((e) => LanguageSupport.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLanguageSupport(): LanguageSupport {
  return {
    id: 0,
    game: undefined,
    language: undefined,
    languageSupportType: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    checksum: "",
  };
}

export const LanguageSupport: MessageFns<LanguageSupport> = {
  encode(message: LanguageSupport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(18).fork()).join();
    }
    if (message.language !== undefined) {
      Language.encode(message.language, writer.uint32(26).fork()).join();
    }
    if (message.languageSupportType !== undefined) {
      LanguageSupportType.encode(message.languageSupportType, writer.uint32(34).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(42).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(50).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(58).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LanguageSupport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLanguageSupport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.language = Language.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.languageSupportType = LanguageSupportType.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LanguageSupport {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
      language: isSet(object.language) ? Language.fromJSON(object.language) : undefined,
      languageSupportType: isSet(object.languageSupportType)
        ? LanguageSupportType.fromJSON(object.languageSupportType)
        : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: LanguageSupport): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    if (message.language !== undefined) {
      obj.language = Language.toJSON(message.language);
    }
    if (message.languageSupportType !== undefined) {
      obj.languageSupportType = LanguageSupportType.toJSON(message.languageSupportType);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<LanguageSupport>): LanguageSupport {
    return LanguageSupport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LanguageSupport>): LanguageSupport {
    const message = createBaseLanguageSupport();
    message.id = object.id ?? 0;
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    message.language = (object.language !== undefined && object.language !== null)
      ? Language.fromPartial(object.language)
      : undefined;
    message.languageSupportType = (object.languageSupportType !== undefined && object.languageSupportType !== null)
      ? LanguageSupportType.fromPartial(object.languageSupportType)
      : undefined;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseLanguageSupportTypeResult(): LanguageSupportTypeResult {
  return { languagesupporttypes: [] };
}

export const LanguageSupportTypeResult: MessageFns<LanguageSupportTypeResult> = {
  encode(message: LanguageSupportTypeResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.languagesupporttypes) {
      LanguageSupportType.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LanguageSupportTypeResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLanguageSupportTypeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.languagesupporttypes.push(LanguageSupportType.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LanguageSupportTypeResult {
    return {
      languagesupporttypes: globalThis.Array.isArray(object?.languagesupporttypes)
        ? object.languagesupporttypes.map((e: any) => LanguageSupportType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LanguageSupportTypeResult): unknown {
    const obj: any = {};
    if (message.languagesupporttypes?.length) {
      obj.languagesupporttypes = message.languagesupporttypes.map((e) => LanguageSupportType.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LanguageSupportTypeResult>): LanguageSupportTypeResult {
    return LanguageSupportTypeResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LanguageSupportTypeResult>): LanguageSupportTypeResult {
    const message = createBaseLanguageSupportTypeResult();
    message.languagesupporttypes = object.languagesupporttypes?.map((e) => LanguageSupportType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLanguageSupportType(): LanguageSupportType {
  return { id: 0, name: "", createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const LanguageSupportType: MessageFns<LanguageSupportType> = {
  encode(message: LanguageSupportType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(34).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(42).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LanguageSupportType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLanguageSupportType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LanguageSupportType {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: LanguageSupportType): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<LanguageSupportType>): LanguageSupportType {
    return LanguageSupportType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LanguageSupportType>): LanguageSupportType {
    const message = createBaseLanguageSupportType();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseMultiplayerModeResult(): MultiplayerModeResult {
  return { multiplayermodes: [] };
}

export const MultiplayerModeResult: MessageFns<MultiplayerModeResult> = {
  encode(message: MultiplayerModeResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.multiplayermodes) {
      MultiplayerMode.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiplayerModeResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiplayerModeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.multiplayermodes.push(MultiplayerMode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiplayerModeResult {
    return {
      multiplayermodes: globalThis.Array.isArray(object?.multiplayermodes)
        ? object.multiplayermodes.map((e: any) => MultiplayerMode.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MultiplayerModeResult): unknown {
    const obj: any = {};
    if (message.multiplayermodes?.length) {
      obj.multiplayermodes = message.multiplayermodes.map((e) => MultiplayerMode.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MultiplayerModeResult>): MultiplayerModeResult {
    return MultiplayerModeResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MultiplayerModeResult>): MultiplayerModeResult {
    const message = createBaseMultiplayerModeResult();
    message.multiplayermodes = object.multiplayermodes?.map((e) => MultiplayerMode.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMultiplayerMode(): MultiplayerMode {
  return {
    id: 0,
    campaigncoop: false,
    dropin: false,
    game: undefined,
    lancoop: false,
    offlinecoop: false,
    offlinecoopmax: 0,
    offlinemax: 0,
    onlinecoop: false,
    onlinecoopmax: 0,
    onlinemax: 0,
    platform: undefined,
    splitscreen: false,
    splitscreenonline: false,
    checksum: "",
  };
}

export const MultiplayerMode: MessageFns<MultiplayerMode> = {
  encode(message: MultiplayerMode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.campaigncoop !== false) {
      writer.uint32(16).bool(message.campaigncoop);
    }
    if (message.dropin !== false) {
      writer.uint32(24).bool(message.dropin);
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(34).fork()).join();
    }
    if (message.lancoop !== false) {
      writer.uint32(40).bool(message.lancoop);
    }
    if (message.offlinecoop !== false) {
      writer.uint32(48).bool(message.offlinecoop);
    }
    if (message.offlinecoopmax !== 0) {
      writer.uint32(56).int32(message.offlinecoopmax);
    }
    if (message.offlinemax !== 0) {
      writer.uint32(64).int32(message.offlinemax);
    }
    if (message.onlinecoop !== false) {
      writer.uint32(72).bool(message.onlinecoop);
    }
    if (message.onlinecoopmax !== 0) {
      writer.uint32(80).int32(message.onlinecoopmax);
    }
    if (message.onlinemax !== 0) {
      writer.uint32(88).int32(message.onlinemax);
    }
    if (message.platform !== undefined) {
      Platform.encode(message.platform, writer.uint32(98).fork()).join();
    }
    if (message.splitscreen !== false) {
      writer.uint32(104).bool(message.splitscreen);
    }
    if (message.splitscreenonline !== false) {
      writer.uint32(112).bool(message.splitscreenonline);
    }
    if (message.checksum !== "") {
      writer.uint32(122).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiplayerMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiplayerMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.campaigncoop = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.dropin = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.lancoop = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.offlinecoop = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.offlinecoopmax = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.offlinemax = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.onlinecoop = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.onlinecoopmax = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.onlinemax = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.platform = Platform.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.splitscreen = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.splitscreenonline = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiplayerMode {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      campaigncoop: isSet(object.campaigncoop) ? globalThis.Boolean(object.campaigncoop) : false,
      dropin: isSet(object.dropin) ? globalThis.Boolean(object.dropin) : false,
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
      lancoop: isSet(object.lancoop) ? globalThis.Boolean(object.lancoop) : false,
      offlinecoop: isSet(object.offlinecoop) ? globalThis.Boolean(object.offlinecoop) : false,
      offlinecoopmax: isSet(object.offlinecoopmax) ? globalThis.Number(object.offlinecoopmax) : 0,
      offlinemax: isSet(object.offlinemax) ? globalThis.Number(object.offlinemax) : 0,
      onlinecoop: isSet(object.onlinecoop) ? globalThis.Boolean(object.onlinecoop) : false,
      onlinecoopmax: isSet(object.onlinecoopmax) ? globalThis.Number(object.onlinecoopmax) : 0,
      onlinemax: isSet(object.onlinemax) ? globalThis.Number(object.onlinemax) : 0,
      platform: isSet(object.platform) ? Platform.fromJSON(object.platform) : undefined,
      splitscreen: isSet(object.splitscreen) ? globalThis.Boolean(object.splitscreen) : false,
      splitscreenonline: isSet(object.splitscreenonline) ? globalThis.Boolean(object.splitscreenonline) : false,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: MultiplayerMode): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.campaigncoop !== false) {
      obj.campaigncoop = message.campaigncoop;
    }
    if (message.dropin !== false) {
      obj.dropin = message.dropin;
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    if (message.lancoop !== false) {
      obj.lancoop = message.lancoop;
    }
    if (message.offlinecoop !== false) {
      obj.offlinecoop = message.offlinecoop;
    }
    if (message.offlinecoopmax !== 0) {
      obj.offlinecoopmax = Math.round(message.offlinecoopmax);
    }
    if (message.offlinemax !== 0) {
      obj.offlinemax = Math.round(message.offlinemax);
    }
    if (message.onlinecoop !== false) {
      obj.onlinecoop = message.onlinecoop;
    }
    if (message.onlinecoopmax !== 0) {
      obj.onlinecoopmax = Math.round(message.onlinecoopmax);
    }
    if (message.onlinemax !== 0) {
      obj.onlinemax = Math.round(message.onlinemax);
    }
    if (message.platform !== undefined) {
      obj.platform = Platform.toJSON(message.platform);
    }
    if (message.splitscreen !== false) {
      obj.splitscreen = message.splitscreen;
    }
    if (message.splitscreenonline !== false) {
      obj.splitscreenonline = message.splitscreenonline;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<MultiplayerMode>): MultiplayerMode {
    return MultiplayerMode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MultiplayerMode>): MultiplayerMode {
    const message = createBaseMultiplayerMode();
    message.id = object.id ?? 0;
    message.campaigncoop = object.campaigncoop ?? false;
    message.dropin = object.dropin ?? false;
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    message.lancoop = object.lancoop ?? false;
    message.offlinecoop = object.offlinecoop ?? false;
    message.offlinecoopmax = object.offlinecoopmax ?? 0;
    message.offlinemax = object.offlinemax ?? 0;
    message.onlinecoop = object.onlinecoop ?? false;
    message.onlinecoopmax = object.onlinecoopmax ?? 0;
    message.onlinemax = object.onlinemax ?? 0;
    message.platform = (object.platform !== undefined && object.platform !== null)
      ? Platform.fromPartial(object.platform)
      : undefined;
    message.splitscreen = object.splitscreen ?? false;
    message.splitscreenonline = object.splitscreenonline ?? false;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseNetworkTypeResult(): NetworkTypeResult {
  return { networktypes: [] };
}

export const NetworkTypeResult: MessageFns<NetworkTypeResult> = {
  encode(message: NetworkTypeResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.networktypes) {
      NetworkType.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkTypeResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkTypeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.networktypes.push(NetworkType.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkTypeResult {
    return {
      networktypes: globalThis.Array.isArray(object?.networktypes)
        ? object.networktypes.map((e: any) => NetworkType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NetworkTypeResult): unknown {
    const obj: any = {};
    if (message.networktypes?.length) {
      obj.networktypes = message.networktypes.map((e) => NetworkType.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkTypeResult>): NetworkTypeResult {
    return NetworkTypeResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkTypeResult>): NetworkTypeResult {
    const message = createBaseNetworkTypeResult();
    message.networktypes = object.networktypes?.map((e) => NetworkType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNetworkType(): NetworkType {
  return { id: 0, name: "", eventNetworks: [], createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const NetworkType: MessageFns<NetworkType> = {
  encode(message: NetworkType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.eventNetworks) {
      EventNetwork.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(34).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(42).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(50).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.eventNetworks.push(EventNetwork.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkType {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      eventNetworks: globalThis.Array.isArray(object?.eventNetworks)
        ? object.eventNetworks.map((e: any) => EventNetwork.fromJSON(e))
        : [],
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: NetworkType): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.eventNetworks?.length) {
      obj.eventNetworks = message.eventNetworks.map((e) => EventNetwork.toJSON(e));
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkType>): NetworkType {
    return NetworkType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkType>): NetworkType {
    const message = createBaseNetworkType();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.eventNetworks = object.eventNetworks?.map((e) => EventNetwork.fromPartial(e)) || [];
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBasePlatformResult(): PlatformResult {
  return { platforms: [] };
}

export const PlatformResult: MessageFns<PlatformResult> = {
  encode(message: PlatformResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.platforms) {
      Platform.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlatformResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.platforms.push(Platform.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformResult {
    return {
      platforms: globalThis.Array.isArray(object?.platforms)
        ? object.platforms.map((e: any) => Platform.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PlatformResult): unknown {
    const obj: any = {};
    if (message.platforms?.length) {
      obj.platforms = message.platforms.map((e) => Platform.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformResult>): PlatformResult {
    return PlatformResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformResult>): PlatformResult {
    const message = createBasePlatformResult();
    message.platforms = object.platforms?.map((e) => Platform.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlatform(): Platform {
  return {
    id: 0,
    abbreviation: "",
    alternativeName: "",
    category: 0,
    createdAt: undefined,
    generation: 0,
    name: "",
    platformLogo: undefined,
    platformFamily: undefined,
    slug: "",
    summary: "",
    updatedAt: undefined,
    url: "",
    versions: [],
    websites: [],
    checksum: "",
    platformType: undefined,
  };
}

export const Platform: MessageFns<Platform> = {
  encode(message: Platform, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.abbreviation !== "") {
      writer.uint32(18).string(message.abbreviation);
    }
    if (message.alternativeName !== "") {
      writer.uint32(26).string(message.alternativeName);
    }
    if (message.category !== 0) {
      writer.uint32(32).int32(message.category);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(42).fork()).join();
    }
    if (message.generation !== 0) {
      writer.uint32(48).int32(message.generation);
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    if (message.platformLogo !== undefined) {
      PlatformLogo.encode(message.platformLogo, writer.uint32(66).fork()).join();
    }
    if (message.platformFamily !== undefined) {
      PlatformFamily.encode(message.platformFamily, writer.uint32(74).fork()).join();
    }
    if (message.slug !== "") {
      writer.uint32(82).string(message.slug);
    }
    if (message.summary !== "") {
      writer.uint32(90).string(message.summary);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(98).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(106).string(message.url);
    }
    for (const v of message.versions) {
      PlatformVersion.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.websites) {
      PlatformWebsite.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(130).string(message.checksum);
    }
    if (message.platformType !== undefined) {
      PlatformType.encode(message.platformType, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Platform {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatform();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.abbreviation = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.alternativeName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.generation = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.platformLogo = PlatformLogo.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.platformFamily = PlatformFamily.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.versions.push(PlatformVersion.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.websites.push(PlatformWebsite.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.platformType = PlatformType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Platform {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      abbreviation: isSet(object.abbreviation) ? globalThis.String(object.abbreviation) : "",
      alternativeName: isSet(object.alternativeName) ? globalThis.String(object.alternativeName) : "",
      category: isSet(object.category) ? platformCategoryEnumFromJSON(object.category) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      generation: isSet(object.generation) ? globalThis.Number(object.generation) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      platformLogo: isSet(object.platformLogo) ? PlatformLogo.fromJSON(object.platformLogo) : undefined,
      platformFamily: isSet(object.platformFamily) ? PlatformFamily.fromJSON(object.platformFamily) : undefined,
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      versions: globalThis.Array.isArray(object?.versions)
        ? object.versions.map((e: any) => PlatformVersion.fromJSON(e))
        : [],
      websites: globalThis.Array.isArray(object?.websites)
        ? object.websites.map((e: any) => PlatformWebsite.fromJSON(e))
        : [],
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      platformType: isSet(object.platformType) ? PlatformType.fromJSON(object.platformType) : undefined,
    };
  },

  toJSON(message: Platform): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.abbreviation !== "") {
      obj.abbreviation = message.abbreviation;
    }
    if (message.alternativeName !== "") {
      obj.alternativeName = message.alternativeName;
    }
    if (message.category !== 0) {
      obj.category = platformCategoryEnumToJSON(message.category);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.generation !== 0) {
      obj.generation = Math.round(message.generation);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.platformLogo !== undefined) {
      obj.platformLogo = PlatformLogo.toJSON(message.platformLogo);
    }
    if (message.platformFamily !== undefined) {
      obj.platformFamily = PlatformFamily.toJSON(message.platformFamily);
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.versions?.length) {
      obj.versions = message.versions.map((e) => PlatformVersion.toJSON(e));
    }
    if (message.websites?.length) {
      obj.websites = message.websites.map((e) => PlatformWebsite.toJSON(e));
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.platformType !== undefined) {
      obj.platformType = PlatformType.toJSON(message.platformType);
    }
    return obj;
  },

  create(base?: DeepPartial<Platform>): Platform {
    return Platform.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Platform>): Platform {
    const message = createBasePlatform();
    message.id = object.id ?? 0;
    message.abbreviation = object.abbreviation ?? "";
    message.alternativeName = object.alternativeName ?? "";
    message.category = object.category ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.generation = object.generation ?? 0;
    message.name = object.name ?? "";
    message.platformLogo = (object.platformLogo !== undefined && object.platformLogo !== null)
      ? PlatformLogo.fromPartial(object.platformLogo)
      : undefined;
    message.platformFamily = (object.platformFamily !== undefined && object.platformFamily !== null)
      ? PlatformFamily.fromPartial(object.platformFamily)
      : undefined;
    message.slug = object.slug ?? "";
    message.summary = object.summary ?? "";
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.url = object.url ?? "";
    message.versions = object.versions?.map((e) => PlatformVersion.fromPartial(e)) || [];
    message.websites = object.websites?.map((e) => PlatformWebsite.fromPartial(e)) || [];
    message.checksum = object.checksum ?? "";
    message.platformType = (object.platformType !== undefined && object.platformType !== null)
      ? PlatformType.fromPartial(object.platformType)
      : undefined;
    return message;
  },
};

function createBasePlatformFamilyResult(): PlatformFamilyResult {
  return { platformfamilies: [] };
}

export const PlatformFamilyResult: MessageFns<PlatformFamilyResult> = {
  encode(message: PlatformFamilyResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.platformfamilies) {
      PlatformFamily.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlatformFamilyResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformFamilyResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.platformfamilies.push(PlatformFamily.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformFamilyResult {
    return {
      platformfamilies: globalThis.Array.isArray(object?.platformfamilies)
        ? object.platformfamilies.map((e: any) => PlatformFamily.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PlatformFamilyResult): unknown {
    const obj: any = {};
    if (message.platformfamilies?.length) {
      obj.platformfamilies = message.platformfamilies.map((e) => PlatformFamily.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformFamilyResult>): PlatformFamilyResult {
    return PlatformFamilyResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformFamilyResult>): PlatformFamilyResult {
    const message = createBasePlatformFamilyResult();
    message.platformfamilies = object.platformfamilies?.map((e) => PlatformFamily.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlatformFamily(): PlatformFamily {
  return { id: 0, name: "", slug: "", checksum: "" };
}

export const PlatformFamily: MessageFns<PlatformFamily> = {
  encode(message: PlatformFamily, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(26).string(message.slug);
    }
    if (message.checksum !== "") {
      writer.uint32(34).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlatformFamily {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformFamily();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformFamily {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: PlatformFamily): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformFamily>): PlatformFamily {
    return PlatformFamily.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformFamily>): PlatformFamily {
    const message = createBasePlatformFamily();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.slug = object.slug ?? "";
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBasePlatformLogoResult(): PlatformLogoResult {
  return { platformlogos: [] };
}

export const PlatformLogoResult: MessageFns<PlatformLogoResult> = {
  encode(message: PlatformLogoResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.platformlogos) {
      PlatformLogo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlatformLogoResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformLogoResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.platformlogos.push(PlatformLogo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformLogoResult {
    return {
      platformlogos: globalThis.Array.isArray(object?.platformlogos)
        ? object.platformlogos.map((e: any) => PlatformLogo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PlatformLogoResult): unknown {
    const obj: any = {};
    if (message.platformlogos?.length) {
      obj.platformlogos = message.platformlogos.map((e) => PlatformLogo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformLogoResult>): PlatformLogoResult {
    return PlatformLogoResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformLogoResult>): PlatformLogoResult {
    const message = createBasePlatformLogoResult();
    message.platformlogos = object.platformlogos?.map((e) => PlatformLogo.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlatformLogo(): PlatformLogo {
  return { id: 0, alphaChannel: false, animated: false, height: 0, imageId: "", url: "", width: 0, checksum: "" };
}

export const PlatformLogo: MessageFns<PlatformLogo> = {
  encode(message: PlatformLogo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.alphaChannel !== false) {
      writer.uint32(16).bool(message.alphaChannel);
    }
    if (message.animated !== false) {
      writer.uint32(24).bool(message.animated);
    }
    if (message.height !== 0) {
      writer.uint32(32).int32(message.height);
    }
    if (message.imageId !== "") {
      writer.uint32(42).string(message.imageId);
    }
    if (message.url !== "") {
      writer.uint32(50).string(message.url);
    }
    if (message.width !== 0) {
      writer.uint32(56).int32(message.width);
    }
    if (message.checksum !== "") {
      writer.uint32(66).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlatformLogo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformLogo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.alphaChannel = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.animated = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.imageId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformLogo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      alphaChannel: isSet(object.alphaChannel) ? globalThis.Boolean(object.alphaChannel) : false,
      animated: isSet(object.animated) ? globalThis.Boolean(object.animated) : false,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      imageId: isSet(object.imageId) ? globalThis.String(object.imageId) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: PlatformLogo): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.alphaChannel !== false) {
      obj.alphaChannel = message.alphaChannel;
    }
    if (message.animated !== false) {
      obj.animated = message.animated;
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformLogo>): PlatformLogo {
    return PlatformLogo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformLogo>): PlatformLogo {
    const message = createBasePlatformLogo();
    message.id = object.id ?? 0;
    message.alphaChannel = object.alphaChannel ?? false;
    message.animated = object.animated ?? false;
    message.height = object.height ?? 0;
    message.imageId = object.imageId ?? "";
    message.url = object.url ?? "";
    message.width = object.width ?? 0;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBasePlatformTypeResult(): PlatformTypeResult {
  return { platformtypes: [] };
}

export const PlatformTypeResult: MessageFns<PlatformTypeResult> = {
  encode(message: PlatformTypeResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.platformtypes) {
      PlatformType.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlatformTypeResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformTypeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.platformtypes.push(PlatformType.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformTypeResult {
    return {
      platformtypes: globalThis.Array.isArray(object?.platformtypes)
        ? object.platformtypes.map((e: any) => PlatformType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PlatformTypeResult): unknown {
    const obj: any = {};
    if (message.platformtypes?.length) {
      obj.platformtypes = message.platformtypes.map((e) => PlatformType.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformTypeResult>): PlatformTypeResult {
    return PlatformTypeResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformTypeResult>): PlatformTypeResult {
    const message = createBasePlatformTypeResult();
    message.platformtypes = object.platformtypes?.map((e) => PlatformType.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlatformType(): PlatformType {
  return { id: 0, name: "", createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const PlatformType: MessageFns<PlatformType> = {
  encode(message: PlatformType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(34).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(42).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlatformType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformType {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: PlatformType): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformType>): PlatformType {
    return PlatformType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformType>): PlatformType {
    const message = createBasePlatformType();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBasePlatformVersionResult(): PlatformVersionResult {
  return { platformversions: [] };
}

export const PlatformVersionResult: MessageFns<PlatformVersionResult> = {
  encode(message: PlatformVersionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.platformversions) {
      PlatformVersion.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlatformVersionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformVersionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.platformversions.push(PlatformVersion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformVersionResult {
    return {
      platformversions: globalThis.Array.isArray(object?.platformversions)
        ? object.platformversions.map((e: any) => PlatformVersion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PlatformVersionResult): unknown {
    const obj: any = {};
    if (message.platformversions?.length) {
      obj.platformversions = message.platformversions.map((e) => PlatformVersion.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformVersionResult>): PlatformVersionResult {
    return PlatformVersionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformVersionResult>): PlatformVersionResult {
    const message = createBasePlatformVersionResult();
    message.platformversions = object.platformversions?.map((e) => PlatformVersion.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlatformVersion(): PlatformVersion {
  return {
    id: 0,
    companies: [],
    connectivity: "",
    cpu: "",
    graphics: "",
    mainManufacturer: undefined,
    media: "",
    memory: "",
    name: "",
    os: "",
    output: "",
    platformLogo: undefined,
    platformVersionReleaseDates: [],
    resolutions: "",
    slug: "",
    sound: "",
    storage: "",
    summary: "",
    url: "",
    checksum: "",
  };
}

export const PlatformVersion: MessageFns<PlatformVersion> = {
  encode(message: PlatformVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    for (const v of message.companies) {
      PlatformVersionCompany.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.connectivity !== "") {
      writer.uint32(26).string(message.connectivity);
    }
    if (message.cpu !== "") {
      writer.uint32(34).string(message.cpu);
    }
    if (message.graphics !== "") {
      writer.uint32(42).string(message.graphics);
    }
    if (message.mainManufacturer !== undefined) {
      PlatformVersionCompany.encode(message.mainManufacturer, writer.uint32(50).fork()).join();
    }
    if (message.media !== "") {
      writer.uint32(58).string(message.media);
    }
    if (message.memory !== "") {
      writer.uint32(66).string(message.memory);
    }
    if (message.name !== "") {
      writer.uint32(74).string(message.name);
    }
    if (message.os !== "") {
      writer.uint32(90).string(message.os);
    }
    if (message.output !== "") {
      writer.uint32(98).string(message.output);
    }
    if (message.platformLogo !== undefined) {
      PlatformLogo.encode(message.platformLogo, writer.uint32(106).fork()).join();
    }
    for (const v of message.platformVersionReleaseDates) {
      PlatformVersionReleaseDate.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.resolutions !== "") {
      writer.uint32(122).string(message.resolutions);
    }
    if (message.slug !== "") {
      writer.uint32(130).string(message.slug);
    }
    if (message.sound !== "") {
      writer.uint32(138).string(message.sound);
    }
    if (message.storage !== "") {
      writer.uint32(146).string(message.storage);
    }
    if (message.summary !== "") {
      writer.uint32(154).string(message.summary);
    }
    if (message.url !== "") {
      writer.uint32(162).string(message.url);
    }
    if (message.checksum !== "") {
      writer.uint32(170).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlatformVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.companies.push(PlatformVersionCompany.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connectivity = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cpu = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.graphics = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.mainManufacturer = PlatformVersionCompany.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.media = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.memory = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.os = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.output = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.platformLogo = PlatformLogo.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.platformVersionReleaseDates.push(PlatformVersionReleaseDate.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.resolutions = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.sound = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.storage = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformVersion {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      companies: globalThis.Array.isArray(object?.companies)
        ? object.companies.map((e: any) => PlatformVersionCompany.fromJSON(e))
        : [],
      connectivity: isSet(object.connectivity) ? globalThis.String(object.connectivity) : "",
      cpu: isSet(object.cpu) ? globalThis.String(object.cpu) : "",
      graphics: isSet(object.graphics) ? globalThis.String(object.graphics) : "",
      mainManufacturer: isSet(object.mainManufacturer)
        ? PlatformVersionCompany.fromJSON(object.mainManufacturer)
        : undefined,
      media: isSet(object.media) ? globalThis.String(object.media) : "",
      memory: isSet(object.memory) ? globalThis.String(object.memory) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      os: isSet(object.os) ? globalThis.String(object.os) : "",
      output: isSet(object.output) ? globalThis.String(object.output) : "",
      platformLogo: isSet(object.platformLogo) ? PlatformLogo.fromJSON(object.platformLogo) : undefined,
      platformVersionReleaseDates: globalThis.Array.isArray(object?.platformVersionReleaseDates)
        ? object.platformVersionReleaseDates.map((e: any) => PlatformVersionReleaseDate.fromJSON(e))
        : [],
      resolutions: isSet(object.resolutions) ? globalThis.String(object.resolutions) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      sound: isSet(object.sound) ? globalThis.String(object.sound) : "",
      storage: isSet(object.storage) ? globalThis.String(object.storage) : "",
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: PlatformVersion): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.companies?.length) {
      obj.companies = message.companies.map((e) => PlatformVersionCompany.toJSON(e));
    }
    if (message.connectivity !== "") {
      obj.connectivity = message.connectivity;
    }
    if (message.cpu !== "") {
      obj.cpu = message.cpu;
    }
    if (message.graphics !== "") {
      obj.graphics = message.graphics;
    }
    if (message.mainManufacturer !== undefined) {
      obj.mainManufacturer = PlatformVersionCompany.toJSON(message.mainManufacturer);
    }
    if (message.media !== "") {
      obj.media = message.media;
    }
    if (message.memory !== "") {
      obj.memory = message.memory;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.os !== "") {
      obj.os = message.os;
    }
    if (message.output !== "") {
      obj.output = message.output;
    }
    if (message.platformLogo !== undefined) {
      obj.platformLogo = PlatformLogo.toJSON(message.platformLogo);
    }
    if (message.platformVersionReleaseDates?.length) {
      obj.platformVersionReleaseDates = message.platformVersionReleaseDates.map((e) =>
        PlatformVersionReleaseDate.toJSON(e)
      );
    }
    if (message.resolutions !== "") {
      obj.resolutions = message.resolutions;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.sound !== "") {
      obj.sound = message.sound;
    }
    if (message.storage !== "") {
      obj.storage = message.storage;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformVersion>): PlatformVersion {
    return PlatformVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformVersion>): PlatformVersion {
    const message = createBasePlatformVersion();
    message.id = object.id ?? 0;
    message.companies = object.companies?.map((e) => PlatformVersionCompany.fromPartial(e)) || [];
    message.connectivity = object.connectivity ?? "";
    message.cpu = object.cpu ?? "";
    message.graphics = object.graphics ?? "";
    message.mainManufacturer = (object.mainManufacturer !== undefined && object.mainManufacturer !== null)
      ? PlatformVersionCompany.fromPartial(object.mainManufacturer)
      : undefined;
    message.media = object.media ?? "";
    message.memory = object.memory ?? "";
    message.name = object.name ?? "";
    message.os = object.os ?? "";
    message.output = object.output ?? "";
    message.platformLogo = (object.platformLogo !== undefined && object.platformLogo !== null)
      ? PlatformLogo.fromPartial(object.platformLogo)
      : undefined;
    message.platformVersionReleaseDates =
      object.platformVersionReleaseDates?.map((e) => PlatformVersionReleaseDate.fromPartial(e)) || [];
    message.resolutions = object.resolutions ?? "";
    message.slug = object.slug ?? "";
    message.sound = object.sound ?? "";
    message.storage = object.storage ?? "";
    message.summary = object.summary ?? "";
    message.url = object.url ?? "";
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBasePlatformVersionCompanyResult(): PlatformVersionCompanyResult {
  return { platformversioncompanies: [] };
}

export const PlatformVersionCompanyResult: MessageFns<PlatformVersionCompanyResult> = {
  encode(message: PlatformVersionCompanyResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.platformversioncompanies) {
      PlatformVersionCompany.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlatformVersionCompanyResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformVersionCompanyResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.platformversioncompanies.push(PlatformVersionCompany.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformVersionCompanyResult {
    return {
      platformversioncompanies: globalThis.Array.isArray(object?.platformversioncompanies)
        ? object.platformversioncompanies.map((e: any) => PlatformVersionCompany.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PlatformVersionCompanyResult): unknown {
    const obj: any = {};
    if (message.platformversioncompanies?.length) {
      obj.platformversioncompanies = message.platformversioncompanies.map((e) => PlatformVersionCompany.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformVersionCompanyResult>): PlatformVersionCompanyResult {
    return PlatformVersionCompanyResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformVersionCompanyResult>): PlatformVersionCompanyResult {
    const message = createBasePlatformVersionCompanyResult();
    message.platformversioncompanies =
      object.platformversioncompanies?.map((e) => PlatformVersionCompany.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlatformVersionCompany(): PlatformVersionCompany {
  return { id: 0, comment: "", company: undefined, developer: false, manufacturer: false, checksum: "" };
}

export const PlatformVersionCompany: MessageFns<PlatformVersionCompany> = {
  encode(message: PlatformVersionCompany, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.comment !== "") {
      writer.uint32(18).string(message.comment);
    }
    if (message.company !== undefined) {
      Company.encode(message.company, writer.uint32(26).fork()).join();
    }
    if (message.developer !== false) {
      writer.uint32(32).bool(message.developer);
    }
    if (message.manufacturer !== false) {
      writer.uint32(40).bool(message.manufacturer);
    }
    if (message.checksum !== "") {
      writer.uint32(50).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlatformVersionCompany {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformVersionCompany();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.company = Company.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.developer = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.manufacturer = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformVersionCompany {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      company: isSet(object.company) ? Company.fromJSON(object.company) : undefined,
      developer: isSet(object.developer) ? globalThis.Boolean(object.developer) : false,
      manufacturer: isSet(object.manufacturer) ? globalThis.Boolean(object.manufacturer) : false,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: PlatformVersionCompany): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.company !== undefined) {
      obj.company = Company.toJSON(message.company);
    }
    if (message.developer !== false) {
      obj.developer = message.developer;
    }
    if (message.manufacturer !== false) {
      obj.manufacturer = message.manufacturer;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformVersionCompany>): PlatformVersionCompany {
    return PlatformVersionCompany.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformVersionCompany>): PlatformVersionCompany {
    const message = createBasePlatformVersionCompany();
    message.id = object.id ?? 0;
    message.comment = object.comment ?? "";
    message.company = (object.company !== undefined && object.company !== null)
      ? Company.fromPartial(object.company)
      : undefined;
    message.developer = object.developer ?? false;
    message.manufacturer = object.manufacturer ?? false;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBasePlatformVersionReleaseDateResult(): PlatformVersionReleaseDateResult {
  return { platformversionreleasedates: [] };
}

export const PlatformVersionReleaseDateResult: MessageFns<PlatformVersionReleaseDateResult> = {
  encode(message: PlatformVersionReleaseDateResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.platformversionreleasedates) {
      PlatformVersionReleaseDate.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlatformVersionReleaseDateResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformVersionReleaseDateResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.platformversionreleasedates.push(PlatformVersionReleaseDate.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformVersionReleaseDateResult {
    return {
      platformversionreleasedates: globalThis.Array.isArray(object?.platformversionreleasedates)
        ? object.platformversionreleasedates.map((e: any) => PlatformVersionReleaseDate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PlatformVersionReleaseDateResult): unknown {
    const obj: any = {};
    if (message.platformversionreleasedates?.length) {
      obj.platformversionreleasedates = message.platformversionreleasedates.map((e) =>
        PlatformVersionReleaseDate.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformVersionReleaseDateResult>): PlatformVersionReleaseDateResult {
    return PlatformVersionReleaseDateResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformVersionReleaseDateResult>): PlatformVersionReleaseDateResult {
    const message = createBasePlatformVersionReleaseDateResult();
    message.platformversionreleasedates =
      object.platformversionreleasedates?.map((e) => PlatformVersionReleaseDate.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlatformVersionReleaseDate(): PlatformVersionReleaseDate {
  return {
    id: 0,
    category: 0,
    createdAt: undefined,
    date: undefined,
    human: "",
    m: 0,
    platformVersion: undefined,
    region: 0,
    updatedAt: undefined,
    y: 0,
    checksum: "",
    dateFormat: undefined,
    releaseRegion: undefined,
  };
}

export const PlatformVersionReleaseDate: MessageFns<PlatformVersionReleaseDate> = {
  encode(message: PlatformVersionReleaseDate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.category !== 0) {
      writer.uint32(16).int32(message.category);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.date !== undefined) {
      Timestamp.encode(message.date, writer.uint32(34).fork()).join();
    }
    if (message.human !== "") {
      writer.uint32(42).string(message.human);
    }
    if (message.m !== 0) {
      writer.uint32(48).int32(message.m);
    }
    if (message.platformVersion !== undefined) {
      PlatformVersion.encode(message.platformVersion, writer.uint32(58).fork()).join();
    }
    if (message.region !== 0) {
      writer.uint32(64).int32(message.region);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(74).fork()).join();
    }
    if (message.y !== 0) {
      writer.uint32(80).int32(message.y);
    }
    if (message.checksum !== "") {
      writer.uint32(90).string(message.checksum);
    }
    if (message.dateFormat !== undefined) {
      DateFormat.encode(message.dateFormat, writer.uint32(98).fork()).join();
    }
    if (message.releaseRegion !== undefined) {
      ReleaseDateRegion.encode(message.releaseRegion, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlatformVersionReleaseDate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformVersionReleaseDate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.date = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.human = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.m = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.platformVersion = PlatformVersion.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.region = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.y = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.dateFormat = DateFormat.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.releaseRegion = ReleaseDateRegion.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformVersionReleaseDate {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      category: isSet(object.category) ? dateFormatChangeDateCategoryEnumFromJSON(object.category) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      date: isSet(object.date) ? fromJsonTimestamp(object.date) : undefined,
      human: isSet(object.human) ? globalThis.String(object.human) : "",
      m: isSet(object.m) ? globalThis.Number(object.m) : 0,
      platformVersion: isSet(object.platformVersion) ? PlatformVersion.fromJSON(object.platformVersion) : undefined,
      region: isSet(object.region) ? regionRegionEnumFromJSON(object.region) : 0,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      dateFormat: isSet(object.dateFormat) ? DateFormat.fromJSON(object.dateFormat) : undefined,
      releaseRegion: isSet(object.releaseRegion) ? ReleaseDateRegion.fromJSON(object.releaseRegion) : undefined,
    };
  },

  toJSON(message: PlatformVersionReleaseDate): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.category !== 0) {
      obj.category = dateFormatChangeDateCategoryEnumToJSON(message.category);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.date !== undefined) {
      obj.date = fromTimestamp(message.date).toISOString();
    }
    if (message.human !== "") {
      obj.human = message.human;
    }
    if (message.m !== 0) {
      obj.m = Math.round(message.m);
    }
    if (message.platformVersion !== undefined) {
      obj.platformVersion = PlatformVersion.toJSON(message.platformVersion);
    }
    if (message.region !== 0) {
      obj.region = regionRegionEnumToJSON(message.region);
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.dateFormat !== undefined) {
      obj.dateFormat = DateFormat.toJSON(message.dateFormat);
    }
    if (message.releaseRegion !== undefined) {
      obj.releaseRegion = ReleaseDateRegion.toJSON(message.releaseRegion);
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformVersionReleaseDate>): PlatformVersionReleaseDate {
    return PlatformVersionReleaseDate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformVersionReleaseDate>): PlatformVersionReleaseDate {
    const message = createBasePlatformVersionReleaseDate();
    message.id = object.id ?? 0;
    message.category = object.category ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.date = (object.date !== undefined && object.date !== null) ? Timestamp.fromPartial(object.date) : undefined;
    message.human = object.human ?? "";
    message.m = object.m ?? 0;
    message.platformVersion = (object.platformVersion !== undefined && object.platformVersion !== null)
      ? PlatformVersion.fromPartial(object.platformVersion)
      : undefined;
    message.region = object.region ?? 0;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.y = object.y ?? 0;
    message.checksum = object.checksum ?? "";
    message.dateFormat = (object.dateFormat !== undefined && object.dateFormat !== null)
      ? DateFormat.fromPartial(object.dateFormat)
      : undefined;
    message.releaseRegion = (object.releaseRegion !== undefined && object.releaseRegion !== null)
      ? ReleaseDateRegion.fromPartial(object.releaseRegion)
      : undefined;
    return message;
  },
};

function createBasePlatformWebsiteResult(): PlatformWebsiteResult {
  return { platformwebsites: [] };
}

export const PlatformWebsiteResult: MessageFns<PlatformWebsiteResult> = {
  encode(message: PlatformWebsiteResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.platformwebsites) {
      PlatformWebsite.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlatformWebsiteResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformWebsiteResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.platformwebsites.push(PlatformWebsite.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformWebsiteResult {
    return {
      platformwebsites: globalThis.Array.isArray(object?.platformwebsites)
        ? object.platformwebsites.map((e: any) => PlatformWebsite.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PlatformWebsiteResult): unknown {
    const obj: any = {};
    if (message.platformwebsites?.length) {
      obj.platformwebsites = message.platformwebsites.map((e) => PlatformWebsite.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformWebsiteResult>): PlatformWebsiteResult {
    return PlatformWebsiteResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformWebsiteResult>): PlatformWebsiteResult {
    const message = createBasePlatformWebsiteResult();
    message.platformwebsites = object.platformwebsites?.map((e) => PlatformWebsite.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlatformWebsite(): PlatformWebsite {
  return { id: 0, category: 0, trusted: false, url: "", checksum: "", type: undefined };
}

export const PlatformWebsite: MessageFns<PlatformWebsite> = {
  encode(message: PlatformWebsite, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.category !== 0) {
      writer.uint32(16).int32(message.category);
    }
    if (message.trusted !== false) {
      writer.uint32(24).bool(message.trusted);
    }
    if (message.url !== "") {
      writer.uint32(34).string(message.url);
    }
    if (message.checksum !== "") {
      writer.uint32(42).string(message.checksum);
    }
    if (message.type !== undefined) {
      WebsiteType.encode(message.type, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlatformWebsite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformWebsite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.trusted = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.type = WebsiteType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformWebsite {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      category: isSet(object.category) ? websiteCategoryEnumFromJSON(object.category) : 0,
      trusted: isSet(object.trusted) ? globalThis.Boolean(object.trusted) : false,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      type: isSet(object.type) ? WebsiteType.fromJSON(object.type) : undefined,
    };
  },

  toJSON(message: PlatformWebsite): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.category !== 0) {
      obj.category = websiteCategoryEnumToJSON(message.category);
    }
    if (message.trusted !== false) {
      obj.trusted = message.trusted;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.type !== undefined) {
      obj.type = WebsiteType.toJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformWebsite>): PlatformWebsite {
    return PlatformWebsite.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformWebsite>): PlatformWebsite {
    const message = createBasePlatformWebsite();
    message.id = object.id ?? 0;
    message.category = object.category ?? 0;
    message.trusted = object.trusted ?? false;
    message.url = object.url ?? "";
    message.checksum = object.checksum ?? "";
    message.type = (object.type !== undefined && object.type !== null)
      ? WebsiteType.fromPartial(object.type)
      : undefined;
    return message;
  },
};

function createBasePlayerPerspectiveResult(): PlayerPerspectiveResult {
  return { playerperspectives: [] };
}

export const PlayerPerspectiveResult: MessageFns<PlayerPerspectiveResult> = {
  encode(message: PlayerPerspectiveResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.playerperspectives) {
      PlayerPerspective.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerPerspectiveResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerPerspectiveResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerperspectives.push(PlayerPerspective.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerPerspectiveResult {
    return {
      playerperspectives: globalThis.Array.isArray(object?.playerperspectives)
        ? object.playerperspectives.map((e: any) => PlayerPerspective.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PlayerPerspectiveResult): unknown {
    const obj: any = {};
    if (message.playerperspectives?.length) {
      obj.playerperspectives = message.playerperspectives.map((e) => PlayerPerspective.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PlayerPerspectiveResult>): PlayerPerspectiveResult {
    return PlayerPerspectiveResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayerPerspectiveResult>): PlayerPerspectiveResult {
    const message = createBasePlayerPerspectiveResult();
    message.playerperspectives = object.playerperspectives?.map((e) => PlayerPerspective.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlayerPerspective(): PlayerPerspective {
  return { id: 0, createdAt: undefined, name: "", slug: "", updatedAt: undefined, url: "", checksum: "" };
}

export const PlayerPerspective: MessageFns<PlayerPerspective> = {
  encode(message: PlayerPerspective, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(18).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(34).string(message.slug);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(42).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(50).string(message.url);
    }
    if (message.checksum !== "") {
      writer.uint32(58).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerPerspective {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerPerspective();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerPerspective {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: PlayerPerspective): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<PlayerPerspective>): PlayerPerspective {
    return PlayerPerspective.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlayerPerspective>): PlayerPerspective {
    const message = createBasePlayerPerspective();
    message.id = object.id ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.name = object.name ?? "";
    message.slug = object.slug ?? "";
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.url = object.url ?? "";
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBasePopularityPrimitiveResult(): PopularityPrimitiveResult {
  return { popularityprimitives: [] };
}

export const PopularityPrimitiveResult: MessageFns<PopularityPrimitiveResult> = {
  encode(message: PopularityPrimitiveResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.popularityprimitives) {
      PopularityPrimitive.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PopularityPrimitiveResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePopularityPrimitiveResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.popularityprimitives.push(PopularityPrimitive.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PopularityPrimitiveResult {
    return {
      popularityprimitives: globalThis.Array.isArray(object?.popularityprimitives)
        ? object.popularityprimitives.map((e: any) => PopularityPrimitive.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PopularityPrimitiveResult): unknown {
    const obj: any = {};
    if (message.popularityprimitives?.length) {
      obj.popularityprimitives = message.popularityprimitives.map((e) => PopularityPrimitive.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PopularityPrimitiveResult>): PopularityPrimitiveResult {
    return PopularityPrimitiveResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PopularityPrimitiveResult>): PopularityPrimitiveResult {
    const message = createBasePopularityPrimitiveResult();
    message.popularityprimitives = object.popularityprimitives?.map((e) => PopularityPrimitive.fromPartial(e)) || [];
    return message;
  },
};

function createBasePopularityPrimitive(): PopularityPrimitive {
  return {
    id: 0,
    gameId: 0,
    popularityType: undefined,
    popularitySource: 0,
    value: 0,
    calculatedAt: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    checksum: "",
    externalPopularitySource: undefined,
  };
}

export const PopularityPrimitive: MessageFns<PopularityPrimitive> = {
  encode(message: PopularityPrimitive, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.gameId !== 0) {
      writer.uint32(16).int32(message.gameId);
    }
    if (message.popularityType !== undefined) {
      PopularityType.encode(message.popularityType, writer.uint32(26).fork()).join();
    }
    if (message.popularitySource !== 0) {
      writer.uint32(32).int32(message.popularitySource);
    }
    if (message.value !== 0) {
      writer.uint32(41).double(message.value);
    }
    if (message.calculatedAt !== undefined) {
      Timestamp.encode(message.calculatedAt, writer.uint32(50).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(58).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(66).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(74).string(message.checksum);
    }
    if (message.externalPopularitySource !== undefined) {
      ExternalGameSource.encode(message.externalPopularitySource, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PopularityPrimitive {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePopularityPrimitive();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gameId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.popularityType = PopularityType.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.popularitySource = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.value = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.calculatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.externalPopularitySource = ExternalGameSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PopularityPrimitive {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      gameId: isSet(object.gameId) ? globalThis.Number(object.gameId) : 0,
      popularityType: isSet(object.popularityType) ? PopularityType.fromJSON(object.popularityType) : undefined,
      popularitySource: isSet(object.popularitySource)
        ? popularitySourcePopularitySourceEnumFromJSON(object.popularitySource)
        : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      calculatedAt: isSet(object.calculatedAt) ? fromJsonTimestamp(object.calculatedAt) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      externalPopularitySource: isSet(object.externalPopularitySource)
        ? ExternalGameSource.fromJSON(object.externalPopularitySource)
        : undefined,
    };
  },

  toJSON(message: PopularityPrimitive): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.gameId !== 0) {
      obj.gameId = Math.round(message.gameId);
    }
    if (message.popularityType !== undefined) {
      obj.popularityType = PopularityType.toJSON(message.popularityType);
    }
    if (message.popularitySource !== 0) {
      obj.popularitySource = popularitySourcePopularitySourceEnumToJSON(message.popularitySource);
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.calculatedAt !== undefined) {
      obj.calculatedAt = fromTimestamp(message.calculatedAt).toISOString();
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.externalPopularitySource !== undefined) {
      obj.externalPopularitySource = ExternalGameSource.toJSON(message.externalPopularitySource);
    }
    return obj;
  },

  create(base?: DeepPartial<PopularityPrimitive>): PopularityPrimitive {
    return PopularityPrimitive.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PopularityPrimitive>): PopularityPrimitive {
    const message = createBasePopularityPrimitive();
    message.id = object.id ?? 0;
    message.gameId = object.gameId ?? 0;
    message.popularityType = (object.popularityType !== undefined && object.popularityType !== null)
      ? PopularityType.fromPartial(object.popularityType)
      : undefined;
    message.popularitySource = object.popularitySource ?? 0;
    message.value = object.value ?? 0;
    message.calculatedAt = (object.calculatedAt !== undefined && object.calculatedAt !== null)
      ? Timestamp.fromPartial(object.calculatedAt)
      : undefined;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    message.externalPopularitySource =
      (object.externalPopularitySource !== undefined && object.externalPopularitySource !== null)
        ? ExternalGameSource.fromPartial(object.externalPopularitySource)
        : undefined;
    return message;
  },
};

function createBasePopularityTypeResult(): PopularityTypeResult {
  return { popularitytypes: [] };
}

export const PopularityTypeResult: MessageFns<PopularityTypeResult> = {
  encode(message: PopularityTypeResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.popularitytypes) {
      PopularityType.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PopularityTypeResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePopularityTypeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.popularitytypes.push(PopularityType.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PopularityTypeResult {
    return {
      popularitytypes: globalThis.Array.isArray(object?.popularitytypes)
        ? object.popularitytypes.map((e: any) => PopularityType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PopularityTypeResult): unknown {
    const obj: any = {};
    if (message.popularitytypes?.length) {
      obj.popularitytypes = message.popularitytypes.map((e) => PopularityType.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PopularityTypeResult>): PopularityTypeResult {
    return PopularityTypeResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PopularityTypeResult>): PopularityTypeResult {
    const message = createBasePopularityTypeResult();
    message.popularitytypes = object.popularitytypes?.map((e) => PopularityType.fromPartial(e)) || [];
    return message;
  },
};

function createBasePopularityType(): PopularityType {
  return {
    id: 0,
    popularitySource: 0,
    name: "",
    createdAt: undefined,
    updatedAt: undefined,
    checksum: "",
    externalPopularitySource: undefined,
  };
}

export const PopularityType: MessageFns<PopularityType> = {
  encode(message: PopularityType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.popularitySource !== 0) {
      writer.uint32(16).int32(message.popularitySource);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(34).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(42).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(50).string(message.checksum);
    }
    if (message.externalPopularitySource !== undefined) {
      ExternalGameSource.encode(message.externalPopularitySource, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PopularityType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePopularityType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.popularitySource = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.externalPopularitySource = ExternalGameSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PopularityType {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      popularitySource: isSet(object.popularitySource)
        ? popularitySourcePopularitySourceEnumFromJSON(object.popularitySource)
        : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      externalPopularitySource: isSet(object.externalPopularitySource)
        ? ExternalGameSource.fromJSON(object.externalPopularitySource)
        : undefined,
    };
  },

  toJSON(message: PopularityType): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.popularitySource !== 0) {
      obj.popularitySource = popularitySourcePopularitySourceEnumToJSON(message.popularitySource);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.externalPopularitySource !== undefined) {
      obj.externalPopularitySource = ExternalGameSource.toJSON(message.externalPopularitySource);
    }
    return obj;
  },

  create(base?: DeepPartial<PopularityType>): PopularityType {
    return PopularityType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PopularityType>): PopularityType {
    const message = createBasePopularityType();
    message.id = object.id ?? 0;
    message.popularitySource = object.popularitySource ?? 0;
    message.name = object.name ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    message.externalPopularitySource =
      (object.externalPopularitySource !== undefined && object.externalPopularitySource !== null)
        ? ExternalGameSource.fromPartial(object.externalPopularitySource)
        : undefined;
    return message;
  },
};

function createBaseRegionResult(): RegionResult {
  return { regions: [] };
}

export const RegionResult: MessageFns<RegionResult> = {
  encode(message: RegionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.regions) {
      Region.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.regions.push(Region.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegionResult {
    return {
      regions: globalThis.Array.isArray(object?.regions) ? object.regions.map((e: any) => Region.fromJSON(e)) : [],
    };
  },

  toJSON(message: RegionResult): unknown {
    const obj: any = {};
    if (message.regions?.length) {
      obj.regions = message.regions.map((e) => Region.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RegionResult>): RegionResult {
    return RegionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegionResult>): RegionResult {
    const message = createBaseRegionResult();
    message.regions = object.regions?.map((e) => Region.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRegion(): Region {
  return { id: 0, name: "", category: "", identifier: "", createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const Region: MessageFns<Region> = {
  encode(message: Region, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.category !== "") {
      writer.uint32(26).string(message.category);
    }
    if (message.identifier !== "") {
      writer.uint32(34).string(message.identifier);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(42).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(50).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(58).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Region {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Region {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: Region): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<Region>): Region {
    return Region.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Region>): Region {
    const message = createBaseRegion();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.category = object.category ?? "";
    message.identifier = object.identifier ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseReleaseDateResult(): ReleaseDateResult {
  return { releasedates: [] };
}

export const ReleaseDateResult: MessageFns<ReleaseDateResult> = {
  encode(message: ReleaseDateResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.releasedates) {
      ReleaseDate.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReleaseDateResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReleaseDateResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.releasedates.push(ReleaseDate.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReleaseDateResult {
    return {
      releasedates: globalThis.Array.isArray(object?.releasedates)
        ? object.releasedates.map((e: any) => ReleaseDate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReleaseDateResult): unknown {
    const obj: any = {};
    if (message.releasedates?.length) {
      obj.releasedates = message.releasedates.map((e) => ReleaseDate.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ReleaseDateResult>): ReleaseDateResult {
    return ReleaseDateResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReleaseDateResult>): ReleaseDateResult {
    const message = createBaseReleaseDateResult();
    message.releasedates = object.releasedates?.map((e) => ReleaseDate.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReleaseDate(): ReleaseDate {
  return {
    id: 0,
    category: 0,
    createdAt: undefined,
    date: undefined,
    game: undefined,
    human: "",
    m: 0,
    platform: undefined,
    region: 0,
    updatedAt: undefined,
    y: 0,
    checksum: "",
    status: undefined,
    dateFormat: undefined,
    releaseRegion: undefined,
  };
}

export const ReleaseDate: MessageFns<ReleaseDate> = {
  encode(message: ReleaseDate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.category !== 0) {
      writer.uint32(16).int32(message.category);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.date !== undefined) {
      Timestamp.encode(message.date, writer.uint32(34).fork()).join();
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(42).fork()).join();
    }
    if (message.human !== "") {
      writer.uint32(50).string(message.human);
    }
    if (message.m !== 0) {
      writer.uint32(56).int32(message.m);
    }
    if (message.platform !== undefined) {
      Platform.encode(message.platform, writer.uint32(66).fork()).join();
    }
    if (message.region !== 0) {
      writer.uint32(72).int32(message.region);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(82).fork()).join();
    }
    if (message.y !== 0) {
      writer.uint32(88).int32(message.y);
    }
    if (message.checksum !== "") {
      writer.uint32(98).string(message.checksum);
    }
    if (message.status !== undefined) {
      ReleaseDateStatus.encode(message.status, writer.uint32(106).fork()).join();
    }
    if (message.dateFormat !== undefined) {
      DateFormat.encode(message.dateFormat, writer.uint32(114).fork()).join();
    }
    if (message.releaseRegion !== undefined) {
      ReleaseDateRegion.encode(message.releaseRegion, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReleaseDate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReleaseDate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.date = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.human = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.m = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.platform = Platform.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.region = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.y = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.status = ReleaseDateStatus.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.dateFormat = DateFormat.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.releaseRegion = ReleaseDateRegion.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReleaseDate {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      category: isSet(object.category) ? dateFormatChangeDateCategoryEnumFromJSON(object.category) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      date: isSet(object.date) ? fromJsonTimestamp(object.date) : undefined,
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
      human: isSet(object.human) ? globalThis.String(object.human) : "",
      m: isSet(object.m) ? globalThis.Number(object.m) : 0,
      platform: isSet(object.platform) ? Platform.fromJSON(object.platform) : undefined,
      region: isSet(object.region) ? regionRegionEnumFromJSON(object.region) : 0,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      status: isSet(object.status) ? ReleaseDateStatus.fromJSON(object.status) : undefined,
      dateFormat: isSet(object.dateFormat) ? DateFormat.fromJSON(object.dateFormat) : undefined,
      releaseRegion: isSet(object.releaseRegion) ? ReleaseDateRegion.fromJSON(object.releaseRegion) : undefined,
    };
  },

  toJSON(message: ReleaseDate): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.category !== 0) {
      obj.category = dateFormatChangeDateCategoryEnumToJSON(message.category);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.date !== undefined) {
      obj.date = fromTimestamp(message.date).toISOString();
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    if (message.human !== "") {
      obj.human = message.human;
    }
    if (message.m !== 0) {
      obj.m = Math.round(message.m);
    }
    if (message.platform !== undefined) {
      obj.platform = Platform.toJSON(message.platform);
    }
    if (message.region !== 0) {
      obj.region = regionRegionEnumToJSON(message.region);
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.status !== undefined) {
      obj.status = ReleaseDateStatus.toJSON(message.status);
    }
    if (message.dateFormat !== undefined) {
      obj.dateFormat = DateFormat.toJSON(message.dateFormat);
    }
    if (message.releaseRegion !== undefined) {
      obj.releaseRegion = ReleaseDateRegion.toJSON(message.releaseRegion);
    }
    return obj;
  },

  create(base?: DeepPartial<ReleaseDate>): ReleaseDate {
    return ReleaseDate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReleaseDate>): ReleaseDate {
    const message = createBaseReleaseDate();
    message.id = object.id ?? 0;
    message.category = object.category ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.date = (object.date !== undefined && object.date !== null) ? Timestamp.fromPartial(object.date) : undefined;
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    message.human = object.human ?? "";
    message.m = object.m ?? 0;
    message.platform = (object.platform !== undefined && object.platform !== null)
      ? Platform.fromPartial(object.platform)
      : undefined;
    message.region = object.region ?? 0;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.y = object.y ?? 0;
    message.checksum = object.checksum ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? ReleaseDateStatus.fromPartial(object.status)
      : undefined;
    message.dateFormat = (object.dateFormat !== undefined && object.dateFormat !== null)
      ? DateFormat.fromPartial(object.dateFormat)
      : undefined;
    message.releaseRegion = (object.releaseRegion !== undefined && object.releaseRegion !== null)
      ? ReleaseDateRegion.fromPartial(object.releaseRegion)
      : undefined;
    return message;
  },
};

function createBaseReleaseDateRegionResult(): ReleaseDateRegionResult {
  return { releasedateregions: [] };
}

export const ReleaseDateRegionResult: MessageFns<ReleaseDateRegionResult> = {
  encode(message: ReleaseDateRegionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.releasedateregions) {
      ReleaseDateRegion.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReleaseDateRegionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReleaseDateRegionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.releasedateregions.push(ReleaseDateRegion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReleaseDateRegionResult {
    return {
      releasedateregions: globalThis.Array.isArray(object?.releasedateregions)
        ? object.releasedateregions.map((e: any) => ReleaseDateRegion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReleaseDateRegionResult): unknown {
    const obj: any = {};
    if (message.releasedateregions?.length) {
      obj.releasedateregions = message.releasedateregions.map((e) => ReleaseDateRegion.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ReleaseDateRegionResult>): ReleaseDateRegionResult {
    return ReleaseDateRegionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReleaseDateRegionResult>): ReleaseDateRegionResult {
    const message = createBaseReleaseDateRegionResult();
    message.releasedateregions = object.releasedateregions?.map((e) => ReleaseDateRegion.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReleaseDateRegion(): ReleaseDateRegion {
  return { id: 0, region: "", createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const ReleaseDateRegion: MessageFns<ReleaseDateRegion> = {
  encode(message: ReleaseDateRegion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.region !== "") {
      writer.uint32(18).string(message.region);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(34).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(42).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReleaseDateRegion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReleaseDateRegion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReleaseDateRegion {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: ReleaseDateRegion): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<ReleaseDateRegion>): ReleaseDateRegion {
    return ReleaseDateRegion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReleaseDateRegion>): ReleaseDateRegion {
    const message = createBaseReleaseDateRegion();
    message.id = object.id ?? 0;
    message.region = object.region ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseReleaseDateStatusResult(): ReleaseDateStatusResult {
  return { releasedatestatuses: [] };
}

export const ReleaseDateStatusResult: MessageFns<ReleaseDateStatusResult> = {
  encode(message: ReleaseDateStatusResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.releasedatestatuses) {
      ReleaseDateStatus.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReleaseDateStatusResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReleaseDateStatusResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.releasedatestatuses.push(ReleaseDateStatus.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReleaseDateStatusResult {
    return {
      releasedatestatuses: globalThis.Array.isArray(object?.releasedatestatuses)
        ? object.releasedatestatuses.map((e: any) => ReleaseDateStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReleaseDateStatusResult): unknown {
    const obj: any = {};
    if (message.releasedatestatuses?.length) {
      obj.releasedatestatuses = message.releasedatestatuses.map((e) => ReleaseDateStatus.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ReleaseDateStatusResult>): ReleaseDateStatusResult {
    return ReleaseDateStatusResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReleaseDateStatusResult>): ReleaseDateStatusResult {
    const message = createBaseReleaseDateStatusResult();
    message.releasedatestatuses = object.releasedatestatuses?.map((e) => ReleaseDateStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReleaseDateStatus(): ReleaseDateStatus {
  return { id: 0, name: "", description: "", createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const ReleaseDateStatus: MessageFns<ReleaseDateStatus> = {
  encode(message: ReleaseDateStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(34).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(42).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(50).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReleaseDateStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReleaseDateStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReleaseDateStatus {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: ReleaseDateStatus): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<ReleaseDateStatus>): ReleaseDateStatus {
    return ReleaseDateStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReleaseDateStatus>): ReleaseDateStatus {
    const message = createBaseReleaseDateStatus();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseScreenshotResult(): ScreenshotResult {
  return { screenshots: [] };
}

export const ScreenshotResult: MessageFns<ScreenshotResult> = {
  encode(message: ScreenshotResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.screenshots) {
      Screenshot.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScreenshotResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScreenshotResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.screenshots.push(Screenshot.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScreenshotResult {
    return {
      screenshots: globalThis.Array.isArray(object?.screenshots)
        ? object.screenshots.map((e: any) => Screenshot.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ScreenshotResult): unknown {
    const obj: any = {};
    if (message.screenshots?.length) {
      obj.screenshots = message.screenshots.map((e) => Screenshot.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ScreenshotResult>): ScreenshotResult {
    return ScreenshotResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScreenshotResult>): ScreenshotResult {
    const message = createBaseScreenshotResult();
    message.screenshots = object.screenshots?.map((e) => Screenshot.fromPartial(e)) || [];
    return message;
  },
};

function createBaseScreenshot(): Screenshot {
  return {
    id: 0,
    alphaChannel: false,
    animated: false,
    game: undefined,
    height: 0,
    imageId: "",
    url: "",
    width: 0,
    checksum: "",
  };
}

export const Screenshot: MessageFns<Screenshot> = {
  encode(message: Screenshot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.alphaChannel !== false) {
      writer.uint32(16).bool(message.alphaChannel);
    }
    if (message.animated !== false) {
      writer.uint32(24).bool(message.animated);
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(34).fork()).join();
    }
    if (message.height !== 0) {
      writer.uint32(40).int32(message.height);
    }
    if (message.imageId !== "") {
      writer.uint32(50).string(message.imageId);
    }
    if (message.url !== "") {
      writer.uint32(58).string(message.url);
    }
    if (message.width !== 0) {
      writer.uint32(64).int32(message.width);
    }
    if (message.checksum !== "") {
      writer.uint32(74).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Screenshot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScreenshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.alphaChannel = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.animated = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.imageId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Screenshot {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      alphaChannel: isSet(object.alphaChannel) ? globalThis.Boolean(object.alphaChannel) : false,
      animated: isSet(object.animated) ? globalThis.Boolean(object.animated) : false,
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      imageId: isSet(object.imageId) ? globalThis.String(object.imageId) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: Screenshot): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.alphaChannel !== false) {
      obj.alphaChannel = message.alphaChannel;
    }
    if (message.animated !== false) {
      obj.animated = message.animated;
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<Screenshot>): Screenshot {
    return Screenshot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Screenshot>): Screenshot {
    const message = createBaseScreenshot();
    message.id = object.id ?? 0;
    message.alphaChannel = object.alphaChannel ?? false;
    message.animated = object.animated ?? false;
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    message.height = object.height ?? 0;
    message.imageId = object.imageId ?? "";
    message.url = object.url ?? "";
    message.width = object.width ?? 0;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseSearchResult(): SearchResult {
  return { searches: [] };
}

export const SearchResult: MessageFns<SearchResult> = {
  encode(message: SearchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.searches) {
      Search.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.searches.push(Search.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResult {
    return {
      searches: globalThis.Array.isArray(object?.searches) ? object.searches.map((e: any) => Search.fromJSON(e)) : [],
    };
  },

  toJSON(message: SearchResult): unknown {
    const obj: any = {};
    if (message.searches?.length) {
      obj.searches = message.searches.map((e) => Search.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResult>): SearchResult {
    return SearchResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResult>): SearchResult {
    const message = createBaseSearchResult();
    message.searches = object.searches?.map((e) => Search.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearch(): Search {
  return {
    id: 0,
    alternativeName: "",
    character: undefined,
    collection: undefined,
    company: undefined,
    description: "",
    game: undefined,
    name: "",
    platform: undefined,
    publishedAt: undefined,
    testDummy: undefined,
    theme: undefined,
    checksum: "",
  };
}

export const Search: MessageFns<Search> = {
  encode(message: Search, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.alternativeName !== "") {
      writer.uint32(18).string(message.alternativeName);
    }
    if (message.character !== undefined) {
      Character.encode(message.character, writer.uint32(26).fork()).join();
    }
    if (message.collection !== undefined) {
      Collection.encode(message.collection, writer.uint32(34).fork()).join();
    }
    if (message.company !== undefined) {
      Company.encode(message.company, writer.uint32(42).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(58).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(66).string(message.name);
    }
    if (message.platform !== undefined) {
      Platform.encode(message.platform, writer.uint32(74).fork()).join();
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(message.publishedAt, writer.uint32(82).fork()).join();
    }
    if (message.testDummy !== undefined) {
      TestDummy.encode(message.testDummy, writer.uint32(90).fork()).join();
    }
    if (message.theme !== undefined) {
      Theme.encode(message.theme, writer.uint32(98).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(106).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Search {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.alternativeName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.character = Character.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.collection = Collection.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.company = Company.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.platform = Platform.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.publishedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.testDummy = TestDummy.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.theme = Theme.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Search {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      alternativeName: isSet(object.alternativeName) ? globalThis.String(object.alternativeName) : "",
      character: isSet(object.character) ? Character.fromJSON(object.character) : undefined,
      collection: isSet(object.collection) ? Collection.fromJSON(object.collection) : undefined,
      company: isSet(object.company) ? Company.fromJSON(object.company) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      platform: isSet(object.platform) ? Platform.fromJSON(object.platform) : undefined,
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
      testDummy: isSet(object.testDummy) ? TestDummy.fromJSON(object.testDummy) : undefined,
      theme: isSet(object.theme) ? Theme.fromJSON(object.theme) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: Search): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.alternativeName !== "") {
      obj.alternativeName = message.alternativeName;
    }
    if (message.character !== undefined) {
      obj.character = Character.toJSON(message.character);
    }
    if (message.collection !== undefined) {
      obj.collection = Collection.toJSON(message.collection);
    }
    if (message.company !== undefined) {
      obj.company = Company.toJSON(message.company);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.platform !== undefined) {
      obj.platform = Platform.toJSON(message.platform);
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = fromTimestamp(message.publishedAt).toISOString();
    }
    if (message.testDummy !== undefined) {
      obj.testDummy = TestDummy.toJSON(message.testDummy);
    }
    if (message.theme !== undefined) {
      obj.theme = Theme.toJSON(message.theme);
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<Search>): Search {
    return Search.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Search>): Search {
    const message = createBaseSearch();
    message.id = object.id ?? 0;
    message.alternativeName = object.alternativeName ?? "";
    message.character = (object.character !== undefined && object.character !== null)
      ? Character.fromPartial(object.character)
      : undefined;
    message.collection = (object.collection !== undefined && object.collection !== null)
      ? Collection.fromPartial(object.collection)
      : undefined;
    message.company = (object.company !== undefined && object.company !== null)
      ? Company.fromPartial(object.company)
      : undefined;
    message.description = object.description ?? "";
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    message.name = object.name ?? "";
    message.platform = (object.platform !== undefined && object.platform !== null)
      ? Platform.fromPartial(object.platform)
      : undefined;
    message.publishedAt = (object.publishedAt !== undefined && object.publishedAt !== null)
      ? Timestamp.fromPartial(object.publishedAt)
      : undefined;
    message.testDummy = (object.testDummy !== undefined && object.testDummy !== null)
      ? TestDummy.fromPartial(object.testDummy)
      : undefined;
    message.theme = (object.theme !== undefined && object.theme !== null) ? Theme.fromPartial(object.theme) : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseTestDummyResult(): TestDummyResult {
  return { testdummies: [] };
}

export const TestDummyResult: MessageFns<TestDummyResult> = {
  encode(message: TestDummyResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.testdummies) {
      TestDummy.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestDummyResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestDummyResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.testdummies.push(TestDummy.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestDummyResult {
    return {
      testdummies: globalThis.Array.isArray(object?.testdummies)
        ? object.testdummies.map((e: any) => TestDummy.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TestDummyResult): unknown {
    const obj: any = {};
    if (message.testdummies?.length) {
      obj.testdummies = message.testdummies.map((e) => TestDummy.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TestDummyResult>): TestDummyResult {
    return TestDummyResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestDummyResult>): TestDummyResult {
    const message = createBaseTestDummyResult();
    message.testdummies = object.testdummies?.map((e) => TestDummy.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTestDummy(): TestDummy {
  return {
    id: 0,
    boolValue: false,
    createdAt: undefined,
    enumTest: 0,
    floatValue: 0,
    game: undefined,
    integerArray: [],
    integerValue: 0,
    name: "",
    newIntegerValue: 0,
    private: false,
    slug: "",
    stringArray: [],
    testDummies: [],
    testDummy: undefined,
    updatedAt: undefined,
    url: "",
    checksum: "",
  };
}

export const TestDummy: MessageFns<TestDummy> = {
  encode(message: TestDummy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.boolValue !== false) {
      writer.uint32(16).bool(message.boolValue);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.enumTest !== 0) {
      writer.uint32(32).int32(message.enumTest);
    }
    if (message.floatValue !== 0) {
      writer.uint32(41).double(message.floatValue);
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(50).fork()).join();
    }
    writer.uint32(58).fork();
    for (const v of message.integerArray) {
      writer.int32(v);
    }
    writer.join();
    if (message.integerValue !== 0) {
      writer.uint32(64).int32(message.integerValue);
    }
    if (message.name !== "") {
      writer.uint32(74).string(message.name);
    }
    if (message.newIntegerValue !== 0) {
      writer.uint32(80).int32(message.newIntegerValue);
    }
    if (message.private !== false) {
      writer.uint32(88).bool(message.private);
    }
    if (message.slug !== "") {
      writer.uint32(98).string(message.slug);
    }
    for (const v of message.stringArray) {
      writer.uint32(106).string(v!);
    }
    for (const v of message.testDummies) {
      TestDummy.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.testDummy !== undefined) {
      TestDummy.encode(message.testDummy, writer.uint32(122).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(130).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(138).string(message.url);
    }
    if (message.checksum !== "") {
      writer.uint32(146).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestDummy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestDummy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.enumTest = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.floatValue = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag === 56) {
            message.integerArray.push(reader.int32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.integerArray.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.integerValue = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.newIntegerValue = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.private = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.stringArray.push(reader.string());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.testDummies.push(TestDummy.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.testDummy = TestDummy.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestDummy {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : false,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      enumTest: isSet(object.enumTest) ? testDummyEnumTestEnumFromJSON(object.enumTest) : 0,
      floatValue: isSet(object.floatValue) ? globalThis.Number(object.floatValue) : 0,
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
      integerArray: globalThis.Array.isArray(object?.integerArray)
        ? object.integerArray.map((e: any) => globalThis.Number(e))
        : [],
      integerValue: isSet(object.integerValue) ? globalThis.Number(object.integerValue) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      newIntegerValue: isSet(object.newIntegerValue) ? globalThis.Number(object.newIntegerValue) : 0,
      private: isSet(object.private) ? globalThis.Boolean(object.private) : false,
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      stringArray: globalThis.Array.isArray(object?.stringArray)
        ? object.stringArray.map((e: any) => globalThis.String(e))
        : [],
      testDummies: globalThis.Array.isArray(object?.testDummies)
        ? object.testDummies.map((e: any) => TestDummy.fromJSON(e))
        : [],
      testDummy: isSet(object.testDummy) ? TestDummy.fromJSON(object.testDummy) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: TestDummy): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.boolValue !== false) {
      obj.boolValue = message.boolValue;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.enumTest !== 0) {
      obj.enumTest = testDummyEnumTestEnumToJSON(message.enumTest);
    }
    if (message.floatValue !== 0) {
      obj.floatValue = message.floatValue;
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    if (message.integerArray?.length) {
      obj.integerArray = message.integerArray.map((e) => Math.round(e));
    }
    if (message.integerValue !== 0) {
      obj.integerValue = Math.round(message.integerValue);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.newIntegerValue !== 0) {
      obj.newIntegerValue = Math.round(message.newIntegerValue);
    }
    if (message.private !== false) {
      obj.private = message.private;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.stringArray?.length) {
      obj.stringArray = message.stringArray;
    }
    if (message.testDummies?.length) {
      obj.testDummies = message.testDummies.map((e) => TestDummy.toJSON(e));
    }
    if (message.testDummy !== undefined) {
      obj.testDummy = TestDummy.toJSON(message.testDummy);
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<TestDummy>): TestDummy {
    return TestDummy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestDummy>): TestDummy {
    const message = createBaseTestDummy();
    message.id = object.id ?? 0;
    message.boolValue = object.boolValue ?? false;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.enumTest = object.enumTest ?? 0;
    message.floatValue = object.floatValue ?? 0;
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    message.integerArray = object.integerArray?.map((e) => e) || [];
    message.integerValue = object.integerValue ?? 0;
    message.name = object.name ?? "";
    message.newIntegerValue = object.newIntegerValue ?? 0;
    message.private = object.private ?? false;
    message.slug = object.slug ?? "";
    message.stringArray = object.stringArray?.map((e) => e) || [];
    message.testDummies = object.testDummies?.map((e) => TestDummy.fromPartial(e)) || [];
    message.testDummy = (object.testDummy !== undefined && object.testDummy !== null)
      ? TestDummy.fromPartial(object.testDummy)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.url = object.url ?? "";
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseThemeResult(): ThemeResult {
  return { themes: [] };
}

export const ThemeResult: MessageFns<ThemeResult> = {
  encode(message: ThemeResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.themes) {
      Theme.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ThemeResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThemeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.themes.push(Theme.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThemeResult {
    return { themes: globalThis.Array.isArray(object?.themes) ? object.themes.map((e: any) => Theme.fromJSON(e)) : [] };
  },

  toJSON(message: ThemeResult): unknown {
    const obj: any = {};
    if (message.themes?.length) {
      obj.themes = message.themes.map((e) => Theme.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ThemeResult>): ThemeResult {
    return ThemeResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThemeResult>): ThemeResult {
    const message = createBaseThemeResult();
    message.themes = object.themes?.map((e) => Theme.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTheme(): Theme {
  return { id: 0, createdAt: undefined, name: "", slug: "", updatedAt: undefined, url: "", checksum: "" };
}

export const Theme: MessageFns<Theme> = {
  encode(message: Theme, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(18).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(34).string(message.slug);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(42).fork()).join();
    }
    if (message.url !== "") {
      writer.uint32(50).string(message.url);
    }
    if (message.checksum !== "") {
      writer.uint32(58).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Theme {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTheme();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Theme {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: Theme): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<Theme>): Theme {
    return Theme.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Theme>): Theme {
    const message = createBaseTheme();
    message.id = object.id ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.name = object.name ?? "";
    message.slug = object.slug ?? "";
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.url = object.url ?? "";
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseWebsiteResult(): WebsiteResult {
  return { websites: [] };
}

export const WebsiteResult: MessageFns<WebsiteResult> = {
  encode(message: WebsiteResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.websites) {
      Website.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebsiteResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebsiteResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.websites.push(Website.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebsiteResult {
    return {
      websites: globalThis.Array.isArray(object?.websites) ? object.websites.map((e: any) => Website.fromJSON(e)) : [],
    };
  },

  toJSON(message: WebsiteResult): unknown {
    const obj: any = {};
    if (message.websites?.length) {
      obj.websites = message.websites.map((e) => Website.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<WebsiteResult>): WebsiteResult {
    return WebsiteResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebsiteResult>): WebsiteResult {
    const message = createBaseWebsiteResult();
    message.websites = object.websites?.map((e) => Website.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWebsite(): Website {
  return { id: 0, category: 0, game: undefined, trusted: false, url: "", checksum: "", type: undefined };
}

export const Website: MessageFns<Website> = {
  encode(message: Website, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.category !== 0) {
      writer.uint32(16).int32(message.category);
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(26).fork()).join();
    }
    if (message.trusted !== false) {
      writer.uint32(32).bool(message.trusted);
    }
    if (message.url !== "") {
      writer.uint32(42).string(message.url);
    }
    if (message.checksum !== "") {
      writer.uint32(50).string(message.checksum);
    }
    if (message.type !== undefined) {
      WebsiteType.encode(message.type, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Website {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebsite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.trusted = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.type = WebsiteType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Website {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      category: isSet(object.category) ? websiteCategoryEnumFromJSON(object.category) : 0,
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
      trusted: isSet(object.trusted) ? globalThis.Boolean(object.trusted) : false,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      type: isSet(object.type) ? WebsiteType.fromJSON(object.type) : undefined,
    };
  },

  toJSON(message: Website): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.category !== 0) {
      obj.category = websiteCategoryEnumToJSON(message.category);
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    if (message.trusted !== false) {
      obj.trusted = message.trusted;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.type !== undefined) {
      obj.type = WebsiteType.toJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<Website>): Website {
    return Website.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Website>): Website {
    const message = createBaseWebsite();
    message.id = object.id ?? 0;
    message.category = object.category ?? 0;
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    message.trusted = object.trusted ?? false;
    message.url = object.url ?? "";
    message.checksum = object.checksum ?? "";
    message.type = (object.type !== undefined && object.type !== null)
      ? WebsiteType.fromPartial(object.type)
      : undefined;
    return message;
  },
};

function createBaseWebsiteTypeResult(): WebsiteTypeResult {
  return { websitetypes: [] };
}

export const WebsiteTypeResult: MessageFns<WebsiteTypeResult> = {
  encode(message: WebsiteTypeResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.websitetypes) {
      WebsiteType.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebsiteTypeResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebsiteTypeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.websitetypes.push(WebsiteType.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebsiteTypeResult {
    return {
      websitetypes: globalThis.Array.isArray(object?.websitetypes)
        ? object.websitetypes.map((e: any) => WebsiteType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WebsiteTypeResult): unknown {
    const obj: any = {};
    if (message.websitetypes?.length) {
      obj.websitetypes = message.websitetypes.map((e) => WebsiteType.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<WebsiteTypeResult>): WebsiteTypeResult {
    return WebsiteTypeResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebsiteTypeResult>): WebsiteTypeResult {
    const message = createBaseWebsiteTypeResult();
    message.websitetypes = object.websitetypes?.map((e) => WebsiteType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWebsiteType(): WebsiteType {
  return { id: 0, type: "", createdAt: undefined, updatedAt: undefined, checksum: "" };
}

export const WebsiteType: MessageFns<WebsiteType> = {
  encode(message: WebsiteType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(26).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(34).fork()).join();
    }
    if (message.checksum !== "") {
      writer.uint32(42).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebsiteType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebsiteType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebsiteType {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: WebsiteType): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = fromTimestamp(message.createdAt).toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = fromTimestamp(message.updatedAt).toISOString();
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<WebsiteType>): WebsiteType {
    return WebsiteType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebsiteType>): WebsiteType {
    const message = createBaseWebsiteType();
    message.id = object.id ?? 0;
    message.type = object.type ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Timestamp.fromPartial(object.createdAt)
      : undefined;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Timestamp.fromPartial(object.updatedAt)
      : undefined;
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Timestamp {
  if (o instanceof globalThis.Date) {
    return toTimestamp(o);
  } else if (typeof o === "string") {
    return toTimestamp(new globalThis.Date(o));
  } else {
    return Timestamp.fromJSON(o);
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
