// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: retrom/server/config.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
export const protobufPackage = "retrom";
export const StorageType = {
    /**
     * SINGLE_FILE_GAME - Standard library directory with single-file games
     * e.g. /contentDir/platformX/game.rom
     */
    SINGLE_FILE_GAME: 0,
    /**
     * MULTI_FILE_GAME - Standard library directory with multi-file games
     * e.g. /contentDir/platformX/game/game.rom
     */
    MULTI_FILE_GAME: 1,
    /**
     * CUSTOM - Custom, user-defined structure composed of named macros
     * used for non-standard library directories and/or automatic
     * tagging of scanned entries
     *
     * example user definition: "/some/path/{platform}/{game}/{region}/{file}"
     */
    CUSTOM: 2,
    UNRECOGNIZED: -1,
};
export function storageTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "SINGLE_FILE_GAME":
            return StorageType.SINGLE_FILE_GAME;
        case 1:
        case "MULTI_FILE_GAME":
            return StorageType.MULTI_FILE_GAME;
        case 2:
        case "CUSTOM":
            return StorageType.CUSTOM;
        case -1:
        case "UNRECOGNIZED":
        default:
            return StorageType.UNRECOGNIZED;
    }
}
export function storageTypeToJSON(object) {
    switch (object) {
        case StorageType.SINGLE_FILE_GAME:
            return "SINGLE_FILE_GAME";
        case StorageType.MULTI_FILE_GAME:
            return "MULTI_FILE_GAME";
        case StorageType.CUSTOM:
            return "CUSTOM";
        case StorageType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseConnectionConfig() {
    return { port: undefined, dbUrl: undefined };
}
export const ConnectionConfig = {
    encode(message, writer = new BinaryWriter()) {
        if (message.port !== undefined) {
            writer.uint32(8).int32(message.port);
        }
        if (message.dbUrl !== undefined) {
            writer.uint32(18).string(message.dbUrl);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConnectionConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.port = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.dbUrl = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            port: isSet(object.port) ? globalThis.Number(object.port) : undefined,
            dbUrl: isSet(object.dbUrl) ? globalThis.String(object.dbUrl) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.port !== undefined) {
            obj.port = Math.round(message.port);
        }
        if (message.dbUrl !== undefined) {
            obj.dbUrl = message.dbUrl;
        }
        return obj;
    },
    create(base) {
        return ConnectionConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConnectionConfig();
        message.port = object.port ?? undefined;
        message.dbUrl = object.dbUrl ?? undefined;
        return message;
    },
};
function createBaseIgnorePatterns() {
    return { patterns: [] };
}
export const IgnorePatterns = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.patterns) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIgnorePatterns();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.patterns.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            patterns: globalThis.Array.isArray(object?.patterns) ? object.patterns.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.patterns?.length) {
            obj.patterns = message.patterns;
        }
        return obj;
    },
    create(base) {
        return IgnorePatterns.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseIgnorePatterns();
        message.patterns = object.patterns?.map((e) => e) || [];
        return message;
    },
};
function createBaseCustomLibraryDefinition() {
    return { definition: "" };
}
export const CustomLibraryDefinition = {
    encode(message, writer = new BinaryWriter()) {
        if (message.definition !== "") {
            writer.uint32(10).string(message.definition);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCustomLibraryDefinition();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.definition = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { definition: isSet(object.definition) ? globalThis.String(object.definition) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.definition !== "") {
            obj.definition = message.definition;
        }
        return obj;
    },
    create(base) {
        return CustomLibraryDefinition.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCustomLibraryDefinition();
        message.definition = object.definition ?? "";
        return message;
    },
};
function createBaseContentDirectory() {
    return { path: "", storageType: undefined, ignorePatterns: undefined, customLibraryDefinition: undefined };
}
export const ContentDirectory = {
    encode(message, writer = new BinaryWriter()) {
        if (message.path !== "") {
            writer.uint32(10).string(message.path);
        }
        if (message.storageType !== undefined) {
            writer.uint32(16).int32(message.storageType);
        }
        if (message.ignorePatterns !== undefined) {
            IgnorePatterns.encode(message.ignorePatterns, writer.uint32(26).fork()).join();
        }
        if (message.customLibraryDefinition !== undefined) {
            CustomLibraryDefinition.encode(message.customLibraryDefinition, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContentDirectory();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.path = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.storageType = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.ignorePatterns = IgnorePatterns.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.customLibraryDefinition = CustomLibraryDefinition.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            path: isSet(object.path) ? globalThis.String(object.path) : "",
            storageType: isSet(object.storageType) ? storageTypeFromJSON(object.storageType) : undefined,
            ignorePatterns: isSet(object.ignorePatterns) ? IgnorePatterns.fromJSON(object.ignorePatterns) : undefined,
            customLibraryDefinition: isSet(object.customLibraryDefinition)
                ? CustomLibraryDefinition.fromJSON(object.customLibraryDefinition)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.path !== "") {
            obj.path = message.path;
        }
        if (message.storageType !== undefined) {
            obj.storageType = storageTypeToJSON(message.storageType);
        }
        if (message.ignorePatterns !== undefined) {
            obj.ignorePatterns = IgnorePatterns.toJSON(message.ignorePatterns);
        }
        if (message.customLibraryDefinition !== undefined) {
            obj.customLibraryDefinition = CustomLibraryDefinition.toJSON(message.customLibraryDefinition);
        }
        return obj;
    },
    create(base) {
        return ContentDirectory.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseContentDirectory();
        message.path = object.path ?? "";
        message.storageType = object.storageType ?? undefined;
        message.ignorePatterns = (object.ignorePatterns !== undefined && object.ignorePatterns !== null)
            ? IgnorePatterns.fromPartial(object.ignorePatterns)
            : undefined;
        message.customLibraryDefinition =
            (object.customLibraryDefinition !== undefined && object.customLibraryDefinition !== null)
                ? CustomLibraryDefinition.fromPartial(object.customLibraryDefinition)
                : undefined;
        return message;
    },
};
function createBaseIGDBConfig() {
    return { clientId: "", clientSecret: "" };
}
export const IGDBConfig = {
    encode(message, writer = new BinaryWriter()) {
        if (message.clientId !== "") {
            writer.uint32(10).string(message.clientId);
        }
        if (message.clientSecret !== "") {
            writer.uint32(18).string(message.clientSecret);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIGDBConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.clientId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.clientSecret = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
            clientSecret: isSet(object.clientSecret) ? globalThis.String(object.clientSecret) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.clientId !== "") {
            obj.clientId = message.clientId;
        }
        if (message.clientSecret !== "") {
            obj.clientSecret = message.clientSecret;
        }
        return obj;
    },
    create(base) {
        return IGDBConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseIGDBConfig();
        message.clientId = object.clientId ?? "";
        message.clientSecret = object.clientSecret ?? "";
        return message;
    },
};
function createBaseSteamConfig() {
    return { apiKey: "", userId: "" };
}
export const SteamConfig = {
    encode(message, writer = new BinaryWriter()) {
        if (message.apiKey !== "") {
            writer.uint32(10).string(message.apiKey);
        }
        if (message.userId !== "") {
            writer.uint32(18).string(message.userId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSteamConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.apiKey = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.userId = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            apiKey: isSet(object.apiKey) ? globalThis.String(object.apiKey) : "",
            userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.apiKey !== "") {
            obj.apiKey = message.apiKey;
        }
        if (message.userId !== "") {
            obj.userId = message.userId;
        }
        return obj;
    },
    create(base) {
        return SteamConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSteamConfig();
        message.apiKey = object.apiKey ?? "";
        message.userId = object.userId ?? "";
        return message;
    },
};
function createBaseServerConfig() {
    return { connection: undefined, contentDirectories: [], igdb: undefined, steam: undefined };
}
export const ServerConfig = {
    encode(message, writer = new BinaryWriter()) {
        if (message.connection !== undefined) {
            ConnectionConfig.encode(message.connection, writer.uint32(10).fork()).join();
        }
        for (const v of message.contentDirectories) {
            ContentDirectory.encode(v, writer.uint32(18).fork()).join();
        }
        if (message.igdb !== undefined) {
            IGDBConfig.encode(message.igdb, writer.uint32(26).fork()).join();
        }
        if (message.steam !== undefined) {
            SteamConfig.encode(message.steam, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseServerConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.connection = ConnectionConfig.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.contentDirectories.push(ContentDirectory.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.igdb = IGDBConfig.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.steam = SteamConfig.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            connection: isSet(object.connection) ? ConnectionConfig.fromJSON(object.connection) : undefined,
            contentDirectories: globalThis.Array.isArray(object?.contentDirectories)
                ? object.contentDirectories.map((e) => ContentDirectory.fromJSON(e))
                : [],
            igdb: isSet(object.igdb) ? IGDBConfig.fromJSON(object.igdb) : undefined,
            steam: isSet(object.steam) ? SteamConfig.fromJSON(object.steam) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.connection !== undefined) {
            obj.connection = ConnectionConfig.toJSON(message.connection);
        }
        if (message.contentDirectories?.length) {
            obj.contentDirectories = message.contentDirectories.map((e) => ContentDirectory.toJSON(e));
        }
        if (message.igdb !== undefined) {
            obj.igdb = IGDBConfig.toJSON(message.igdb);
        }
        if (message.steam !== undefined) {
            obj.steam = SteamConfig.toJSON(message.steam);
        }
        return obj;
    },
    create(base) {
        return ServerConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseServerConfig();
        message.connection = (object.connection !== undefined && object.connection !== null)
            ? ConnectionConfig.fromPartial(object.connection)
            : undefined;
        message.contentDirectories = object.contentDirectories?.map((e) => ContentDirectory.fromPartial(e)) || [];
        message.igdb = (object.igdb !== undefined && object.igdb !== null)
            ? IGDBConfig.fromPartial(object.igdb)
            : undefined;
        message.steam = (object.steam !== undefined && object.steam !== null)
            ? SteamConfig.fromPartial(object.steam)
            : undefined;
        return message;
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
