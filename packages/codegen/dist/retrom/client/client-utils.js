// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: retrom/client/client-utils.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Emulator, EmulatorProfile } from "../models/emulators";
import { GameFile } from "../models/game-files";
import { Game } from "../models/games";
export const protobufPackage = "retrom";
export const InstallationStatus = { INSTALLED: 0, INSTALLING: 1, NOT_INSTALLED: 2, UNRECOGNIZED: -1 };
export function installationStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "INSTALLED":
            return InstallationStatus.INSTALLED;
        case 1:
        case "INSTALLING":
            return InstallationStatus.INSTALLING;
        case 2:
        case "NOT_INSTALLED":
            return InstallationStatus.NOT_INSTALLED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return InstallationStatus.UNRECOGNIZED;
    }
}
export function installationStatusToJSON(object) {
    switch (object) {
        case InstallationStatus.INSTALLED:
            return "INSTALLED";
        case InstallationStatus.INSTALLING:
            return "INSTALLING";
        case InstallationStatus.NOT_INSTALLED:
            return "NOT_INSTALLED";
        case InstallationStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export const PlayStatus = { PLAYING: 0, NOT_PLAYING: 1, UNRECOGNIZED: -1 };
export function playStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "PLAYING":
            return PlayStatus.PLAYING;
        case 1:
        case "NOT_PLAYING":
            return PlayStatus.NOT_PLAYING;
        case -1:
        case "UNRECOGNIZED":
        default:
            return PlayStatus.UNRECOGNIZED;
    }
}
export function playStatusToJSON(object) {
    switch (object) {
        case PlayStatus.PLAYING:
            return "PLAYING";
        case PlayStatus.NOT_PLAYING:
            return "NOT_PLAYING";
        case PlayStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseRetromHostInfo() {
    return { hostName: "", port: "", host: "" };
}
export const RetromHostInfo = {
    encode(message, writer = new BinaryWriter()) {
        if (message.hostName !== "") {
            writer.uint32(10).string(message.hostName);
        }
        if (message.port !== "") {
            writer.uint32(18).string(message.port);
        }
        if (message.host !== "") {
            writer.uint32(26).string(message.host);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRetromHostInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.hostName = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.port = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.host = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            hostName: isSet(object.hostName) ? globalThis.String(object.hostName) : "",
            port: isSet(object.port) ? globalThis.String(object.port) : "",
            host: isSet(object.host) ? globalThis.String(object.host) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.hostName !== "") {
            obj.hostName = message.hostName;
        }
        if (message.port !== "") {
            obj.port = message.port;
        }
        if (message.host !== "") {
            obj.host = message.host;
        }
        return obj;
    },
    create(base) {
        return RetromHostInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRetromHostInfo();
        message.hostName = object.hostName ?? "";
        message.port = object.port ?? "";
        message.host = object.host ?? "";
        return message;
    },
};
function createBaseInstallationProgressUpdate() {
    return { gameId: 0, progress: 0 };
}
export const InstallationProgressUpdate = {
    encode(message, writer = new BinaryWriter()) {
        if (message.gameId !== 0) {
            writer.uint32(8).int32(message.gameId);
        }
        if (message.progress !== 0) {
            writer.uint32(16).uint32(message.progress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallationProgressUpdate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.gameId = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.progress = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            gameId: isSet(object.gameId) ? globalThis.Number(object.gameId) : 0,
            progress: isSet(object.progress) ? globalThis.Number(object.progress) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.gameId !== 0) {
            obj.gameId = Math.round(message.gameId);
        }
        if (message.progress !== 0) {
            obj.progress = Math.round(message.progress);
        }
        return obj;
    },
    create(base) {
        return InstallationProgressUpdate.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInstallationProgressUpdate();
        message.gameId = object.gameId ?? 0;
        message.progress = object.progress ?? 0;
        return message;
    },
};
function createBaseInstallGamePayload() {
    return { game: undefined, files: [] };
}
export const InstallGamePayload = {
    encode(message, writer = new BinaryWriter()) {
        if (message.game !== undefined) {
            Game.encode(message.game, writer.uint32(10).fork()).join();
        }
        for (const v of message.files) {
            GameFile.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallGamePayload();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.game = Game.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.files.push(GameFile.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
            files: globalThis.Array.isArray(object?.files) ? object.files.map((e) => GameFile.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.game !== undefined) {
            obj.game = Game.toJSON(message.game);
        }
        if (message.files?.length) {
            obj.files = message.files.map((e) => GameFile.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return InstallGamePayload.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInstallGamePayload();
        message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
        message.files = object.files?.map((e) => GameFile.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUninstallGamePayload() {
    return { game: undefined };
}
export const UninstallGamePayload = {
    encode(message, writer = new BinaryWriter()) {
        if (message.game !== undefined) {
            Game.encode(message.game, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUninstallGamePayload();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.game = Game.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { game: isSet(object.game) ? Game.fromJSON(object.game) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.game !== undefined) {
            obj.game = Game.toJSON(message.game);
        }
        return obj;
    },
    create(base) {
        return UninstallGamePayload.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUninstallGamePayload();
        message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
        return message;
    },
};
function createBasePlayGamePayload() {
    return { game: undefined, emulatorProfile: undefined, emulator: undefined, file: undefined };
}
export const PlayGamePayload = {
    encode(message, writer = new BinaryWriter()) {
        if (message.game !== undefined) {
            Game.encode(message.game, writer.uint32(10).fork()).join();
        }
        if (message.emulatorProfile !== undefined) {
            EmulatorProfile.encode(message.emulatorProfile, writer.uint32(18).fork()).join();
        }
        if (message.emulator !== undefined) {
            Emulator.encode(message.emulator, writer.uint32(26).fork()).join();
        }
        if (message.file !== undefined) {
            GameFile.encode(message.file, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlayGamePayload();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.game = Game.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.emulatorProfile = EmulatorProfile.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.emulator = Emulator.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.file = GameFile.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
            emulatorProfile: isSet(object.emulatorProfile) ? EmulatorProfile.fromJSON(object.emulatorProfile) : undefined,
            emulator: isSet(object.emulator) ? Emulator.fromJSON(object.emulator) : undefined,
            file: isSet(object.file) ? GameFile.fromJSON(object.file) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.game !== undefined) {
            obj.game = Game.toJSON(message.game);
        }
        if (message.emulatorProfile !== undefined) {
            obj.emulatorProfile = EmulatorProfile.toJSON(message.emulatorProfile);
        }
        if (message.emulator !== undefined) {
            obj.emulator = Emulator.toJSON(message.emulator);
        }
        if (message.file !== undefined) {
            obj.file = GameFile.toJSON(message.file);
        }
        return obj;
    },
    create(base) {
        return PlayGamePayload.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePlayGamePayload();
        message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
        message.emulatorProfile = (object.emulatorProfile !== undefined && object.emulatorProfile !== null)
            ? EmulatorProfile.fromPartial(object.emulatorProfile)
            : undefined;
        message.emulator = (object.emulator !== undefined && object.emulator !== null)
            ? Emulator.fromPartial(object.emulator)
            : undefined;
        message.file = (object.file !== undefined && object.file !== null) ? GameFile.fromPartial(object.file) : undefined;
        return message;
    },
};
function createBaseStopGamePayload() {
    return { game: undefined };
}
export const StopGamePayload = {
    encode(message, writer = new BinaryWriter()) {
        if (message.game !== undefined) {
            Game.encode(message.game, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStopGamePayload();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.game = Game.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { game: isSet(object.game) ? Game.fromJSON(object.game) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.game !== undefined) {
            obj.game = Game.toJSON(message.game);
        }
        return obj;
    },
    create(base) {
        return StopGamePayload.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStopGamePayload();
        message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
        return message;
    },
};
function createBaseGetGamePlayStatusPayload() {
    return { game: undefined };
}
export const GetGamePlayStatusPayload = {
    encode(message, writer = new BinaryWriter()) {
        if (message.game !== undefined) {
            Game.encode(message.game, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetGamePlayStatusPayload();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.game = Game.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { game: isSet(object.game) ? Game.fromJSON(object.game) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.game !== undefined) {
            obj.game = Game.toJSON(message.game);
        }
        return obj;
    },
    create(base) {
        return GetGamePlayStatusPayload.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetGamePlayStatusPayload();
        message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
        return message;
    },
};
function createBaseGamePlayStatusUpdate() {
    return { gameId: 0, playStatus: 0 };
}
export const GamePlayStatusUpdate = {
    encode(message, writer = new BinaryWriter()) {
        if (message.gameId !== 0) {
            writer.uint32(8).int32(message.gameId);
        }
        if (message.playStatus !== 0) {
            writer.uint32(16).int32(message.playStatus);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGamePlayStatusUpdate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.gameId = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.playStatus = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            gameId: isSet(object.gameId) ? globalThis.Number(object.gameId) : 0,
            playStatus: isSet(object.playStatus) ? playStatusFromJSON(object.playStatus) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.gameId !== 0) {
            obj.gameId = Math.round(message.gameId);
        }
        if (message.playStatus !== 0) {
            obj.playStatus = playStatusToJSON(message.playStatus);
        }
        return obj;
    },
    create(base) {
        return GamePlayStatusUpdate.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGamePlayStatusUpdate();
        message.gameId = object.gameId ?? 0;
        message.playStatus = object.playStatus ?? 0;
        return message;
    },
};
function createBaseInstallationState() {
    return { installationState: new Map() };
}
export const InstallationState = {
    encode(message, writer = new BinaryWriter()) {
        message.installationState.forEach((value, key) => {
            InstallationState_InstallationStateEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallationState();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = InstallationState_InstallationStateEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.installationState.set(entry1.key, entry1.value);
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            installationState: isObject(object.installationState)
                ? Object.entries(object.installationState).reduce((acc, [key, value]) => {
                    acc.set(globalThis.Number(key), installationStatusFromJSON(value));
                    return acc;
                }, new Map())
                : new Map(),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.installationState?.size) {
            obj.installationState = {};
            message.installationState.forEach((v, k) => {
                obj.installationState[k] = installationStatusToJSON(v);
            });
        }
        return obj;
    },
    create(base) {
        return InstallationState.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInstallationState();
        message.installationState = (() => {
            const m = new Map();
            (object.installationState ?? new Map()).forEach((value, key) => {
                if (value !== undefined) {
                    m.set(key, value);
                }
            });
            return m;
        })();
        return message;
    },
};
function createBaseInstallationState_InstallationStateEntry() {
    return { key: 0, value: 0 };
}
export const InstallationState_InstallationStateEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== 0) {
            writer.uint32(8).int32(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallationState_InstallationStateEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.key = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.value = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.Number(object.key) : 0,
            value: isSet(object.value) ? installationStatusFromJSON(object.value) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== 0) {
            obj.key = Math.round(message.key);
        }
        if (message.value !== 0) {
            obj.value = installationStatusToJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return InstallationState_InstallationStateEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInstallationState_InstallationStateEntry();
        message.key = object.key ?? 0;
        message.value = object.value ?? 0;
        return message;
    },
};
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
