// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: retrom/services.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { FilesystemNode } from "./file-explorer";
import { JobProgress } from "./jobs";
import { Client, NewClient, UpdatedClient } from "./models/clients";
import { DefaultEmulatorProfile, Emulator, EmulatorProfile, LocalEmulatorConfig, NewEmulator, NewEmulatorProfile, NewLocalEmulatorConfig, UpdatedDefaultEmulatorProfile, UpdatedEmulator, UpdatedEmulatorProfile, UpdatedLocalEmulatorConfig, } from "./models/emulators";
import { GameFile, UpdatedGameFile } from "./models/game-files";
import { Game, UpdatedGame } from "./models/games";
import { GameGenre, GameMetadata, NewGameMetadata, NewPlatformMetadata, PlatformMetadata, UpdatedGameMetadata, UpdatedPlatformMetadata, } from "./models/metadata";
import { Platform, UpdatedPlatform } from "./models/platforms";
import { IgdbFields, IgdbFilters, IgdbGameSearchQuery, IgdbPagination, IgdbPlatformSearchQuery, IgdbSearch, } from "./providers/igdb";
import { ServerConfig } from "./server/config";
import { ServerInfo } from "./server/server-info";
export const protobufPackage = "retrom";
export const GetIgdbSearchRequest_IgdbSearchType = { GAME: 0, PLATFORM: 1, UNRECOGNIZED: -1 };
export function getIgdbSearchRequest_IgdbSearchTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "GAME":
            return GetIgdbSearchRequest_IgdbSearchType.GAME;
        case 1:
        case "PLATFORM":
            return GetIgdbSearchRequest_IgdbSearchType.PLATFORM;
        case -1:
        case "UNRECOGNIZED":
        default:
            return GetIgdbSearchRequest_IgdbSearchType.UNRECOGNIZED;
    }
}
export function getIgdbSearchRequest_IgdbSearchTypeToJSON(object) {
    switch (object) {
        case GetIgdbSearchRequest_IgdbSearchType.GAME:
            return "GAME";
        case GetIgdbSearchRequest_IgdbSearchType.PLATFORM:
            return "PLATFORM";
        case GetIgdbSearchRequest_IgdbSearchType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseUpdateLibraryRequest() {
    return {};
}
export const UpdateLibraryRequest = {
    encode(_, writer = new BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateLibraryRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return UpdateLibraryRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseUpdateLibraryRequest();
        return message;
    },
};
function createBaseUpdateLibraryResponse() {
    return { jobIds: [] };
}
export const UpdateLibraryResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.jobIds) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateLibraryResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.jobIds.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            jobIds: globalThis.Array.isArray(object?.jobIds) ? object.jobIds.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.jobIds?.length) {
            obj.jobIds = message.jobIds;
        }
        return obj;
    },
    create(base) {
        return UpdateLibraryResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateLibraryResponse();
        message.jobIds = object.jobIds?.map((e) => e) || [];
        return message;
    },
};
function createBaseUpdateLibraryMetadataRequest() {
    return { overwrite: undefined };
}
export const UpdateLibraryMetadataRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.overwrite !== undefined) {
            writer.uint32(8).bool(message.overwrite);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateLibraryMetadataRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.overwrite = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { overwrite: isSet(object.overwrite) ? globalThis.Boolean(object.overwrite) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.overwrite !== undefined) {
            obj.overwrite = message.overwrite;
        }
        return obj;
    },
    create(base) {
        return UpdateLibraryMetadataRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateLibraryMetadataRequest();
        message.overwrite = object.overwrite ?? undefined;
        return message;
    },
};
function createBaseUpdateLibraryMetadataResponse() {
    return { platformMetadataJobId: "", gameMetadataJobId: "", extraMetadataJobId: "", steamMetadataJobId: undefined };
}
export const UpdateLibraryMetadataResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.platformMetadataJobId !== "") {
            writer.uint32(10).string(message.platformMetadataJobId);
        }
        if (message.gameMetadataJobId !== "") {
            writer.uint32(18).string(message.gameMetadataJobId);
        }
        if (message.extraMetadataJobId !== "") {
            writer.uint32(26).string(message.extraMetadataJobId);
        }
        if (message.steamMetadataJobId !== undefined) {
            writer.uint32(34).string(message.steamMetadataJobId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateLibraryMetadataResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.platformMetadataJobId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.gameMetadataJobId = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.extraMetadataJobId = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.steamMetadataJobId = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            platformMetadataJobId: isSet(object.platformMetadataJobId) ? globalThis.String(object.platformMetadataJobId) : "",
            gameMetadataJobId: isSet(object.gameMetadataJobId) ? globalThis.String(object.gameMetadataJobId) : "",
            extraMetadataJobId: isSet(object.extraMetadataJobId) ? globalThis.String(object.extraMetadataJobId) : "",
            steamMetadataJobId: isSet(object.steamMetadataJobId) ? globalThis.String(object.steamMetadataJobId) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.platformMetadataJobId !== "") {
            obj.platformMetadataJobId = message.platformMetadataJobId;
        }
        if (message.gameMetadataJobId !== "") {
            obj.gameMetadataJobId = message.gameMetadataJobId;
        }
        if (message.extraMetadataJobId !== "") {
            obj.extraMetadataJobId = message.extraMetadataJobId;
        }
        if (message.steamMetadataJobId !== undefined) {
            obj.steamMetadataJobId = message.steamMetadataJobId;
        }
        return obj;
    },
    create(base) {
        return UpdateLibraryMetadataResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateLibraryMetadataResponse();
        message.platformMetadataJobId = object.platformMetadataJobId ?? "";
        message.gameMetadataJobId = object.gameMetadataJobId ?? "";
        message.extraMetadataJobId = object.extraMetadataJobId ?? "";
        message.steamMetadataJobId = object.steamMetadataJobId ?? undefined;
        return message;
    },
};
function createBaseGetPlatformsRequest() {
    return { ids: [], withMetadata: undefined, includeDeleted: undefined };
}
export const GetPlatformsRequest = {
    encode(message, writer = new BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.ids) {
            writer.int32(v);
        }
        writer.join();
        if (message.withMetadata !== undefined) {
            writer.uint32(16).bool(message.withMetadata);
        }
        if (message.includeDeleted !== undefined) {
            writer.uint32(24).bool(message.includeDeleted);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPlatformsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.ids.push(reader.int32());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.ids.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.withMetadata = reader.bool();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.includeDeleted = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e) => globalThis.Number(e)) : [],
            withMetadata: isSet(object.withMetadata) ? globalThis.Boolean(object.withMetadata) : undefined,
            includeDeleted: isSet(object.includeDeleted) ? globalThis.Boolean(object.includeDeleted) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ids?.length) {
            obj.ids = message.ids.map((e) => Math.round(e));
        }
        if (message.withMetadata !== undefined) {
            obj.withMetadata = message.withMetadata;
        }
        if (message.includeDeleted !== undefined) {
            obj.includeDeleted = message.includeDeleted;
        }
        return obj;
    },
    create(base) {
        return GetPlatformsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetPlatformsRequest();
        message.ids = object.ids?.map((e) => e) || [];
        message.withMetadata = object.withMetadata ?? undefined;
        message.includeDeleted = object.includeDeleted ?? undefined;
        return message;
    },
};
function createBaseGetPlatformsResponse() {
    return { platforms: [], metadata: [] };
}
export const GetPlatformsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.platforms) {
            Platform.encode(v, writer.uint32(10).fork()).join();
        }
        for (const v of message.metadata) {
            PlatformMetadata.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPlatformsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.platforms.push(Platform.decode(reader, reader.uint32()));
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.metadata.push(PlatformMetadata.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            platforms: globalThis.Array.isArray(object?.platforms)
                ? object.platforms.map((e) => Platform.fromJSON(e))
                : [],
            metadata: globalThis.Array.isArray(object?.metadata)
                ? object.metadata.map((e) => PlatformMetadata.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.platforms?.length) {
            obj.platforms = message.platforms.map((e) => Platform.toJSON(e));
        }
        if (message.metadata?.length) {
            obj.metadata = message.metadata.map((e) => PlatformMetadata.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GetPlatformsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetPlatformsResponse();
        message.platforms = object.platforms?.map((e) => Platform.fromPartial(e)) || [];
        message.metadata = object.metadata?.map((e) => PlatformMetadata.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGetGamesRequest() {
    return { platformIds: [], ids: [], withMetadata: undefined, withFiles: undefined, includeDeleted: undefined };
}
export const GetGamesRequest = {
    encode(message, writer = new BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.platformIds) {
            writer.int32(v);
        }
        writer.join();
        writer.uint32(18).fork();
        for (const v of message.ids) {
            writer.int32(v);
        }
        writer.join();
        if (message.withMetadata !== undefined) {
            writer.uint32(24).bool(message.withMetadata);
        }
        if (message.withFiles !== undefined) {
            writer.uint32(32).bool(message.withFiles);
        }
        if (message.includeDeleted !== undefined) {
            writer.uint32(40).bool(message.includeDeleted);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetGamesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.platformIds.push(reader.int32());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.platformIds.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
                case 2: {
                    if (tag === 16) {
                        message.ids.push(reader.int32());
                        continue;
                    }
                    if (tag === 18) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.ids.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.withMetadata = reader.bool();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.withFiles = reader.bool();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.includeDeleted = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            platformIds: globalThis.Array.isArray(object?.platformIds)
                ? object.platformIds.map((e) => globalThis.Number(e))
                : [],
            ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e) => globalThis.Number(e)) : [],
            withMetadata: isSet(object.withMetadata) ? globalThis.Boolean(object.withMetadata) : undefined,
            withFiles: isSet(object.withFiles) ? globalThis.Boolean(object.withFiles) : undefined,
            includeDeleted: isSet(object.includeDeleted) ? globalThis.Boolean(object.includeDeleted) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.platformIds?.length) {
            obj.platformIds = message.platformIds.map((e) => Math.round(e));
        }
        if (message.ids?.length) {
            obj.ids = message.ids.map((e) => Math.round(e));
        }
        if (message.withMetadata !== undefined) {
            obj.withMetadata = message.withMetadata;
        }
        if (message.withFiles !== undefined) {
            obj.withFiles = message.withFiles;
        }
        if (message.includeDeleted !== undefined) {
            obj.includeDeleted = message.includeDeleted;
        }
        return obj;
    },
    create(base) {
        return GetGamesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetGamesRequest();
        message.platformIds = object.platformIds?.map((e) => e) || [];
        message.ids = object.ids?.map((e) => e) || [];
        message.withMetadata = object.withMetadata ?? undefined;
        message.withFiles = object.withFiles ?? undefined;
        message.includeDeleted = object.includeDeleted ?? undefined;
        return message;
    },
};
function createBaseGetGamesResponse() {
    return { games: [], metadata: [], gameFiles: [] };
}
export const GetGamesResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.games) {
            Game.encode(v, writer.uint32(10).fork()).join();
        }
        for (const v of message.metadata) {
            GameMetadata.encode(v, writer.uint32(18).fork()).join();
        }
        for (const v of message.gameFiles) {
            GameFile.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetGamesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.games.push(Game.decode(reader, reader.uint32()));
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.metadata.push(GameMetadata.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.gameFiles.push(GameFile.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            games: globalThis.Array.isArray(object?.games) ? object.games.map((e) => Game.fromJSON(e)) : [],
            metadata: globalThis.Array.isArray(object?.metadata)
                ? object.metadata.map((e) => GameMetadata.fromJSON(e))
                : [],
            gameFiles: globalThis.Array.isArray(object?.gameFiles)
                ? object.gameFiles.map((e) => GameFile.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.games?.length) {
            obj.games = message.games.map((e) => Game.toJSON(e));
        }
        if (message.metadata?.length) {
            obj.metadata = message.metadata.map((e) => GameMetadata.toJSON(e));
        }
        if (message.gameFiles?.length) {
            obj.gameFiles = message.gameFiles.map((e) => GameFile.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GetGamesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetGamesResponse();
        message.games = object.games?.map((e) => Game.fromPartial(e)) || [];
        message.metadata = object.metadata?.map((e) => GameMetadata.fromPartial(e)) || [];
        message.gameFiles = object.gameFiles?.map((e) => GameFile.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGetGameMetadataRequest() {
    return { gameIds: [] };
}
export const GetGameMetadataRequest = {
    encode(message, writer = new BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.gameIds) {
            writer.int32(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetGameMetadataRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.gameIds.push(reader.int32());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.gameIds.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            gameIds: globalThis.Array.isArray(object?.gameIds) ? object.gameIds.map((e) => globalThis.Number(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.gameIds?.length) {
            obj.gameIds = message.gameIds.map((e) => Math.round(e));
        }
        return obj;
    },
    create(base) {
        return GetGameMetadataRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetGameMetadataRequest();
        message.gameIds = object.gameIds?.map((e) => e) || [];
        return message;
    },
};
function createBaseGetGameMetadataResponse() {
    return { metadata: [], similarGames: new Map(), genres: new Map() };
}
export const GetGameMetadataResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.metadata) {
            GameMetadata.encode(v, writer.uint32(10).fork()).join();
        }
        message.similarGames.forEach((value, key) => {
            GetGameMetadataResponse_SimilarGamesEntry.encode({ key: key, value }, writer.uint32(18).fork()).join();
        });
        message.genres.forEach((value, key) => {
            GetGameMetadataResponse_GenresEntry.encode({ key: key, value }, writer.uint32(26).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetGameMetadataResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata.push(GameMetadata.decode(reader, reader.uint32()));
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = GetGameMetadataResponse_SimilarGamesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.similarGames.set(entry2.key, entry2.value);
                    }
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    const entry3 = GetGameMetadataResponse_GenresEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.genres.set(entry3.key, entry3.value);
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: globalThis.Array.isArray(object?.metadata)
                ? object.metadata.map((e) => GameMetadata.fromJSON(e))
                : [],
            similarGames: isObject(object.similarGames)
                ? Object.entries(object.similarGames).reduce((acc, [key, value]) => {
                    acc.set(globalThis.Number(key), GetGameMetadataResponse_SimilarGames.fromJSON(value));
                    return acc;
                }, new Map())
                : new Map(),
            genres: isObject(object.genres)
                ? Object.entries(object.genres).reduce((acc, [key, value]) => {
                    acc.set(globalThis.Number(key), GetGameMetadataResponse_GameGenres.fromJSON(value));
                    return acc;
                }, new Map())
                : new Map(),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata?.length) {
            obj.metadata = message.metadata.map((e) => GameMetadata.toJSON(e));
        }
        if (message.similarGames?.size) {
            obj.similarGames = {};
            message.similarGames.forEach((v, k) => {
                obj.similarGames[k] = GetGameMetadataResponse_SimilarGames.toJSON(v);
            });
        }
        if (message.genres?.size) {
            obj.genres = {};
            message.genres.forEach((v, k) => {
                obj.genres[k] = GetGameMetadataResponse_GameGenres.toJSON(v);
            });
        }
        return obj;
    },
    create(base) {
        return GetGameMetadataResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetGameMetadataResponse();
        message.metadata = object.metadata?.map((e) => GameMetadata.fromPartial(e)) || [];
        message.similarGames = (() => {
            const m = new Map();
            (object.similarGames ?? new Map()).forEach((value, key) => {
                if (value !== undefined) {
                    m.set(key, GetGameMetadataResponse_SimilarGames.fromPartial(value));
                }
            });
            return m;
        })();
        message.genres = (() => {
            const m = new Map();
            (object.genres ?? new Map()).forEach((value, key) => {
                if (value !== undefined) {
                    m.set(key, GetGameMetadataResponse_GameGenres.fromPartial(value));
                }
            });
            return m;
        })();
        return message;
    },
};
function createBaseGetGameMetadataResponse_GameGenres() {
    return { value: [] };
}
export const GetGameMetadataResponse_GameGenres = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.value) {
            GameGenre.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetGameMetadataResponse_GameGenres();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.value.push(GameGenre.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            value: globalThis.Array.isArray(object?.value) ? object.value.map((e) => GameGenre.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.value?.length) {
            obj.value = message.value.map((e) => GameGenre.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GetGameMetadataResponse_GameGenres.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetGameMetadataResponse_GameGenres();
        message.value = object.value?.map((e) => GameGenre.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGetGameMetadataResponse_SimilarGames() {
    return { value: [] };
}
export const GetGameMetadataResponse_SimilarGames = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.value) {
            Game.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetGameMetadataResponse_SimilarGames();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.value.push(Game.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { value: globalThis.Array.isArray(object?.value) ? object.value.map((e) => Game.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.value?.length) {
            obj.value = message.value.map((e) => Game.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GetGameMetadataResponse_SimilarGames.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetGameMetadataResponse_SimilarGames();
        message.value = object.value?.map((e) => Game.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGetGameMetadataResponse_SimilarGamesEntry() {
    return { key: 0, value: undefined };
}
export const GetGameMetadataResponse_SimilarGamesEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== 0) {
            writer.uint32(8).int32(message.key);
        }
        if (message.value !== undefined) {
            GetGameMetadataResponse_SimilarGames.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetGameMetadataResponse_SimilarGamesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.key = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = GetGameMetadataResponse_SimilarGames.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.Number(object.key) : 0,
            value: isSet(object.value) ? GetGameMetadataResponse_SimilarGames.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== 0) {
            obj.key = Math.round(message.key);
        }
        if (message.value !== undefined) {
            obj.value = GetGameMetadataResponse_SimilarGames.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return GetGameMetadataResponse_SimilarGamesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetGameMetadataResponse_SimilarGamesEntry();
        message.key = object.key ?? 0;
        message.value = (object.value !== undefined && object.value !== null)
            ? GetGameMetadataResponse_SimilarGames.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseGetGameMetadataResponse_GenresEntry() {
    return { key: 0, value: undefined };
}
export const GetGameMetadataResponse_GenresEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== 0) {
            writer.uint32(8).int32(message.key);
        }
        if (message.value !== undefined) {
            GetGameMetadataResponse_GameGenres.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetGameMetadataResponse_GenresEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.key = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = GetGameMetadataResponse_GameGenres.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.Number(object.key) : 0,
            value: isSet(object.value) ? GetGameMetadataResponse_GameGenres.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== 0) {
            obj.key = Math.round(message.key);
        }
        if (message.value !== undefined) {
            obj.value = GetGameMetadataResponse_GameGenres.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return GetGameMetadataResponse_GenresEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetGameMetadataResponse_GenresEntry();
        message.key = object.key ?? 0;
        message.value = (object.value !== undefined && object.value !== null)
            ? GetGameMetadataResponse_GameGenres.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseGetPlatformMetadataRequest() {
    return { platformIds: [] };
}
export const GetPlatformMetadataRequest = {
    encode(message, writer = new BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.platformIds) {
            writer.int32(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPlatformMetadataRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.platformIds.push(reader.int32());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.platformIds.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            platformIds: globalThis.Array.isArray(object?.platformIds)
                ? object.platformIds.map((e) => globalThis.Number(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.platformIds?.length) {
            obj.platformIds = message.platformIds.map((e) => Math.round(e));
        }
        return obj;
    },
    create(base) {
        return GetPlatformMetadataRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetPlatformMetadataRequest();
        message.platformIds = object.platformIds?.map((e) => e) || [];
        return message;
    },
};
function createBaseGetPlatformMetadataResponse() {
    return { metadata: [] };
}
export const GetPlatformMetadataResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.metadata) {
            PlatformMetadata.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPlatformMetadataResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata.push(PlatformMetadata.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: globalThis.Array.isArray(object?.metadata)
                ? object.metadata.map((e) => PlatformMetadata.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata?.length) {
            obj.metadata = message.metadata.map((e) => PlatformMetadata.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GetPlatformMetadataResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetPlatformMetadataResponse();
        message.metadata = object.metadata?.map((e) => PlatformMetadata.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGetIgdbGameSearchResultsRequest() {
    return { query: undefined };
}
export const GetIgdbGameSearchResultsRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.query !== undefined) {
            IgdbGameSearchQuery.encode(message.query, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIgdbGameSearchResultsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.query = IgdbGameSearchQuery.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { query: isSet(object.query) ? IgdbGameSearchQuery.fromJSON(object.query) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.query !== undefined) {
            obj.query = IgdbGameSearchQuery.toJSON(message.query);
        }
        return obj;
    },
    create(base) {
        return GetIgdbGameSearchResultsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetIgdbGameSearchResultsRequest();
        message.query = (object.query !== undefined && object.query !== null)
            ? IgdbGameSearchQuery.fromPartial(object.query)
            : undefined;
        return message;
    },
};
function createBaseGetIgdbGameSearchResultsResponse() {
    return { metadata: [] };
}
export const GetIgdbGameSearchResultsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.metadata) {
            NewGameMetadata.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIgdbGameSearchResultsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata.push(NewGameMetadata.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: globalThis.Array.isArray(object?.metadata)
                ? object.metadata.map((e) => NewGameMetadata.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata?.length) {
            obj.metadata = message.metadata.map((e) => NewGameMetadata.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GetIgdbGameSearchResultsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetIgdbGameSearchResultsResponse();
        message.metadata = object.metadata?.map((e) => NewGameMetadata.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdateGameMetadataRequest() {
    return { metadata: [] };
}
export const UpdateGameMetadataRequest = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.metadata) {
            UpdatedGameMetadata.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateGameMetadataRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata.push(UpdatedGameMetadata.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: globalThis.Array.isArray(object?.metadata)
                ? object.metadata.map((e) => UpdatedGameMetadata.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata?.length) {
            obj.metadata = message.metadata.map((e) => UpdatedGameMetadata.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdateGameMetadataRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateGameMetadataRequest();
        message.metadata = object.metadata?.map((e) => UpdatedGameMetadata.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdateGameMetadataResponse() {
    return { metadataUpdated: [] };
}
export const UpdateGameMetadataResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.metadataUpdated) {
            GameMetadata.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateGameMetadataResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadataUpdated.push(GameMetadata.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadataUpdated: globalThis.Array.isArray(object?.metadataUpdated)
                ? object.metadataUpdated.map((e) => GameMetadata.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadataUpdated?.length) {
            obj.metadataUpdated = message.metadataUpdated.map((e) => GameMetadata.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdateGameMetadataResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateGameMetadataResponse();
        message.metadataUpdated = object.metadataUpdated?.map((e) => GameMetadata.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGetIgdbPlatformSearchResultsRequest() {
    return { query: undefined };
}
export const GetIgdbPlatformSearchResultsRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.query !== undefined) {
            IgdbPlatformSearchQuery.encode(message.query, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIgdbPlatformSearchResultsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.query = IgdbPlatformSearchQuery.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { query: isSet(object.query) ? IgdbPlatformSearchQuery.fromJSON(object.query) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.query !== undefined) {
            obj.query = IgdbPlatformSearchQuery.toJSON(message.query);
        }
        return obj;
    },
    create(base) {
        return GetIgdbPlatformSearchResultsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetIgdbPlatformSearchResultsRequest();
        message.query = (object.query !== undefined && object.query !== null)
            ? IgdbPlatformSearchQuery.fromPartial(object.query)
            : undefined;
        return message;
    },
};
function createBaseGetIgdbPlatformSearchResultsResponse() {
    return { metadata: [] };
}
export const GetIgdbPlatformSearchResultsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.metadata) {
            NewPlatformMetadata.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIgdbPlatformSearchResultsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata.push(NewPlatformMetadata.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: globalThis.Array.isArray(object?.metadata)
                ? object.metadata.map((e) => NewPlatformMetadata.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata?.length) {
            obj.metadata = message.metadata.map((e) => NewPlatformMetadata.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GetIgdbPlatformSearchResultsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetIgdbPlatformSearchResultsResponse();
        message.metadata = object.metadata?.map((e) => NewPlatformMetadata.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdatePlatformMetadataRequest() {
    return { metadata: [] };
}
export const UpdatePlatformMetadataRequest = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.metadata) {
            UpdatedPlatformMetadata.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdatePlatformMetadataRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata.push(UpdatedPlatformMetadata.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: globalThis.Array.isArray(object?.metadata)
                ? object.metadata.map((e) => UpdatedPlatformMetadata.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata?.length) {
            obj.metadata = message.metadata.map((e) => UpdatedPlatformMetadata.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdatePlatformMetadataRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdatePlatformMetadataRequest();
        message.metadata = object.metadata?.map((e) => UpdatedPlatformMetadata.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdatePlatformMetadataResponse() {
    return { metadataUpdated: [] };
}
export const UpdatePlatformMetadataResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.metadataUpdated) {
            PlatformMetadata.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdatePlatformMetadataResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadataUpdated.push(PlatformMetadata.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadataUpdated: globalThis.Array.isArray(object?.metadataUpdated)
                ? object.metadataUpdated.map((e) => PlatformMetadata.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadataUpdated?.length) {
            obj.metadataUpdated = message.metadataUpdated.map((e) => PlatformMetadata.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdatePlatformMetadataResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdatePlatformMetadataResponse();
        message.metadataUpdated = object.metadataUpdated?.map((e) => PlatformMetadata.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGetIgdbSearchRequest() {
    return { searchType: 0, search: undefined, pagination: undefined, filters: undefined, fields: undefined };
}
export const GetIgdbSearchRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.searchType !== 0) {
            writer.uint32(8).int32(message.searchType);
        }
        if (message.search !== undefined) {
            IgdbSearch.encode(message.search, writer.uint32(18).fork()).join();
        }
        if (message.pagination !== undefined) {
            IgdbPagination.encode(message.pagination, writer.uint32(26).fork()).join();
        }
        if (message.filters !== undefined) {
            IgdbFilters.encode(message.filters, writer.uint32(34).fork()).join();
        }
        if (message.fields !== undefined) {
            IgdbFields.encode(message.fields, writer.uint32(42).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIgdbSearchRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.searchType = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.search = IgdbSearch.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.pagination = IgdbPagination.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.filters = IgdbFilters.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.fields = IgdbFields.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            searchType: isSet(object.searchType) ? getIgdbSearchRequest_IgdbSearchTypeFromJSON(object.searchType) : 0,
            search: isSet(object.search) ? IgdbSearch.fromJSON(object.search) : undefined,
            pagination: isSet(object.pagination) ? IgdbPagination.fromJSON(object.pagination) : undefined,
            filters: isSet(object.filters) ? IgdbFilters.fromJSON(object.filters) : undefined,
            fields: isSet(object.fields) ? IgdbFields.fromJSON(object.fields) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.searchType !== 0) {
            obj.searchType = getIgdbSearchRequest_IgdbSearchTypeToJSON(message.searchType);
        }
        if (message.search !== undefined) {
            obj.search = IgdbSearch.toJSON(message.search);
        }
        if (message.pagination !== undefined) {
            obj.pagination = IgdbPagination.toJSON(message.pagination);
        }
        if (message.filters !== undefined) {
            obj.filters = IgdbFilters.toJSON(message.filters);
        }
        if (message.fields !== undefined) {
            obj.fields = IgdbFields.toJSON(message.fields);
        }
        return obj;
    },
    create(base) {
        return GetIgdbSearchRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetIgdbSearchRequest();
        message.searchType = object.searchType ?? 0;
        message.search = (object.search !== undefined && object.search !== null)
            ? IgdbSearch.fromPartial(object.search)
            : undefined;
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? IgdbPagination.fromPartial(object.pagination)
            : undefined;
        message.filters = (object.filters !== undefined && object.filters !== null)
            ? IgdbFilters.fromPartial(object.filters)
            : undefined;
        message.fields = (object.fields !== undefined && object.fields !== null)
            ? IgdbFields.fromPartial(object.fields)
            : undefined;
        return message;
    },
};
function createBaseIgdbSearchGameResponse() {
    return { games: [] };
}
export const IgdbSearchGameResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.games) {
            NewGameMetadata.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIgdbSearchGameResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.games.push(NewGameMetadata.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            games: globalThis.Array.isArray(object?.games) ? object.games.map((e) => NewGameMetadata.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.games?.length) {
            obj.games = message.games.map((e) => NewGameMetadata.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return IgdbSearchGameResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseIgdbSearchGameResponse();
        message.games = object.games?.map((e) => NewGameMetadata.fromPartial(e)) || [];
        return message;
    },
};
function createBaseIgdbSearchPlatformResponse() {
    return { platforms: [] };
}
export const IgdbSearchPlatformResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.platforms) {
            NewPlatformMetadata.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIgdbSearchPlatformResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.platforms.push(NewPlatformMetadata.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            platforms: globalThis.Array.isArray(object?.platforms)
                ? object.platforms.map((e) => NewPlatformMetadata.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.platforms?.length) {
            obj.platforms = message.platforms.map((e) => NewPlatformMetadata.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return IgdbSearchPlatformResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseIgdbSearchPlatformResponse();
        message.platforms = object.platforms?.map((e) => NewPlatformMetadata.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGetIgdbSearchResponse() {
    return { searchResults: undefined };
}
export const GetIgdbSearchResponse = {
    encode(message, writer = new BinaryWriter()) {
        switch (message.searchResults?.$case) {
            case "gameMatches":
                IgdbSearchGameResponse.encode(message.searchResults.gameMatches, writer.uint32(10).fork()).join();
                break;
            case "platformMatches":
                IgdbSearchPlatformResponse.encode(message.searchResults.platformMatches, writer.uint32(18).fork()).join();
                break;
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIgdbSearchResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.searchResults = {
                        $case: "gameMatches",
                        gameMatches: IgdbSearchGameResponse.decode(reader, reader.uint32()),
                    };
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.searchResults = {
                        $case: "platformMatches",
                        platformMatches: IgdbSearchPlatformResponse.decode(reader, reader.uint32()),
                    };
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            searchResults: isSet(object.gameMatches)
                ? { $case: "gameMatches", gameMatches: IgdbSearchGameResponse.fromJSON(object.gameMatches) }
                : isSet(object.platformMatches)
                    ? { $case: "platformMatches", platformMatches: IgdbSearchPlatformResponse.fromJSON(object.platformMatches) }
                    : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.searchResults?.$case === "gameMatches") {
            obj.gameMatches = IgdbSearchGameResponse.toJSON(message.searchResults.gameMatches);
        }
        else if (message.searchResults?.$case === "platformMatches") {
            obj.platformMatches = IgdbSearchPlatformResponse.toJSON(message.searchResults.platformMatches);
        }
        return obj;
    },
    create(base) {
        return GetIgdbSearchResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetIgdbSearchResponse();
        switch (object.searchResults?.$case) {
            case "gameMatches": {
                if (object.searchResults?.gameMatches !== undefined && object.searchResults?.gameMatches !== null) {
                    message.searchResults = {
                        $case: "gameMatches",
                        gameMatches: IgdbSearchGameResponse.fromPartial(object.searchResults.gameMatches),
                    };
                }
                break;
            }
            case "platformMatches": {
                if (object.searchResults?.platformMatches !== undefined && object.searchResults?.platformMatches !== null) {
                    message.searchResults = {
                        $case: "platformMatches",
                        platformMatches: IgdbSearchPlatformResponse.fromPartial(object.searchResults.platformMatches),
                    };
                }
                break;
            }
        }
        return message;
    },
};
function createBaseDeleteLibraryRequest() {
    return {};
}
export const DeleteLibraryRequest = {
    encode(_, writer = new BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteLibraryRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return DeleteLibraryRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseDeleteLibraryRequest();
        return message;
    },
};
function createBaseDeleteLibraryResponse() {
    return {};
}
export const DeleteLibraryResponse = {
    encode(_, writer = new BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteLibraryResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return DeleteLibraryResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseDeleteLibraryResponse();
        return message;
    },
};
function createBaseDeleteMissingEntriesRequest() {
    return { dryRun: false };
}
export const DeleteMissingEntriesRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.dryRun !== false) {
            writer.uint32(8).bool(message.dryRun);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteMissingEntriesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.dryRun = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { dryRun: isSet(object.dryRun) ? globalThis.Boolean(object.dryRun) : false };
    },
    toJSON(message) {
        const obj = {};
        if (message.dryRun !== false) {
            obj.dryRun = message.dryRun;
        }
        return obj;
    },
    create(base) {
        return DeleteMissingEntriesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteMissingEntriesRequest();
        message.dryRun = object.dryRun ?? false;
        return message;
    },
};
function createBaseDeleteMissingEntriesResponse() {
    return { platformsDeleted: [], gamesDeleted: [], gameFilesDeleted: [] };
}
export const DeleteMissingEntriesResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.platformsDeleted) {
            Platform.encode(v, writer.uint32(10).fork()).join();
        }
        for (const v of message.gamesDeleted) {
            Game.encode(v, writer.uint32(18).fork()).join();
        }
        for (const v of message.gameFilesDeleted) {
            GameFile.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteMissingEntriesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.platformsDeleted.push(Platform.decode(reader, reader.uint32()));
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.gamesDeleted.push(Game.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.gameFilesDeleted.push(GameFile.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            platformsDeleted: globalThis.Array.isArray(object?.platformsDeleted)
                ? object.platformsDeleted.map((e) => Platform.fromJSON(e))
                : [],
            gamesDeleted: globalThis.Array.isArray(object?.gamesDeleted)
                ? object.gamesDeleted.map((e) => Game.fromJSON(e))
                : [],
            gameFilesDeleted: globalThis.Array.isArray(object?.gameFilesDeleted)
                ? object.gameFilesDeleted.map((e) => GameFile.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.platformsDeleted?.length) {
            obj.platformsDeleted = message.platformsDeleted.map((e) => Platform.toJSON(e));
        }
        if (message.gamesDeleted?.length) {
            obj.gamesDeleted = message.gamesDeleted.map((e) => Game.toJSON(e));
        }
        if (message.gameFilesDeleted?.length) {
            obj.gameFilesDeleted = message.gameFilesDeleted.map((e) => GameFile.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return DeleteMissingEntriesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteMissingEntriesResponse();
        message.platformsDeleted = object.platformsDeleted?.map((e) => Platform.fromPartial(e)) || [];
        message.gamesDeleted = object.gamesDeleted?.map((e) => Game.fromPartial(e)) || [];
        message.gameFilesDeleted = object.gameFilesDeleted?.map((e) => GameFile.fromPartial(e)) || [];
        return message;
    },
};
function createBaseDeletePlatformsRequest() {
    return { ids: [], deleteFromDisk: false, blacklistEntries: false };
}
export const DeletePlatformsRequest = {
    encode(message, writer = new BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.ids) {
            writer.int32(v);
        }
        writer.join();
        if (message.deleteFromDisk !== false) {
            writer.uint32(16).bool(message.deleteFromDisk);
        }
        if (message.blacklistEntries !== false) {
            writer.uint32(24).bool(message.blacklistEntries);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeletePlatformsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.ids.push(reader.int32());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.ids.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.deleteFromDisk = reader.bool();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.blacklistEntries = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e) => globalThis.Number(e)) : [],
            deleteFromDisk: isSet(object.deleteFromDisk) ? globalThis.Boolean(object.deleteFromDisk) : false,
            blacklistEntries: isSet(object.blacklistEntries) ? globalThis.Boolean(object.blacklistEntries) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ids?.length) {
            obj.ids = message.ids.map((e) => Math.round(e));
        }
        if (message.deleteFromDisk !== false) {
            obj.deleteFromDisk = message.deleteFromDisk;
        }
        if (message.blacklistEntries !== false) {
            obj.blacklistEntries = message.blacklistEntries;
        }
        return obj;
    },
    create(base) {
        return DeletePlatformsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeletePlatformsRequest();
        message.ids = object.ids?.map((e) => e) || [];
        message.deleteFromDisk = object.deleteFromDisk ?? false;
        message.blacklistEntries = object.blacklistEntries ?? false;
        return message;
    },
};
function createBaseDeletePlatformsResponse() {
    return { platformsDeleted: [] };
}
export const DeletePlatformsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.platformsDeleted) {
            Platform.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeletePlatformsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.platformsDeleted.push(Platform.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            platformsDeleted: globalThis.Array.isArray(object?.platformsDeleted)
                ? object.platformsDeleted.map((e) => Platform.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.platformsDeleted?.length) {
            obj.platformsDeleted = message.platformsDeleted.map((e) => Platform.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return DeletePlatformsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeletePlatformsResponse();
        message.platformsDeleted = object.platformsDeleted?.map((e) => Platform.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdatePlatformsRequest() {
    return { platforms: [] };
}
export const UpdatePlatformsRequest = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.platforms) {
            UpdatedPlatform.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdatePlatformsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.platforms.push(UpdatedPlatform.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            platforms: globalThis.Array.isArray(object?.platforms)
                ? object.platforms.map((e) => UpdatedPlatform.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.platforms?.length) {
            obj.platforms = message.platforms.map((e) => UpdatedPlatform.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdatePlatformsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdatePlatformsRequest();
        message.platforms = object.platforms?.map((e) => UpdatedPlatform.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdatePlatformsResponse() {
    return { platformsUpdated: [] };
}
export const UpdatePlatformsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.platformsUpdated) {
            Platform.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdatePlatformsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.platformsUpdated.push(Platform.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            platformsUpdated: globalThis.Array.isArray(object?.platformsUpdated)
                ? object.platformsUpdated.map((e) => Platform.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.platformsUpdated?.length) {
            obj.platformsUpdated = message.platformsUpdated.map((e) => Platform.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdatePlatformsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdatePlatformsResponse();
        message.platformsUpdated = object.platformsUpdated?.map((e) => Platform.fromPartial(e)) || [];
        return message;
    },
};
function createBaseDeleteGamesRequest() {
    return { ids: [], deleteFromDisk: false, blacklistEntries: false };
}
export const DeleteGamesRequest = {
    encode(message, writer = new BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.ids) {
            writer.int32(v);
        }
        writer.join();
        if (message.deleteFromDisk !== false) {
            writer.uint32(16).bool(message.deleteFromDisk);
        }
        if (message.blacklistEntries !== false) {
            writer.uint32(24).bool(message.blacklistEntries);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteGamesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.ids.push(reader.int32());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.ids.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.deleteFromDisk = reader.bool();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.blacklistEntries = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e) => globalThis.Number(e)) : [],
            deleteFromDisk: isSet(object.deleteFromDisk) ? globalThis.Boolean(object.deleteFromDisk) : false,
            blacklistEntries: isSet(object.blacklistEntries) ? globalThis.Boolean(object.blacklistEntries) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ids?.length) {
            obj.ids = message.ids.map((e) => Math.round(e));
        }
        if (message.deleteFromDisk !== false) {
            obj.deleteFromDisk = message.deleteFromDisk;
        }
        if (message.blacklistEntries !== false) {
            obj.blacklistEntries = message.blacklistEntries;
        }
        return obj;
    },
    create(base) {
        return DeleteGamesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteGamesRequest();
        message.ids = object.ids?.map((e) => e) || [];
        message.deleteFromDisk = object.deleteFromDisk ?? false;
        message.blacklistEntries = object.blacklistEntries ?? false;
        return message;
    },
};
function createBaseDeleteGamesResponse() {
    return { gamesDeleted: [] };
}
export const DeleteGamesResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.gamesDeleted) {
            Game.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteGamesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.gamesDeleted.push(Game.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            gamesDeleted: globalThis.Array.isArray(object?.gamesDeleted)
                ? object.gamesDeleted.map((e) => Game.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.gamesDeleted?.length) {
            obj.gamesDeleted = message.gamesDeleted.map((e) => Game.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return DeleteGamesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteGamesResponse();
        message.gamesDeleted = object.gamesDeleted?.map((e) => Game.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdateGamesRequest() {
    return { games: [] };
}
export const UpdateGamesRequest = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.games) {
            UpdatedGame.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateGamesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.games.push(UpdatedGame.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            games: globalThis.Array.isArray(object?.games) ? object.games.map((e) => UpdatedGame.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.games?.length) {
            obj.games = message.games.map((e) => UpdatedGame.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdateGamesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateGamesRequest();
        message.games = object.games?.map((e) => UpdatedGame.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdateGamesResponse() {
    return { gamesUpdated: [] };
}
export const UpdateGamesResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.gamesUpdated) {
            Game.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateGamesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.gamesUpdated.push(Game.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            gamesUpdated: globalThis.Array.isArray(object?.gamesUpdated)
                ? object.gamesUpdated.map((e) => Game.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.gamesUpdated?.length) {
            obj.gamesUpdated = message.gamesUpdated.map((e) => Game.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdateGamesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateGamesResponse();
        message.gamesUpdated = object.gamesUpdated?.map((e) => Game.fromPartial(e)) || [];
        return message;
    },
};
function createBaseCreateClientRequest() {
    return { client: undefined };
}
export const CreateClientRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.client !== undefined) {
            NewClient.encode(message.client, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateClientRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.client = NewClient.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { client: isSet(object.client) ? NewClient.fromJSON(object.client) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.client !== undefined) {
            obj.client = NewClient.toJSON(message.client);
        }
        return obj;
    },
    create(base) {
        return CreateClientRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateClientRequest();
        message.client = (object.client !== undefined && object.client !== null)
            ? NewClient.fromPartial(object.client)
            : undefined;
        return message;
    },
};
function createBaseCreateClientResponse() {
    return { clientCreated: undefined };
}
export const CreateClientResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.clientCreated !== undefined) {
            Client.encode(message.clientCreated, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateClientResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.clientCreated = Client.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { clientCreated: isSet(object.clientCreated) ? Client.fromJSON(object.clientCreated) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.clientCreated !== undefined) {
            obj.clientCreated = Client.toJSON(message.clientCreated);
        }
        return obj;
    },
    create(base) {
        return CreateClientResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateClientResponse();
        message.clientCreated = (object.clientCreated !== undefined && object.clientCreated !== null)
            ? Client.fromPartial(object.clientCreated)
            : undefined;
        return message;
    },
};
function createBaseGetClientsRequest() {
    return { ids: [], names: [] };
}
export const GetClientsRequest = {
    encode(message, writer = new BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.ids) {
            writer.int32(v);
        }
        writer.join();
        for (const v of message.names) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetClientsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.ids.push(reader.int32());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.ids.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.names.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e) => globalThis.Number(e)) : [],
            names: globalThis.Array.isArray(object?.names) ? object.names.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ids?.length) {
            obj.ids = message.ids.map((e) => Math.round(e));
        }
        if (message.names?.length) {
            obj.names = message.names;
        }
        return obj;
    },
    create(base) {
        return GetClientsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetClientsRequest();
        message.ids = object.ids?.map((e) => e) || [];
        message.names = object.names?.map((e) => e) || [];
        return message;
    },
};
function createBaseGetClientsResponse() {
    return { clients: [] };
}
export const GetClientsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.clients) {
            Client.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetClientsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.clients.push(Client.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            clients: globalThis.Array.isArray(object?.clients) ? object.clients.map((e) => Client.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.clients?.length) {
            obj.clients = message.clients.map((e) => Client.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GetClientsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetClientsResponse();
        message.clients = object.clients?.map((e) => Client.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdateClientsRequest() {
    return { clients: [] };
}
export const UpdateClientsRequest = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.clients) {
            UpdatedClient.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateClientsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.clients.push(UpdatedClient.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            clients: globalThis.Array.isArray(object?.clients)
                ? object.clients.map((e) => UpdatedClient.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.clients?.length) {
            obj.clients = message.clients.map((e) => UpdatedClient.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdateClientsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateClientsRequest();
        message.clients = object.clients?.map((e) => UpdatedClient.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdateClientsResponse() {
    return { clientsUpdated: [] };
}
export const UpdateClientsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.clientsUpdated) {
            Client.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateClientsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.clientsUpdated.push(Client.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            clientsUpdated: globalThis.Array.isArray(object?.clientsUpdated)
                ? object.clientsUpdated.map((e) => Client.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.clientsUpdated?.length) {
            obj.clientsUpdated = message.clientsUpdated.map((e) => Client.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdateClientsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateClientsResponse();
        message.clientsUpdated = object.clientsUpdated?.map((e) => Client.fromPartial(e)) || [];
        return message;
    },
};
function createBaseDeleteClientsRequest() {
    return { ids: [] };
}
export const DeleteClientsRequest = {
    encode(message, writer = new BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.ids) {
            writer.int32(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteClientsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.ids.push(reader.int32());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.ids.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e) => globalThis.Number(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.ids?.length) {
            obj.ids = message.ids.map((e) => Math.round(e));
        }
        return obj;
    },
    create(base) {
        return DeleteClientsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteClientsRequest();
        message.ids = object.ids?.map((e) => e) || [];
        return message;
    },
};
function createBaseDeleteClientsResponse() {
    return { clientsDeleted: [] };
}
export const DeleteClientsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.clientsDeleted) {
            Client.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteClientsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.clientsDeleted.push(Client.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            clientsDeleted: globalThis.Array.isArray(object?.clientsDeleted)
                ? object.clientsDeleted.map((e) => Client.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.clientsDeleted?.length) {
            obj.clientsDeleted = message.clientsDeleted.map((e) => Client.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return DeleteClientsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteClientsResponse();
        message.clientsDeleted = object.clientsDeleted?.map((e) => Client.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGetServerInfoRequest() {
    return {};
}
export const GetServerInfoRequest = {
    encode(_, writer = new BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetServerInfoRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return GetServerInfoRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseGetServerInfoRequest();
        return message;
    },
};
function createBaseGetServerInfoResponse() {
    return { serverInfo: undefined };
}
export const GetServerInfoResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.serverInfo !== undefined) {
            ServerInfo.encode(message.serverInfo, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetServerInfoResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.serverInfo = ServerInfo.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { serverInfo: isSet(object.serverInfo) ? ServerInfo.fromJSON(object.serverInfo) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.serverInfo !== undefined) {
            obj.serverInfo = ServerInfo.toJSON(message.serverInfo);
        }
        return obj;
    },
    create(base) {
        return GetServerInfoResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetServerInfoResponse();
        message.serverInfo = (object.serverInfo !== undefined && object.serverInfo !== null)
            ? ServerInfo.fromPartial(object.serverInfo)
            : undefined;
        return message;
    },
};
function createBaseGetServerConfigRequest() {
    return {};
}
export const GetServerConfigRequest = {
    encode(_, writer = new BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetServerConfigRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return GetServerConfigRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseGetServerConfigRequest();
        return message;
    },
};
function createBaseGetServerConfigResponse() {
    return { config: undefined };
}
export const GetServerConfigResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.config !== undefined) {
            ServerConfig.encode(message.config, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetServerConfigResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.config = ServerConfig.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { config: isSet(object.config) ? ServerConfig.fromJSON(object.config) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.config !== undefined) {
            obj.config = ServerConfig.toJSON(message.config);
        }
        return obj;
    },
    create(base) {
        return GetServerConfigResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetServerConfigResponse();
        message.config = (object.config !== undefined && object.config !== null)
            ? ServerConfig.fromPartial(object.config)
            : undefined;
        return message;
    },
};
function createBaseUpdateServerConfigRequest() {
    return { config: undefined };
}
export const UpdateServerConfigRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.config !== undefined) {
            ServerConfig.encode(message.config, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateServerConfigRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.config = ServerConfig.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { config: isSet(object.config) ? ServerConfig.fromJSON(object.config) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.config !== undefined) {
            obj.config = ServerConfig.toJSON(message.config);
        }
        return obj;
    },
    create(base) {
        return UpdateServerConfigRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateServerConfigRequest();
        message.config = (object.config !== undefined && object.config !== null)
            ? ServerConfig.fromPartial(object.config)
            : undefined;
        return message;
    },
};
function createBaseUpdateServerConfigResponse() {
    return { configUpdated: undefined };
}
export const UpdateServerConfigResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.configUpdated !== undefined) {
            ServerConfig.encode(message.configUpdated, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateServerConfigResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.configUpdated = ServerConfig.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { configUpdated: isSet(object.configUpdated) ? ServerConfig.fromJSON(object.configUpdated) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.configUpdated !== undefined) {
            obj.configUpdated = ServerConfig.toJSON(message.configUpdated);
        }
        return obj;
    },
    create(base) {
        return UpdateServerConfigResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateServerConfigResponse();
        message.configUpdated = (object.configUpdated !== undefined && object.configUpdated !== null)
            ? ServerConfig.fromPartial(object.configUpdated)
            : undefined;
        return message;
    },
};
function createBaseCreateEmulatorsRequest() {
    return { emulators: [] };
}
export const CreateEmulatorsRequest = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.emulators) {
            NewEmulator.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateEmulatorsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.emulators.push(NewEmulator.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            emulators: globalThis.Array.isArray(object?.emulators)
                ? object.emulators.map((e) => NewEmulator.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.emulators?.length) {
            obj.emulators = message.emulators.map((e) => NewEmulator.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return CreateEmulatorsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateEmulatorsRequest();
        message.emulators = object.emulators?.map((e) => NewEmulator.fromPartial(e)) || [];
        return message;
    },
};
function createBaseCreateEmulatorsResponse() {
    return { emulatorsCreated: [] };
}
export const CreateEmulatorsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.emulatorsCreated) {
            Emulator.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateEmulatorsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.emulatorsCreated.push(Emulator.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            emulatorsCreated: globalThis.Array.isArray(object?.emulatorsCreated)
                ? object.emulatorsCreated.map((e) => Emulator.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.emulatorsCreated?.length) {
            obj.emulatorsCreated = message.emulatorsCreated.map((e) => Emulator.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return CreateEmulatorsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateEmulatorsResponse();
        message.emulatorsCreated = object.emulatorsCreated?.map((e) => Emulator.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGetEmulatorsRequest() {
    return { ids: [], supportedPlatformIds: [] };
}
export const GetEmulatorsRequest = {
    encode(message, writer = new BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.ids) {
            writer.int32(v);
        }
        writer.join();
        writer.uint32(18).fork();
        for (const v of message.supportedPlatformIds) {
            writer.int32(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetEmulatorsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.ids.push(reader.int32());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.ids.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
                case 2: {
                    if (tag === 16) {
                        message.supportedPlatformIds.push(reader.int32());
                        continue;
                    }
                    if (tag === 18) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.supportedPlatformIds.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e) => globalThis.Number(e)) : [],
            supportedPlatformIds: globalThis.Array.isArray(object?.supportedPlatformIds)
                ? object.supportedPlatformIds.map((e) => globalThis.Number(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ids?.length) {
            obj.ids = message.ids.map((e) => Math.round(e));
        }
        if (message.supportedPlatformIds?.length) {
            obj.supportedPlatformIds = message.supportedPlatformIds.map((e) => Math.round(e));
        }
        return obj;
    },
    create(base) {
        return GetEmulatorsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetEmulatorsRequest();
        message.ids = object.ids?.map((e) => e) || [];
        message.supportedPlatformIds = object.supportedPlatformIds?.map((e) => e) || [];
        return message;
    },
};
function createBaseGetEmulatorsResponse() {
    return { emulators: [] };
}
export const GetEmulatorsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.emulators) {
            Emulator.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetEmulatorsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.emulators.push(Emulator.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            emulators: globalThis.Array.isArray(object?.emulators)
                ? object.emulators.map((e) => Emulator.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.emulators?.length) {
            obj.emulators = message.emulators.map((e) => Emulator.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GetEmulatorsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetEmulatorsResponse();
        message.emulators = object.emulators?.map((e) => Emulator.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdateEmulatorsRequest() {
    return { emulators: [] };
}
export const UpdateEmulatorsRequest = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.emulators) {
            UpdatedEmulator.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateEmulatorsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.emulators.push(UpdatedEmulator.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            emulators: globalThis.Array.isArray(object?.emulators)
                ? object.emulators.map((e) => UpdatedEmulator.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.emulators?.length) {
            obj.emulators = message.emulators.map((e) => UpdatedEmulator.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdateEmulatorsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateEmulatorsRequest();
        message.emulators = object.emulators?.map((e) => UpdatedEmulator.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdateEmulatorsResponse() {
    return { emulatorsUpdated: [] };
}
export const UpdateEmulatorsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.emulatorsUpdated) {
            Emulator.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateEmulatorsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.emulatorsUpdated.push(Emulator.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            emulatorsUpdated: globalThis.Array.isArray(object?.emulatorsUpdated)
                ? object.emulatorsUpdated.map((e) => Emulator.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.emulatorsUpdated?.length) {
            obj.emulatorsUpdated = message.emulatorsUpdated.map((e) => Emulator.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdateEmulatorsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateEmulatorsResponse();
        message.emulatorsUpdated = object.emulatorsUpdated?.map((e) => Emulator.fromPartial(e)) || [];
        return message;
    },
};
function createBaseDeleteEmulatorsRequest() {
    return { ids: [] };
}
export const DeleteEmulatorsRequest = {
    encode(message, writer = new BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.ids) {
            writer.int32(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteEmulatorsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.ids.push(reader.int32());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.ids.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e) => globalThis.Number(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.ids?.length) {
            obj.ids = message.ids.map((e) => Math.round(e));
        }
        return obj;
    },
    create(base) {
        return DeleteEmulatorsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteEmulatorsRequest();
        message.ids = object.ids?.map((e) => e) || [];
        return message;
    },
};
function createBaseDeleteEmulatorsResponse() {
    return { emulatorsDeleted: [] };
}
export const DeleteEmulatorsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.emulatorsDeleted) {
            Emulator.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteEmulatorsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.emulatorsDeleted.push(Emulator.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            emulatorsDeleted: globalThis.Array.isArray(object?.emulatorsDeleted)
                ? object.emulatorsDeleted.map((e) => Emulator.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.emulatorsDeleted?.length) {
            obj.emulatorsDeleted = message.emulatorsDeleted.map((e) => Emulator.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return DeleteEmulatorsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteEmulatorsResponse();
        message.emulatorsDeleted = object.emulatorsDeleted?.map((e) => Emulator.fromPartial(e)) || [];
        return message;
    },
};
function createBaseCreateEmulatorProfilesRequest() {
    return { profiles: [] };
}
export const CreateEmulatorProfilesRequest = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.profiles) {
            NewEmulatorProfile.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateEmulatorProfilesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.profiles.push(NewEmulatorProfile.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            profiles: globalThis.Array.isArray(object?.profiles)
                ? object.profiles.map((e) => NewEmulatorProfile.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.profiles?.length) {
            obj.profiles = message.profiles.map((e) => NewEmulatorProfile.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return CreateEmulatorProfilesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateEmulatorProfilesRequest();
        message.profiles = object.profiles?.map((e) => NewEmulatorProfile.fromPartial(e)) || [];
        return message;
    },
};
function createBaseCreateEmulatorProfilesResponse() {
    return { profilesCreated: [] };
}
export const CreateEmulatorProfilesResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.profilesCreated) {
            EmulatorProfile.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateEmulatorProfilesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.profilesCreated.push(EmulatorProfile.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            profilesCreated: globalThis.Array.isArray(object?.profilesCreated)
                ? object.profilesCreated.map((e) => EmulatorProfile.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.profilesCreated?.length) {
            obj.profilesCreated = message.profilesCreated.map((e) => EmulatorProfile.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return CreateEmulatorProfilesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateEmulatorProfilesResponse();
        message.profilesCreated = object.profilesCreated?.map((e) => EmulatorProfile.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGetEmulatorProfilesRequest() {
    return { ids: [], emulatorIds: [] };
}
export const GetEmulatorProfilesRequest = {
    encode(message, writer = new BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.ids) {
            writer.int32(v);
        }
        writer.join();
        writer.uint32(18).fork();
        for (const v of message.emulatorIds) {
            writer.int32(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetEmulatorProfilesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.ids.push(reader.int32());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.ids.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
                case 2: {
                    if (tag === 16) {
                        message.emulatorIds.push(reader.int32());
                        continue;
                    }
                    if (tag === 18) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.emulatorIds.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e) => globalThis.Number(e)) : [],
            emulatorIds: globalThis.Array.isArray(object?.emulatorIds)
                ? object.emulatorIds.map((e) => globalThis.Number(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ids?.length) {
            obj.ids = message.ids.map((e) => Math.round(e));
        }
        if (message.emulatorIds?.length) {
            obj.emulatorIds = message.emulatorIds.map((e) => Math.round(e));
        }
        return obj;
    },
    create(base) {
        return GetEmulatorProfilesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetEmulatorProfilesRequest();
        message.ids = object.ids?.map((e) => e) || [];
        message.emulatorIds = object.emulatorIds?.map((e) => e) || [];
        return message;
    },
};
function createBaseGetEmulatorProfilesResponse() {
    return { profiles: [] };
}
export const GetEmulatorProfilesResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.profiles) {
            EmulatorProfile.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetEmulatorProfilesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.profiles.push(EmulatorProfile.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            profiles: globalThis.Array.isArray(object?.profiles)
                ? object.profiles.map((e) => EmulatorProfile.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.profiles?.length) {
            obj.profiles = message.profiles.map((e) => EmulatorProfile.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GetEmulatorProfilesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetEmulatorProfilesResponse();
        message.profiles = object.profiles?.map((e) => EmulatorProfile.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdateEmulatorProfilesRequest() {
    return { profiles: [] };
}
export const UpdateEmulatorProfilesRequest = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.profiles) {
            UpdatedEmulatorProfile.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateEmulatorProfilesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.profiles.push(UpdatedEmulatorProfile.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            profiles: globalThis.Array.isArray(object?.profiles)
                ? object.profiles.map((e) => UpdatedEmulatorProfile.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.profiles?.length) {
            obj.profiles = message.profiles.map((e) => UpdatedEmulatorProfile.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdateEmulatorProfilesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateEmulatorProfilesRequest();
        message.profiles = object.profiles?.map((e) => UpdatedEmulatorProfile.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdateEmulatorProfilesResponse() {
    return { profilesUpdated: [] };
}
export const UpdateEmulatorProfilesResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.profilesUpdated) {
            EmulatorProfile.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateEmulatorProfilesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.profilesUpdated.push(EmulatorProfile.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            profilesUpdated: globalThis.Array.isArray(object?.profilesUpdated)
                ? object.profilesUpdated.map((e) => EmulatorProfile.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.profilesUpdated?.length) {
            obj.profilesUpdated = message.profilesUpdated.map((e) => EmulatorProfile.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdateEmulatorProfilesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateEmulatorProfilesResponse();
        message.profilesUpdated = object.profilesUpdated?.map((e) => EmulatorProfile.fromPartial(e)) || [];
        return message;
    },
};
function createBaseDeleteEmulatorProfilesRequest() {
    return { ids: [] };
}
export const DeleteEmulatorProfilesRequest = {
    encode(message, writer = new BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.ids) {
            writer.int32(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteEmulatorProfilesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.ids.push(reader.int32());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.ids.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e) => globalThis.Number(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.ids?.length) {
            obj.ids = message.ids.map((e) => Math.round(e));
        }
        return obj;
    },
    create(base) {
        return DeleteEmulatorProfilesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteEmulatorProfilesRequest();
        message.ids = object.ids?.map((e) => e) || [];
        return message;
    },
};
function createBaseDeleteEmulatorProfilesResponse() {
    return { profilesDeleted: [] };
}
export const DeleteEmulatorProfilesResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.profilesDeleted) {
            EmulatorProfile.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteEmulatorProfilesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.profilesDeleted.push(EmulatorProfile.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            profilesDeleted: globalThis.Array.isArray(object?.profilesDeleted)
                ? object.profilesDeleted.map((e) => EmulatorProfile.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.profilesDeleted?.length) {
            obj.profilesDeleted = message.profilesDeleted.map((e) => EmulatorProfile.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return DeleteEmulatorProfilesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteEmulatorProfilesResponse();
        message.profilesDeleted = object.profilesDeleted?.map((e) => EmulatorProfile.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGetDefaultEmulatorProfilesRequest() {
    return { platformIds: [] };
}
export const GetDefaultEmulatorProfilesRequest = {
    encode(message, writer = new BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.platformIds) {
            writer.int32(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetDefaultEmulatorProfilesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.platformIds.push(reader.int32());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.platformIds.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            platformIds: globalThis.Array.isArray(object?.platformIds)
                ? object.platformIds.map((e) => globalThis.Number(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.platformIds?.length) {
            obj.platformIds = message.platformIds.map((e) => Math.round(e));
        }
        return obj;
    },
    create(base) {
        return GetDefaultEmulatorProfilesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetDefaultEmulatorProfilesRequest();
        message.platformIds = object.platformIds?.map((e) => e) || [];
        return message;
    },
};
function createBaseGetDefaultEmulatorProfilesResponse() {
    return { defaultProfiles: [] };
}
export const GetDefaultEmulatorProfilesResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.defaultProfiles) {
            DefaultEmulatorProfile.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetDefaultEmulatorProfilesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.defaultProfiles.push(DefaultEmulatorProfile.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            defaultProfiles: globalThis.Array.isArray(object?.defaultProfiles)
                ? object.defaultProfiles.map((e) => DefaultEmulatorProfile.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.defaultProfiles?.length) {
            obj.defaultProfiles = message.defaultProfiles.map((e) => DefaultEmulatorProfile.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GetDefaultEmulatorProfilesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetDefaultEmulatorProfilesResponse();
        message.defaultProfiles = object.defaultProfiles?.map((e) => DefaultEmulatorProfile.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdateDefaultEmulatorProfilesRequest() {
    return { defaultProfiles: [] };
}
export const UpdateDefaultEmulatorProfilesRequest = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.defaultProfiles) {
            UpdatedDefaultEmulatorProfile.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateDefaultEmulatorProfilesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.defaultProfiles.push(UpdatedDefaultEmulatorProfile.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            defaultProfiles: globalThis.Array.isArray(object?.defaultProfiles)
                ? object.defaultProfiles.map((e) => UpdatedDefaultEmulatorProfile.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.defaultProfiles?.length) {
            obj.defaultProfiles = message.defaultProfiles.map((e) => UpdatedDefaultEmulatorProfile.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdateDefaultEmulatorProfilesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateDefaultEmulatorProfilesRequest();
        message.defaultProfiles = object.defaultProfiles?.map((e) => UpdatedDefaultEmulatorProfile.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdateDefaultEmulatorProfilesResponse() {
    return { defaultProfilesUpdated: [] };
}
export const UpdateDefaultEmulatorProfilesResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.defaultProfilesUpdated) {
            DefaultEmulatorProfile.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateDefaultEmulatorProfilesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.defaultProfilesUpdated.push(DefaultEmulatorProfile.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            defaultProfilesUpdated: globalThis.Array.isArray(object?.defaultProfilesUpdated)
                ? object.defaultProfilesUpdated.map((e) => DefaultEmulatorProfile.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.defaultProfilesUpdated?.length) {
            obj.defaultProfilesUpdated = message.defaultProfilesUpdated.map((e) => DefaultEmulatorProfile.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdateDefaultEmulatorProfilesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateDefaultEmulatorProfilesResponse();
        message.defaultProfilesUpdated = object.defaultProfilesUpdated?.map((e) => DefaultEmulatorProfile.fromPartial(e)) ||
            [];
        return message;
    },
};
function createBaseDeleteDefaultEmulatorProfilesRequest() {
    return { platformIds: [] };
}
export const DeleteDefaultEmulatorProfilesRequest = {
    encode(message, writer = new BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.platformIds) {
            writer.int32(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteDefaultEmulatorProfilesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.platformIds.push(reader.int32());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.platformIds.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            platformIds: globalThis.Array.isArray(object?.platformIds)
                ? object.platformIds.map((e) => globalThis.Number(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.platformIds?.length) {
            obj.platformIds = message.platformIds.map((e) => Math.round(e));
        }
        return obj;
    },
    create(base) {
        return DeleteDefaultEmulatorProfilesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteDefaultEmulatorProfilesRequest();
        message.platformIds = object.platformIds?.map((e) => e) || [];
        return message;
    },
};
function createBaseDeleteDefaultEmulatorProfilesResponse() {
    return { defaultProfilesDeleted: [] };
}
export const DeleteDefaultEmulatorProfilesResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.defaultProfilesDeleted) {
            DefaultEmulatorProfile.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteDefaultEmulatorProfilesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.defaultProfilesDeleted.push(DefaultEmulatorProfile.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            defaultProfilesDeleted: globalThis.Array.isArray(object?.defaultProfilesDeleted)
                ? object.defaultProfilesDeleted.map((e) => DefaultEmulatorProfile.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.defaultProfilesDeleted?.length) {
            obj.defaultProfilesDeleted = message.defaultProfilesDeleted.map((e) => DefaultEmulatorProfile.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return DeleteDefaultEmulatorProfilesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteDefaultEmulatorProfilesResponse();
        message.defaultProfilesDeleted = object.defaultProfilesDeleted?.map((e) => DefaultEmulatorProfile.fromPartial(e)) ||
            [];
        return message;
    },
};
function createBaseDeleteGameFilesRequest() {
    return { ids: [], deleteFromDisk: false, blacklistEntries: false };
}
export const DeleteGameFilesRequest = {
    encode(message, writer = new BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.ids) {
            writer.int32(v);
        }
        writer.join();
        if (message.deleteFromDisk !== false) {
            writer.uint32(16).bool(message.deleteFromDisk);
        }
        if (message.blacklistEntries !== false) {
            writer.uint32(24).bool(message.blacklistEntries);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteGameFilesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.ids.push(reader.int32());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.ids.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.deleteFromDisk = reader.bool();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.blacklistEntries = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e) => globalThis.Number(e)) : [],
            deleteFromDisk: isSet(object.deleteFromDisk) ? globalThis.Boolean(object.deleteFromDisk) : false,
            blacklistEntries: isSet(object.blacklistEntries) ? globalThis.Boolean(object.blacklistEntries) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ids?.length) {
            obj.ids = message.ids.map((e) => Math.round(e));
        }
        if (message.deleteFromDisk !== false) {
            obj.deleteFromDisk = message.deleteFromDisk;
        }
        if (message.blacklistEntries !== false) {
            obj.blacklistEntries = message.blacklistEntries;
        }
        return obj;
    },
    create(base) {
        return DeleteGameFilesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteGameFilesRequest();
        message.ids = object.ids?.map((e) => e) || [];
        message.deleteFromDisk = object.deleteFromDisk ?? false;
        message.blacklistEntries = object.blacklistEntries ?? false;
        return message;
    },
};
function createBaseDeleteGameFilesResponse() {
    return { gameFilesDeleted: [] };
}
export const DeleteGameFilesResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.gameFilesDeleted) {
            GameFile.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteGameFilesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.gameFilesDeleted.push(GameFile.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            gameFilesDeleted: globalThis.Array.isArray(object?.gameFilesDeleted)
                ? object.gameFilesDeleted.map((e) => GameFile.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.gameFilesDeleted?.length) {
            obj.gameFilesDeleted = message.gameFilesDeleted.map((e) => GameFile.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return DeleteGameFilesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteGameFilesResponse();
        message.gameFilesDeleted = object.gameFilesDeleted?.map((e) => GameFile.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdateGameFilesRequest() {
    return { gameFiles: [] };
}
export const UpdateGameFilesRequest = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.gameFiles) {
            UpdatedGameFile.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateGameFilesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.gameFiles.push(UpdatedGameFile.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            gameFiles: globalThis.Array.isArray(object?.gameFiles)
                ? object.gameFiles.map((e) => UpdatedGameFile.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.gameFiles?.length) {
            obj.gameFiles = message.gameFiles.map((e) => UpdatedGameFile.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdateGameFilesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateGameFilesRequest();
        message.gameFiles = object.gameFiles?.map((e) => UpdatedGameFile.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdateGameFilesResponse() {
    return { gameFilesUpdated: [] };
}
export const UpdateGameFilesResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.gameFilesUpdated) {
            GameFile.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateGameFilesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.gameFilesUpdated.push(GameFile.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            gameFilesUpdated: globalThis.Array.isArray(object?.gameFilesUpdated)
                ? object.gameFilesUpdated.map((e) => GameFile.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.gameFilesUpdated?.length) {
            obj.gameFilesUpdated = message.gameFilesUpdated.map((e) => GameFile.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdateGameFilesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateGameFilesResponse();
        message.gameFilesUpdated = object.gameFilesUpdated?.map((e) => GameFile.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGetJobsRequest() {
    return {};
}
export const GetJobsRequest = {
    encode(_, writer = new BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetJobsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return GetJobsRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseGetJobsRequest();
        return message;
    },
};
function createBaseGetJobsResponse() {
    return { jobs: [] };
}
export const GetJobsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.jobs) {
            JobProgress.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetJobsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.jobs.push(JobProgress.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { jobs: globalThis.Array.isArray(object?.jobs) ? object.jobs.map((e) => JobProgress.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.jobs?.length) {
            obj.jobs = message.jobs.map((e) => JobProgress.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GetJobsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetJobsResponse();
        message.jobs = object.jobs?.map((e) => JobProgress.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGetJobSubscriptionRequest() {
    return { jobId: "" };
}
export const GetJobSubscriptionRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.jobId !== "") {
            writer.uint32(10).string(message.jobId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetJobSubscriptionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.jobId = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { jobId: isSet(object.jobId) ? globalThis.String(object.jobId) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.jobId !== "") {
            obj.jobId = message.jobId;
        }
        return obj;
    },
    create(base) {
        return GetJobSubscriptionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetJobSubscriptionRequest();
        message.jobId = object.jobId ?? "";
        return message;
    },
};
function createBaseGetJobSubscriptionResponse() {
    return { job: undefined };
}
export const GetJobSubscriptionResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.job !== undefined) {
            JobProgress.encode(message.job, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetJobSubscriptionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.job = JobProgress.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { job: isSet(object.job) ? JobProgress.fromJSON(object.job) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.job !== undefined) {
            obj.job = JobProgress.toJSON(message.job);
        }
        return obj;
    },
    create(base) {
        return GetJobSubscriptionResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetJobSubscriptionResponse();
        message.job = (object.job !== undefined && object.job !== null) ? JobProgress.fromPartial(object.job) : undefined;
        return message;
    },
};
function createBaseGetFilesystemNodeRequest() {
    return { path: undefined };
}
export const GetFilesystemNodeRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.path !== undefined) {
            writer.uint32(10).string(message.path);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetFilesystemNodeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.path = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { path: isSet(object.path) ? globalThis.String(object.path) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.path !== undefined) {
            obj.path = message.path;
        }
        return obj;
    },
    create(base) {
        return GetFilesystemNodeRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetFilesystemNodeRequest();
        message.path = object.path ?? undefined;
        return message;
    },
};
function createBaseGetFilesystemNodeResponse() {
    return { node: undefined, children: [] };
}
export const GetFilesystemNodeResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.node !== undefined) {
            FilesystemNode.encode(message.node, writer.uint32(10).fork()).join();
        }
        for (const v of message.children) {
            FilesystemNode.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetFilesystemNodeResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.node = FilesystemNode.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.children.push(FilesystemNode.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            node: isSet(object.node) ? FilesystemNode.fromJSON(object.node) : undefined,
            children: globalThis.Array.isArray(object?.children)
                ? object.children.map((e) => FilesystemNode.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.node !== undefined) {
            obj.node = FilesystemNode.toJSON(message.node);
        }
        if (message.children?.length) {
            obj.children = message.children.map((e) => FilesystemNode.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GetFilesystemNodeResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetFilesystemNodeResponse();
        message.node = (object.node !== undefined && object.node !== null)
            ? FilesystemNode.fromPartial(object.node)
            : undefined;
        message.children = object.children?.map((e) => FilesystemNode.fromPartial(e)) || [];
        return message;
    },
};
function createBaseCreateLocalEmulatorConfigsRequest() {
    return { configs: [] };
}
export const CreateLocalEmulatorConfigsRequest = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.configs) {
            NewLocalEmulatorConfig.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateLocalEmulatorConfigsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.configs.push(NewLocalEmulatorConfig.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            configs: globalThis.Array.isArray(object?.configs)
                ? object.configs.map((e) => NewLocalEmulatorConfig.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.configs?.length) {
            obj.configs = message.configs.map((e) => NewLocalEmulatorConfig.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return CreateLocalEmulatorConfigsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateLocalEmulatorConfigsRequest();
        message.configs = object.configs?.map((e) => NewLocalEmulatorConfig.fromPartial(e)) || [];
        return message;
    },
};
function createBaseCreateLocalEmulatorConfigsResponse() {
    return { configsCreated: [] };
}
export const CreateLocalEmulatorConfigsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.configsCreated) {
            LocalEmulatorConfig.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateLocalEmulatorConfigsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.configsCreated.push(LocalEmulatorConfig.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            configsCreated: globalThis.Array.isArray(object?.configsCreated)
                ? object.configsCreated.map((e) => LocalEmulatorConfig.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.configsCreated?.length) {
            obj.configsCreated = message.configsCreated.map((e) => LocalEmulatorConfig.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return CreateLocalEmulatorConfigsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateLocalEmulatorConfigsResponse();
        message.configsCreated = object.configsCreated?.map((e) => LocalEmulatorConfig.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGetLocalEmulatorConfigsRequest() {
    return { emulatorIds: [], clientId: 0 };
}
export const GetLocalEmulatorConfigsRequest = {
    encode(message, writer = new BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.emulatorIds) {
            writer.int32(v);
        }
        writer.join();
        if (message.clientId !== 0) {
            writer.uint32(16).int32(message.clientId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetLocalEmulatorConfigsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.emulatorIds.push(reader.int32());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.emulatorIds.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.clientId = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            emulatorIds: globalThis.Array.isArray(object?.emulatorIds)
                ? object.emulatorIds.map((e) => globalThis.Number(e))
                : [],
            clientId: isSet(object.clientId) ? globalThis.Number(object.clientId) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.emulatorIds?.length) {
            obj.emulatorIds = message.emulatorIds.map((e) => Math.round(e));
        }
        if (message.clientId !== 0) {
            obj.clientId = Math.round(message.clientId);
        }
        return obj;
    },
    create(base) {
        return GetLocalEmulatorConfigsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetLocalEmulatorConfigsRequest();
        message.emulatorIds = object.emulatorIds?.map((e) => e) || [];
        message.clientId = object.clientId ?? 0;
        return message;
    },
};
function createBaseGetLocalEmulatorConfigsResponse() {
    return { configs: [] };
}
export const GetLocalEmulatorConfigsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.configs) {
            LocalEmulatorConfig.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetLocalEmulatorConfigsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.configs.push(LocalEmulatorConfig.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            configs: globalThis.Array.isArray(object?.configs)
                ? object.configs.map((e) => LocalEmulatorConfig.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.configs?.length) {
            obj.configs = message.configs.map((e) => LocalEmulatorConfig.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GetLocalEmulatorConfigsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetLocalEmulatorConfigsResponse();
        message.configs = object.configs?.map((e) => LocalEmulatorConfig.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdateLocalEmulatorConfigsRequest() {
    return { configs: [] };
}
export const UpdateLocalEmulatorConfigsRequest = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.configs) {
            UpdatedLocalEmulatorConfig.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateLocalEmulatorConfigsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.configs.push(UpdatedLocalEmulatorConfig.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            configs: globalThis.Array.isArray(object?.configs)
                ? object.configs.map((e) => UpdatedLocalEmulatorConfig.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.configs?.length) {
            obj.configs = message.configs.map((e) => UpdatedLocalEmulatorConfig.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdateLocalEmulatorConfigsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateLocalEmulatorConfigsRequest();
        message.configs = object.configs?.map((e) => UpdatedLocalEmulatorConfig.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUpdateLocalEmulatorConfigsResponse() {
    return { configsUpdated: [] };
}
export const UpdateLocalEmulatorConfigsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.configsUpdated) {
            LocalEmulatorConfig.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateLocalEmulatorConfigsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.configsUpdated.push(LocalEmulatorConfig.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            configsUpdated: globalThis.Array.isArray(object?.configsUpdated)
                ? object.configsUpdated.map((e) => LocalEmulatorConfig.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.configsUpdated?.length) {
            obj.configsUpdated = message.configsUpdated.map((e) => LocalEmulatorConfig.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UpdateLocalEmulatorConfigsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateLocalEmulatorConfigsResponse();
        message.configsUpdated = object.configsUpdated?.map((e) => LocalEmulatorConfig.fromPartial(e)) || [];
        return message;
    },
};
function createBaseDeleteLocalEmulatorConfigsRequest() {
    return { ids: [] };
}
export const DeleteLocalEmulatorConfigsRequest = {
    encode(message, writer = new BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.ids) {
            writer.int32(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteLocalEmulatorConfigsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.ids.push(reader.int32());
                        continue;
                    }
                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.ids.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e) => globalThis.Number(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.ids?.length) {
            obj.ids = message.ids.map((e) => Math.round(e));
        }
        return obj;
    },
    create(base) {
        return DeleteLocalEmulatorConfigsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteLocalEmulatorConfigsRequest();
        message.ids = object.ids?.map((e) => e) || [];
        return message;
    },
};
function createBaseDeleteLocalEmulatorConfigsResponse() {
    return { configsDeleted: [] };
}
export const DeleteLocalEmulatorConfigsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.configsDeleted) {
            LocalEmulatorConfig.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteLocalEmulatorConfigsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.configsDeleted.push(LocalEmulatorConfig.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            configsDeleted: globalThis.Array.isArray(object?.configsDeleted)
                ? object.configsDeleted.map((e) => LocalEmulatorConfig.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.configsDeleted?.length) {
            obj.configsDeleted = message.configsDeleted.map((e) => LocalEmulatorConfig.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return DeleteLocalEmulatorConfigsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeleteLocalEmulatorConfigsResponse();
        message.configsDeleted = object.configsDeleted?.map((e) => LocalEmulatorConfig.fromPartial(e)) || [];
        return message;
    },
};
export const LibraryServiceDefinition = {
    name: "LibraryService",
    fullName: "retrom.LibraryService",
    methods: {
        updateLibrary: {
            name: "UpdateLibrary",
            requestType: UpdateLibraryRequest,
            requestStream: false,
            responseType: UpdateLibraryResponse,
            responseStream: false,
            options: {},
        },
        updateLibraryMetadata: {
            name: "UpdateLibraryMetadata",
            requestType: UpdateLibraryMetadataRequest,
            requestStream: false,
            responseType: UpdateLibraryMetadataResponse,
            responseStream: false,
            options: {},
        },
        deleteLibrary: {
            name: "DeleteLibrary",
            requestType: DeleteLibraryRequest,
            requestStream: false,
            responseType: DeleteLibraryResponse,
            responseStream: false,
            options: {},
        },
        deleteMissingEntries: {
            name: "DeleteMissingEntries",
            requestType: DeleteMissingEntriesRequest,
            requestStream: false,
            responseType: DeleteMissingEntriesResponse,
            responseStream: false,
            options: {},
        },
    },
};
export const PlatformServiceDefinition = {
    name: "PlatformService",
    fullName: "retrom.PlatformService",
    methods: {
        getPlatforms: {
            name: "GetPlatforms",
            requestType: GetPlatformsRequest,
            requestStream: false,
            responseType: GetPlatformsResponse,
            responseStream: false,
            options: {},
        },
        deletePlatforms: {
            name: "DeletePlatforms",
            requestType: DeletePlatformsRequest,
            requestStream: false,
            responseType: DeletePlatformsResponse,
            responseStream: false,
            options: {},
        },
        updatePlatforms: {
            name: "UpdatePlatforms",
            requestType: UpdatePlatformsRequest,
            requestStream: false,
            responseType: UpdatePlatformsResponse,
            responseStream: false,
            options: {},
        },
    },
};
export const GameServiceDefinition = {
    name: "GameService",
    fullName: "retrom.GameService",
    methods: {
        getGames: {
            name: "GetGames",
            requestType: GetGamesRequest,
            requestStream: false,
            responseType: GetGamesResponse,
            responseStream: false,
            options: {},
        },
        deleteGames: {
            name: "DeleteGames",
            requestType: DeleteGamesRequest,
            requestStream: false,
            responseType: DeleteGamesResponse,
            responseStream: false,
            options: {},
        },
        updateGames: {
            name: "UpdateGames",
            requestType: UpdateGamesRequest,
            requestStream: false,
            responseType: UpdateGamesResponse,
            responseStream: false,
            options: {},
        },
        deleteGameFiles: {
            name: "DeleteGameFiles",
            requestType: DeleteGameFilesRequest,
            requestStream: false,
            responseType: DeleteGameFilesResponse,
            responseStream: false,
            options: {},
        },
        updateGameFiles: {
            name: "UpdateGameFiles",
            requestType: UpdateGameFilesRequest,
            requestStream: false,
            responseType: UpdateGameFilesResponse,
            responseStream: false,
            options: {},
        },
    },
};
export const MetadataServiceDefinition = {
    name: "MetadataService",
    fullName: "retrom.MetadataService",
    methods: {
        getGameMetadata: {
            name: "GetGameMetadata",
            requestType: GetGameMetadataRequest,
            requestStream: false,
            responseType: GetGameMetadataResponse,
            responseStream: false,
            options: {},
        },
        updateGameMetadata: {
            name: "UpdateGameMetadata",
            requestType: UpdateGameMetadataRequest,
            requestStream: false,
            responseType: UpdateGameMetadataResponse,
            responseStream: false,
            options: {},
        },
        getPlatformMetadata: {
            name: "GetPlatformMetadata",
            requestType: GetPlatformMetadataRequest,
            requestStream: false,
            responseType: GetPlatformMetadataResponse,
            responseStream: false,
            options: {},
        },
        updatePlatformMetadata: {
            name: "UpdatePlatformMetadata",
            requestType: UpdatePlatformMetadataRequest,
            requestStream: false,
            responseType: UpdatePlatformMetadataResponse,
            responseStream: false,
            options: {},
        },
        getIgdbSearch: {
            name: "GetIgdbSearch",
            requestType: GetIgdbSearchRequest,
            requestStream: false,
            responseType: GetIgdbSearchResponse,
            responseStream: false,
            options: {},
        },
        getIgdbGameSearchResults: {
            name: "GetIgdbGameSearchResults",
            requestType: GetIgdbGameSearchResultsRequest,
            requestStream: false,
            responseType: GetIgdbGameSearchResultsResponse,
            responseStream: false,
            options: {},
        },
        getIgdbPlatformSearchResults: {
            name: "GetIgdbPlatformSearchResults",
            requestType: GetIgdbPlatformSearchResultsRequest,
            requestStream: false,
            responseType: GetIgdbPlatformSearchResultsResponse,
            responseStream: false,
            options: {},
        },
    },
};
export const ClientServiceDefinition = {
    name: "ClientService",
    fullName: "retrom.ClientService",
    methods: {
        createClient: {
            name: "CreateClient",
            requestType: CreateClientRequest,
            requestStream: false,
            responseType: CreateClientResponse,
            responseStream: false,
            options: {},
        },
        getClients: {
            name: "GetClients",
            requestType: GetClientsRequest,
            requestStream: false,
            responseType: GetClientsResponse,
            responseStream: false,
            options: {},
        },
        updateClients: {
            name: "UpdateClients",
            requestType: UpdateClientsRequest,
            requestStream: false,
            responseType: UpdateClientsResponse,
            responseStream: false,
            options: {},
        },
        deleteClients: {
            name: "DeleteClients",
            requestType: DeleteClientsRequest,
            requestStream: false,
            responseType: DeleteClientsResponse,
            responseStream: false,
            options: {},
        },
    },
};
export const ServerServiceDefinition = {
    name: "ServerService",
    fullName: "retrom.ServerService",
    methods: {
        getServerInfo: {
            name: "GetServerInfo",
            requestType: GetServerInfoRequest,
            requestStream: false,
            responseType: GetServerInfoResponse,
            responseStream: false,
            options: {},
        },
        getServerConfig: {
            name: "GetServerConfig",
            requestType: GetServerConfigRequest,
            requestStream: false,
            responseType: GetServerConfigResponse,
            responseStream: false,
            options: {},
        },
        updateServerConfig: {
            name: "UpdateServerConfig",
            requestType: UpdateServerConfigRequest,
            requestStream: false,
            responseType: UpdateServerConfigResponse,
            responseStream: false,
            options: {},
        },
    },
};
export const EmulatorServiceDefinition = {
    name: "EmulatorService",
    fullName: "retrom.EmulatorService",
    methods: {
        createEmulators: {
            name: "CreateEmulators",
            requestType: CreateEmulatorsRequest,
            requestStream: false,
            responseType: CreateEmulatorsResponse,
            responseStream: false,
            options: {},
        },
        getEmulators: {
            name: "GetEmulators",
            requestType: GetEmulatorsRequest,
            requestStream: false,
            responseType: GetEmulatorsResponse,
            responseStream: false,
            options: {},
        },
        updateEmulators: {
            name: "UpdateEmulators",
            requestType: UpdateEmulatorsRequest,
            requestStream: false,
            responseType: UpdateEmulatorsResponse,
            responseStream: false,
            options: {},
        },
        deleteEmulators: {
            name: "DeleteEmulators",
            requestType: DeleteEmulatorsRequest,
            requestStream: false,
            responseType: DeleteEmulatorsResponse,
            responseStream: false,
            options: {},
        },
        createEmulatorProfiles: {
            name: "CreateEmulatorProfiles",
            requestType: CreateEmulatorProfilesRequest,
            requestStream: false,
            responseType: CreateEmulatorProfilesResponse,
            responseStream: false,
            options: {},
        },
        getEmulatorProfiles: {
            name: "GetEmulatorProfiles",
            requestType: GetEmulatorProfilesRequest,
            requestStream: false,
            responseType: GetEmulatorProfilesResponse,
            responseStream: false,
            options: {},
        },
        updateEmulatorProfiles: {
            name: "UpdateEmulatorProfiles",
            requestType: UpdateEmulatorProfilesRequest,
            requestStream: false,
            responseType: UpdateEmulatorProfilesResponse,
            responseStream: false,
            options: {},
        },
        deleteEmulatorProfiles: {
            name: "DeleteEmulatorProfiles",
            requestType: DeleteEmulatorProfilesRequest,
            requestStream: false,
            responseType: DeleteEmulatorProfilesResponse,
            responseStream: false,
            options: {},
        },
        getDefaultEmulatorProfiles: {
            name: "GetDefaultEmulatorProfiles",
            requestType: GetDefaultEmulatorProfilesRequest,
            requestStream: false,
            responseType: GetDefaultEmulatorProfilesResponse,
            responseStream: false,
            options: {},
        },
        updateDefaultEmulatorProfiles: {
            name: "UpdateDefaultEmulatorProfiles",
            requestType: UpdateDefaultEmulatorProfilesRequest,
            requestStream: false,
            responseType: UpdateDefaultEmulatorProfilesResponse,
            responseStream: false,
            options: {},
        },
        deleteDefaultEmulatorProfiles: {
            name: "DeleteDefaultEmulatorProfiles",
            requestType: DeleteDefaultEmulatorProfilesRequest,
            requestStream: false,
            responseType: DeleteDefaultEmulatorProfilesResponse,
            responseStream: false,
            options: {},
        },
        createLocalEmulatorConfigs: {
            name: "CreateLocalEmulatorConfigs",
            requestType: CreateLocalEmulatorConfigsRequest,
            requestStream: false,
            responseType: CreateLocalEmulatorConfigsResponse,
            responseStream: false,
            options: {},
        },
        getLocalEmulatorConfigs: {
            name: "GetLocalEmulatorConfigs",
            requestType: GetLocalEmulatorConfigsRequest,
            requestStream: false,
            responseType: GetLocalEmulatorConfigsResponse,
            responseStream: false,
            options: {},
        },
        updateLocalEmulatorConfigs: {
            name: "UpdateLocalEmulatorConfigs",
            requestType: UpdateLocalEmulatorConfigsRequest,
            requestStream: false,
            responseType: UpdateLocalEmulatorConfigsResponse,
            responseStream: false,
            options: {},
        },
        deleteLocalEmulatorConfigs: {
            name: "DeleteLocalEmulatorConfigs",
            requestType: DeleteLocalEmulatorConfigsRequest,
            requestStream: false,
            responseType: DeleteLocalEmulatorConfigsResponse,
            responseStream: false,
            options: {},
        },
    },
};
export const JobServiceDefinition = {
    name: "JobService",
    fullName: "retrom.JobService",
    methods: {
        getJobs: {
            name: "GetJobs",
            requestType: GetJobsRequest,
            requestStream: false,
            responseType: GetJobsResponse,
            responseStream: true,
            options: {},
        },
        getJobSubscription: {
            name: "GetJobSubscription",
            requestType: GetJobSubscriptionRequest,
            requestStream: false,
            responseType: GetJobSubscriptionResponse,
            responseStream: true,
            options: {},
        },
    },
};
export const FileExplorerServiceDefinition = {
    name: "FileExplorerService",
    fullName: "retrom.FileExplorerService",
    methods: {
        getFilesystemNode: {
            name: "GetFilesystemNode",
            requestType: GetFilesystemNodeRequest,
            requestStream: false,
            responseType: GetFilesystemNodeResponse,
            responseStream: false,
            options: {},
        },
    },
};
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
